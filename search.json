[{"title":"Git Bash配置多个Github用户","url":"/2024/09/30/Git-bash%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAGithub%E7%94%A8%E6%88%B7/","content":"其实有两种方法，第一种比较简单粗暴但是有效，第二种需要配置各种比较麻烦，但是一劳永逸。\n 方案一\n对于 windows 系统， 选择控制面板 =》 用户账户 =》凭据管理器 =》windows 凭据，删除里面类似 git 相关的的用户信息（以 git 打头的相关数据）。 这样你在敲 git push 就会弹出对话框让你重新输入用户名和密码。 输入你要更改的用户名和密码就可以了。\n 方案二\n 注册 Github 账号\n首先肯定得需要多个 Github 账号，这里用两个作为示范\n 生成新 ssh key\n打开 git bash，输入~/.ssh进入到.ssh 文件夹\n~/.ssh\n在.ssh 目录下，可以将原有的 id_rsa 和 id_rsa.pub 删掉，然后输入ssh-keygen -t rsa -C &quot;你的第一个github邮箱地址&quot;\nssh-keygen -t rsa -C 2461298052@qq.com\n然后输入并回车(这个是私钥的名称，可以随意取)，这里我就用 github 的用户名：id_rsa_xiansakana\nid_rsa_xiansakana\n之后输入密码和再一次确认密码可以为空，回车。\n然后在.ssh 目录下会出现私钥 id_rsd_xiansakana 和公钥 id_rsa_xiansakana.pub。\n打开公钥 id_rsa_xiansakana.pub，将内容 copy 到第一个 github 的 SSH keys 中。\n同理，配置第二个 github 邮箱地址，并将公钥 id_rsa_saltedfishcj.pub 的内容 copy 到第二个 github 的 SSH keys 中\nssh-keygen -t rsa -C saltedfishcj@gmail.comid_rsa_saltedfishcj\n 添加 ssh key\n默认 SSH 只会读取id_rsa，所以为了让 SSH 识别新的私钥，需要将其添加到SSH agent。\n如果报错：Could not open a connection to your authentication agent.无法连接到 ssh agent，可执行ssh-agent命令后再执行ssh-add ~/.ssh/id_rsa_xiansakana命令。\nssh-agent bashssh-add ~/.ssh/id_rsa_xiansakanassh-add ~/.ssh/id_rsa_saltedfishcj\n 配置 config 文件\n然后在.ssh 目录下，新建一个 config 文件（如果无），命令：touch config，再对 config 文件进行编辑\ntouch config\n#Default 第一个账号(2461298052@qq.com)Host xiansakanaHostName github.comPreferredAuthentications publickeyIdentityFile ~&#x2F;.ssh&#x2F;id_rsa_xiansakana#second 第二个账号（saltedfishcj@gmail.com）Host saltedfishcjHostName github.comPreferredAuthentications publickeyIdentityFile ~&#x2F;.ssh&#x2F;id_rsa_saltedfishcj\n\n其中 Host 后的名字可以随意方便自己记忆，但 HostName 必须为 github.com(或者其它 git 地址)。\n\n 测试配置\n使用命令：ssh -T git@xiansakana，\nssh -T git@xiansakana\n如果看到下面的命令表示配置成功了。\nHi xiansakana! You've successfully authenticated, but GitHub does not provide shell access.\n同理\nssh -T git@saltedfishcj\n查看当前用户\nssh -T git@github.com\n查看当前密钥\nssh-add -l\n切换账号\ngit config --global user.name \"name\"git config --global user.email \"email\"\n不过通常应该是可以用上面添加 ssh key 的方法来切换\nssh-agent bashssh-add ~/.ssh/id_rsa_xiansakanassh-add ~/.ssh/id_rsa_saltedfishcj\n查看配置\ngit config --global --list\n‍\n","categories":["计算机"],"tags":["Git"]},{"title":"Git常用版本控制指令","url":"/2024/09/30/Git%E5%B8%B8%E7%94%A8%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4/","content":" branch\ngit clone 获取指定分支\ngit clone -b &lt;分支名&gt; &lt;仓库地址&gt;\n查看全部分支\ngit branch -a\n将本地分支与远程同名分支相关联\ngit push -u origin &lt;本地分支名&gt;\n创建本地分支\ngit checkout -b &lt;本地分支名&gt;\n拉取指定的某一个分支\ngit checkout -b &lt;本地分支名&gt; origin/&lt;远程分支名&gt;\n\n该命令的作用是：checkout 远程仓库 origin 的分支“dev”，在本地起名为“dev”分支，并切换到本地的“dev”分支。\n\n拉取该分支的最新代码\ngit pull origin dev\n pull\n将远程指定分支拉取到本地指定分支上\ngit pull origin &lt;远程分支名&gt;:&lt;本地分支名&gt;\n将远程指定分支拉取到本地当前分支上\ngit pull origin &lt;远程分支名&gt;\n将与本地当前分支同名的远程分支拉取到本地当前分支上，需先关联远程分支。\ngit pull\ngit 强制覆盖本地命令\ngit fetch --allgit reset --hard origin/master\n push\n将本地当前分支推送到远程指定分支上\ngit push origin &lt;本地分支名&gt;:&lt;远程分支名&gt;\n将本地当前分支推送到与本地当前分支同名的远程分支上\ngit push origin &lt;本地分支名&gt;\n将本地当前分支推送到与本地当前分支同名的远程分支上，需先关联远程分支\ngit push\n 删除远端 commit\n先删除本地的几次提交，&quot;HEAD~1&quot;里面的 1 代表撤回几次提交\ngit reset --soft HEAD~1\n然后强制性将本地覆盖性的提交到远端，达到删除的目的，&quot;branchname&quot;是你的分支名称\ngit push origin branchname --force\n merge\n切换到​​main​​分支：首先确保你当前在main分支上。\ngit checkout main\n拉取最新的​​main​​分支代码：确保你的main分支是最新的。\ngit pull origin main\n合并​​dev​​分支：将dev分支合并到main分支上。\ngit merge dev\n如果有冲突发生，在合并过程中 Git 会提示你进行解决。你需要手动解决冲突，并提交合并后的结果。\n推送到远程仓库：合并完成后，将更新的main分支推送到远程仓库。\ngit push origin main\n pull 和 fetch\n​git pull​ 和 git fetch​ 都是用于从远程仓库获取更新的命令，但它们的作用和使用场景有所不同。\n ​git fetch​\n​git fetch​ 从远程仓库下载所有分支的最新提交，但不会修改你当前的工作目录。它只是将这些更新存储在你的本地仓库中。你需要手动合并或检查这些更新。\n使用场景：\n\n想要查看远程仓库的最新状态，而不影响本地的代码。\n在进行 git rebase​ 或 git merge​ 前，先获取最新的提交信息。\n\ngit fetch\n ​git pull​\n​git pull​ 是一个高层次的命令，它实际上是 git fetch​ 和 git merge​ 的组合。它从远程仓库获取最新的提交，并自动将这些更新合并到你当前的分支中。\n使用场景：\n\n想要快速更新你当前分支的代码，使之与远程分支保持同步。\n对于非协作性的开发，想要快速获取并应用最新的更改。\n\ngit pull\n 比较\n\n\n获取更新的方式：\n\n​git fetch​ 只下载更新，不改变当前分支。\n​git pull​ 下载更新并自动合并到当前分支。\n\n\n\n控制程度：\n\n​git fetch​ 提供了更多的控制权，可以手动查看和合并更新。\n​git pull​ 简化了流程，但可能会引起自动合并冲突。\n\n\n\n使用场景：\n\n​git fetch​ 更适合在需要精细控制合并过程的情况下使用。\n​git pull​ 适合在需要快速同步并更新当前分支时使用。\n\n\n\n在实际使用中，建议先使用 git fetch​ 查看更新，然后再决定是否以及如何合并这些更新。这样可以避免不必要的合并冲突和问题。\n","categories":["计算机"],"tags":["Git"]},{"title":"Hexo语法转义","url":"/2024/10/01/Hexo%E8%AF%AD%E6%B3%95%E8%BD%AC%E4%B9%89/","content":"! &amp;#33;         — 惊叹号 Exclamation mark” &amp;#34; &quot;  — 双引号 Quotation mark# &amp;#35;         — 数字标志 Number sign$ &amp;#36;         — 美元标志 Dollar sign% &amp;#37;         — 百分号 Percent sign&amp; &amp;#38; &amp;   — And&#x2F;Ampersand‘ &#39;         — 单引号 Apostrophe( &amp;#40;         — 小括号左边部分 Left parenthesis) &amp;#41;         — 小括号右边部分 Right parenthesis* &amp;#42;         — 星号 Asterisk+ &amp;#43;         — 加号 Plus sign&lt; &amp;#60; &lt;    — 小于号 Less than&#x3D; &amp;#61;         — 等于符号 Equals sign- &amp;#45; &amp;minus; — 减号&gt; &amp;#62; &gt;    — 大于号 Greater than? &amp;#63;         — 问号 Question mark@ &amp;#64;         — At[ &amp;#91;         — 中括号左边部分 Left square bracket\\ &amp;#92;         — 反斜杠 Reverse solidus (backslash)] &amp;#93;         — 中括号右边部分 Right square bracket&#96; &#96;         - 重音号 backquote&#x2F;grave accent&#123; &amp;#123;        — 大括号左边部分 Left curly brace| &amp;#124;        — 竖线Vertical bar&#125; &amp;#125;        — 大括号右边部分 Right curly brace\n","categories":["笔记"],"tags":["Hexo"]},{"title":"Markdown语法参考","url":"/2024/09/30/Markdown%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83/","content":" Typora 的 Markdown 语法\n 标题\n# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n 一级标题\n 二级标题\n 三级标题\n 四级标题\n 五级标题\n 六级标题\n 分割线\n//分割线表示---------&lt;hr style=\"border:1px solid red;\"&gt;\n\n\n\n\n\n\n 字体\n 字体类型和颜色\n&lt;font face=\"kaiti\"&gt;这里是楷体&lt;/font&gt;&lt;br/&gt;&lt;font face=\"heiti\"&gt;这里是黑体&lt;/font&gt;&lt;br/&gt;&lt;font face=\"simsun\"&gt;这里是宋体&lt;/font&gt;&lt;br/&gt;&lt;font face=\"Arial\"&gt;This is Arial&lt;/font&gt;&lt;br/&gt;&lt;font face=\"Arial Narrow\"&gt;This is Arial Narrow&lt;/font&gt;&lt;br/&gt;&lt;font face=\"Times New Roman\"&gt;This is Times New Roman&lt;/font&gt;&lt;br/&gt;&lt;font face=\"Calibri\"&gt;This is Calibri&lt;/font&gt;&lt;br/&gt;&lt;font color=\"red\"&gt;&lt;b&gt;红色加粗&lt;/b&gt;&lt;/font&gt;&lt;br/&gt;&lt;font style=\"background: linear-gradient( to right，#ff1616，#ff7716，#ffdc16,#36c945，#10a5ce，#Of0096，#a51eff，#ff1616); \"&gt;这是七色光彩背景颜色&lt;/font&gt;\n这里是楷体\n这里是黑体\n这里是宋体\n这里是幼圆\n这里是华文彩云\nThis is Arial\nThis is Arial Narrow\nThis is Times New Roman\nThis is Calibri\n红色加粗\n这是七色光彩背景颜色\n 其他\n==高亮==~~删除线~~**粗\\*\\***体**_斜体_**_粗_\\***\\*_斜_**_**体**_&lt;u&gt;下划线&lt;/u&gt;:smile:$\\theta=x^2$\n高亮\n删除线\n粗**体\n斜体\n粗***斜_*​ *_​体*\n下划线\n😄\nemoji 链接\nθ=x2\\theta=x^2θ=x2\n 转义\n\\\\ 反斜杠\\` 反引号 \\* 星号\\_ 下划线\\&#123;\\&#125; 大括号\\[\\] 中括号\\(\\) 小括号\\# 井号\\+ 加号\\- 减号\\. 英文句号\\! 感叹号&amp;#124; 竖号\n\\ 反斜杠\n` 反引号 * 星号\n_ 下划线\n{} 大括号\n[] 中括号\n() 小括号\n# 井号\n+ 加号\n- 减号\n. 英文句号\n! 感叹号\n|  竖号\n 引用\n//一级引用用一个&gt;来表示//二级引用用两个&gt;来表示//三级引用用三个&gt;来表示\n\n一级引用\n\n\n\n二级引用\n\n\n\n\n\n三级引用\n\n\n\n 脚注\n一键三连[^1]\n一键三连[1]\n 列表\n 有序列表\n//有序列表## 有序列表1. 有序列表 12. 有序列表 23. 有序列表 3   1. 子序列 1   2. 子序列 2   3. 子序列 3\n\n有序列表 1\n有序列表 2\n有序列表 3\n\n子序列 1\n子序列 2\n子序列 3\n\n\n\n 无序列表\n//无序列表## 无序列表- 无序列表 1* 无序列表 2  - [ ] 子序列 1  - [ ] 子序列 2  - [x] 子序列 3- 无序列表 3  - 子序列 1  * 子序列 2  - 子序列 3\n\n无序列表 1\n\n\n无序列表 2\n\n[ ] 子序列 1\n[ ] 子序列 2\n[x] 子序列 3\n\n\n\n\n\n无序列表 3\n\n子序列 1\n\n\n子序列 2\n\n\n子序列 3\n\n\n\n 数学公式\n$$\\frac&#123;partial f&#125;&#123;\\partial x&#125; = \\sqrt[3]&#123;a_1&#125;x$$$$\\Gamma(z) = \\int_0^\\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt \\tag&#123;2&#125;$$$$\\lim_&#123;a\\to\\infty&#125;a=\\infty\\lim_&#123;b\\rightarrow-\\infty&#125;=-\\infty \\tag&#123;3&#125;$$$$x(t)=\\sum_&#123;k=-\\infty&#125;^&#123;\\infty&#125;a_ke^&#123;jkw_0t&#125; \\tag&#123;4&#125;$$\n∂f∂x=a13x(1)\\frac{\\partial f}{\\partial x} = \\sqrt[3]{a_1}x \\tag{1}\n∂x∂f​=3a1​​x(1)\nΓ(z)=∫0∞tz−1e−tdt(2)\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt \\tag{2}\nΓ(z)=∫0∞​tz−1e−tdt(2)\nlim⁡a→∞a=∞lim⁡b→−∞=−∞(3)\\lim_{a\\to\\infty}a=\\infty\\lim_{b\\rightarrow-\\infty}=-\\infty \\tag{3}\na→∞lim​a=∞b→−∞lim​=−∞(3)\nx(t)=∑k=−∞∞akejkw0t(4)x(t)=\\sum_{k=-\\infty}^{\\infty}a_ke^{jkw_0t} \\tag{4}\nx(t)=k=−∞∑∞​ak​ejkw0​t(4)\n$$\\vec&#123;F&#125;=ma\\\\\\leq\\\\\\geq$$\nF⃗=maa≤bb≥c\\vec{F}=ma\\\\\na\\leq b\\\\\nb\\geq c\nF=maa≤bb≥c\n 希腊字母\n$\\alpha$, $\\beta$, $\\gamma$, $\\delta$, $\\epsilon$\\$\\varepsilon$, $\\eta$, $\\theta$, $\\vartheta$, $\\kappa$\\$\\pi$, $\\rho$, $\\lambda$, $\\mu$, $\\phi$\\$\\varphi$, $\\omega$, $\\tau$, $\\psi$, $\\Psi$\\$\\xi$, $\\iota$, $\\zeta$, $\\nu$, $\\upsilon$\\$\\sigma$, $\\chi$, $\\omicron$, $\\Xi$, $\\Upsilon$\nα\\alphaα, β\\betaβ, γ\\gammaγ, δ\\deltaδ, ϵ\\epsilonϵ\nε\\varepsilonε, η\\etaη, θ\\thetaθ, ϑ\\varthetaϑ, κ\\kappaκ\nπ\\piπ, ρ\\rhoρ, λ\\lambdaλ, μ\\muμ, ϕ\\phiϕ\nφ\\varphiφ, ω\\omegaω, τ\\tauτ, ψ\\psiψ, Ψ\\PsiΨ\nξ\\xiξ, ι\\iotaι, ζ\\zetaζ, ν\\nuν, υ\\upsilonυ\nσ\\sigmaσ, χ\\chiχ, ο\\omicronο, Ξ\\XiΞ, Υ\\UpsilonΥ\n 矩阵\n$$\\begin&#123;Bmatrix&#125;   a &amp; b \\\\   c &amp; d\\end&#123;Bmatrix&#125; \\tag&#123;1&#125;$$\n{abcd}(1)\\begin{Bmatrix}\n\ta &amp; b \\\\\n\tc &amp; d\n\\end{Bmatrix} \\tag{1}\n{ac​bd​}(1)\n$$\\begin&#123;bmatrix&#125;a &amp; b\\\\c &amp; d\\end&#123;bmatrix&#125; \\tag&#123;2&#125;$$\n[abcd](2)\\begin{bmatrix}\na &amp; b\\\\\nc &amp; d\n\\end{bmatrix} \\tag{2}\n[ac​bd​](2)\n$$\\begin&#123;vmatrix&#125;a &amp; b\\\\c &amp; d\\end&#123;vmatrix&#125; \\tag&#123;3&#125;$$\n∣abcd∣(3)\\begin{vmatrix}\na &amp; b\\\\\nc &amp; d\n\\end{vmatrix} \\tag{3}\n∣∣∣∣∣​ac​bd​∣∣∣∣∣​(3)\n$$\\left\\&#123;\\begin&#123;matrix&#125;1 &amp; 2 &amp; 3\\\\4 &amp; 5 &amp; 6\\\\7 &amp; 8 &amp; 9\\end&#123;matrix&#125;\\right\\&#125; \\tag&#123;4&#125;$$\n{123456789}(4)\\left\\{\n\\begin{matrix}\n1 &amp; 2 &amp; 3\\\\\n4 &amp; 5 &amp; 6\\\\\n7 &amp; 8 &amp; 9\n\\end{matrix}\n\\right\\} \\tag{4}\n⎩⎪⎨⎪⎧​147​258​369​⎭⎪⎬⎪⎫​(4)\n$$\\left[\\begin&#123;matrix&#125;1 &amp; 2 &amp; 3\\\\4 &amp; 5 &amp; 6\\\\7 &amp; 8 &amp; 9\\end&#123;matrix&#125;\\right] \\tag&#123;5&#125;$$\n[123456789](5)\\left[\n\\begin{matrix}\n1 &amp; 2 &amp; 3\\\\\n4 &amp; 5 &amp; 6\\\\\n7 &amp; 8 &amp; 9\n\\end{matrix}\n\\right] \\tag{5}\n⎣⎢⎡​147​258​369​⎦⎥⎤​(5)\n$$\\left(\\begin&#123;matrix&#125;1 &amp; 2 &amp; 3\\\\4 &amp; 5 &amp; 6\\\\7 &amp; 8 &amp; 9\\end&#123;matrix&#125;\\right) \\tag&#123;6&#125;$$\n(123456789)(6)\\left(\n\\begin{matrix}\n1 &amp; 2 &amp; 3\\\\\n4 &amp; 5 &amp; 6\\\\\n7 &amp; 8 &amp; 9\n\\end{matrix}\n\\right) \\tag{6}\n⎝⎛​147​258​369​⎠⎞​(6)\n$$\\begin&#123;Bmatrix&#125;1 &amp; 2 &amp; \\cdots &amp; 5\\\\6 &amp; 7 &amp; \\cdots &amp; 10\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\\\alpha &amp; \\alpha+1 &amp; \\cdots &amp; \\alpha+4\\end&#123;Bmatrix&#125;\\tag&#123;7&#125;$$\n{12⋯567⋯10⋮⋮⋱⋮αα+1⋯α+4}(7)\\begin{Bmatrix}\n1 &amp; 2 &amp; \\cdots &amp; 5\\\\\n6 &amp; 7 &amp; \\cdots &amp; 10\\\\\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\\n\\alpha &amp; \\alpha+1 &amp; \\cdots &amp; \\alpha+4\n\\end{Bmatrix}\\tag{7}\n⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​16⋮α​27⋮α+1​⋯⋯⋱⋯​510⋮α+4​⎭⎪⎪⎪⎪⎬⎪⎪⎪⎪⎫​(7)\n 多行等式对齐\n$$\\begin&#123;aligned&#125;a &amp;= b + c \\\\  &amp;= d + e + f\\end&#123;aligned&#125;$$\na=b+c=d+e+f\\begin{aligned}\na &amp;= b + c \\\\\n  &amp;= d + e + f\n\\end{aligned}\na​=b+c=d+e+f​\n 方程组、条件表达式\n$$\\begin&#123;cases&#125;3x + 5y +  z \\\\7x - 2y + 4z \\\\-6x + 3y + 2z\\end&#123;cases&#125;$$\n{3x+5y+z7x−2y+4z−6x+3y+2z\\begin{cases}\n3x + 5y +  z \\\\\n7x - 2y + 4z \\\\\n-6x + 3y + 2z\n\\end{cases}\n⎩⎪⎪⎨⎪⎪⎧​3x+5y+z7x−2y+4z−6x+3y+2z​\n$$f(n) =\\begin&#123;cases&#125;n/2,  &amp; \\text&#123;if &#125;n\\text&#123; is even&#125; \\\\3n+1, &amp; \\text&#123;if &#125;n\\text&#123; is odd&#125;\\end&#123;cases&#125;$$\nf(n)={n/2,if n is even3n+1,if n is oddf(n) =\n\\begin{cases}\nn/2,  &amp; \\text{if }n\\text{ is even} \\\\\n3n+1, &amp; \\text{if }n\\text{ is odd}\n\\end{cases}\nf(n)={n/2,3n+1,​if n is evenif n is odd​\n 间隔\n//紧贴 + 无空格 + 小空格 + 中空格 + 大空格 + 真空格 + 双真空格$$a\\!b + ab + a\\,b + a\\;b + a\\ b + a\\quad b + a\\qquad b$$\na ⁣b+ab+a b+a  b+a b+ab+aba\\!b + ab + a\\,b + a\\;b + a\\ b + a\\quad b + a\\qquad b\nab+ab+ab+ab+a b+ab+ab\n 表格\n 简易表格\n$$\\begin&#123;array&#125;&#123;|c|l|r|&#125;\t\\hline 1&amp;20&amp;3000\\\\\t\\hline 40&amp;500&amp;60000\\\\\t\\hline 7000&amp;80000&amp;9000000\\\\\t\\hline\\end&#123;array&#125;$$\n120300040500600007000800009000000\\begin{array}{|c|l|r|}\n\t\\hline 1&amp;20&amp;3000\\\\\n\t\\hline 40&amp;500&amp;60000\\\\\n\t\\hline 7000&amp;80000&amp;9000000\\\\\n\t\\hline\n\\end{array}\n1407000​2050080000​3000600009000000​​\n|参数|解释|  |:-:|:-:|//居中//|-:|-:|右对齐//|:-|:-|左对齐|enable|是否启用 nav 左侧项目按钮，仅控制左侧项目按钮||travelling|是否启用 nav 开往按钮|\n\n\n\n参数\n解释\n\n\n\n\nenable\n是否启用 nav 左侧项目按钮，仅控制左侧项目按钮\n\n\ntravelling\n是否启用 nav 开往按钮\n\n\n\n 真值表\n$$\\begin&#123;array&#125;&#123;cc|c&#125;\t       A&amp;B&amp;F\\\\\t\\hline 0&amp;0&amp;0\\\\\t       0&amp;1&amp;1\\\\\t       1&amp;0&amp;1\\\\\t       1&amp;1&amp;1\\\\\\end&#123;array&#125;$$\nABF000011101111\\begin{array}{cc|c}\n\t       A&amp;B&amp;F\\\\\n\t\\hline 0&amp;0&amp;0\\\\\n\t       0&amp;1&amp;1\\\\\n\t       1&amp;0&amp;1\\\\\n\t       1&amp;1&amp;1\\\\\n\\end{array}\nA0011​B0101​F0111​​\n 甘特图\n```mermaid\t\tgantt        dateFormat  YYYY-MM-DD        title 软件开发甘特图        section 设计        需求                      :done,    des1, 2014-01-06,2014-01-08        原型                      :active,  des2, 2014-01-09, 3d        UI设计                    :         des3, after des2, 5d        未来任务                   :         des4, after des3, 5d        section 开发        学习准备理解需求                      :crit, done, 2014-01-06,24h        设计框架                             :crit, done, after des2, 2d        开发                                 :crit, active, 3d        未来任务                              :crit, 5d        耍                                   :2d        section 测试        功能测试                              :active, a1, after des3, 3d        压力测试                               :after a1  , 20h        测试报告                               : 48h```\nganttdateFormat  YYYY-MM-DDtitle Work PlanFYP Topic Select                      :done,    des1, 2022-06-06,2022-09-15Preliminary Report                      :done,  des2, 2022-10-05,2022-10-30Final Report Framework: done, 2022-11-18, 2022-12-01Literature Reading                    :active,          2022-09-20,2023-03-18Interim Report :done, 2022-12-25, 2023-01-13Experiment Performing :active, 2022-11-23, 2023-03-01Data Analysis: 2023-02-22, 2023-04-10Final Report: 2023-03-01, 2023-04-28Oral Presentation: 2023-05-15, 2023-05-19\n 超链接\n[B 站](https://www.bilibili.com)[原神](./QQ截图20220110160242.png)[【静止画 MAD】FRIEND(https://i0.hdslb.com/bfs/archive/3fb28cc5eef41d048083c48e7539bdf9a7864440.jpg@560w_350h_100Q_1c.webp)[【静止画 MAD】FRIEND](https://www.bilibili.com/video/BV1uL411W7HT)&lt;iframe src=\"https://player.bilibili.com/player.html?aid=461536590&amp;bvid=BV1uL411W7HT&amp;cid=368370249&amp;p=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" &amp;danmaku=\"1\" width=\"90%\" height=\"360\"&gt; &lt;/iframe&gt;\nB 站\n【静止画 MAD】FRIEND\n【静止画 MAD】FRIEND\n\n\n\n 图片\n//在线图片![【静止画MAD】FRIEND](https://i0.hdslb.com/bfs/archive/3fb28cc5eef41d048083c48e7539bdf9a7864440.jpg@560w_350h_100Q_1c.webp)//本地图片![原神](./QQ截图20220110160242.png)\n​​\n 代码块\n`printf()`\nprintf()\n#include&lt;stdio.h&gt;int main()&#123;printf(\"hello world!\");return 0;&#125;\n UML 图表\n//下面是一个序列图```mermaidsequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样?```\nsequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br&#x2F;&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样?\n//下面是一个流程图```mermaidgraph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D```\ngraph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D\n\n关于 Mermaid 语法，参考 这儿,\n\n Flowchart 流程图\n//标准流程图源码格式st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op\nst&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op\n//标准流程图源码格式（横向）st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op\nst&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op\n\n\n\n点赞、投币、收藏 ↩︎\n\n\n\n","categories":["笔记"],"tags":["Markdown"]},{"title":"SpaceSniffer添加到右键菜单","url":"/2024/12/23/SpaceSniffer%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/","content":" 启动程序\n直接打开 SpaceSniffer.exe 即可。\n需要注意的是，如果待分析的目录中包含需要管理员权限操作的子目录或者子文件，需要以管理员身份启动软件才能正常分析，否则会抛出警告。\n启动后依次点击 Help &gt; command line help 可以查看命令行帮助文档：\n\n观察一下，scan 参数可以指定我们想要分析的目录，如果是在右键上，我们应该通过变量实时获取目标目录。\n 添加右键入口\n首先我们需要一个默认以管理员权限启动的 cmd.exe，cmd.exe 一般位于 C:\\WINDOWS\\system32 下，找到它然后复制一个新的程序并重命名为 cmda.exe：\n\n右键这个 cmda.exe，定位到 属性 &gt; 兼容性，勾选 以管理员身份运行此程序，然后确定，记下这个 cmda.exe 的路径 C:\\WINDOWS\\system32\\cmda.exe：\n\n打开注册表编辑器（win + r 然后输入 regedit 确定），定位到 HKEY_CLASSES_ROOT\\Directory\\shell，这个文件夹代表了 一般目录的右键菜单：\n\n可以看到我这里已经添加了四个入口，分别是 cmder, find, git bash 和将要添加的 SpaceSniffer。\n右键 shell，新建项，取名为 SpaceSniffer。\n修改 SpaceSniffer 项的 (默认) 为 使用 SpaceSniffer 分析这个目录的磁盘空间，这个字符串将出现在你的右键菜单中，可修改为其他的值。\n在 (默认) 值的同级环境中右键依次点击 新建值 &gt; 字符串值，取名为 Icon。\n双击 Icon，修改其值为 SpaceSniffer.exe 程序的路径；最后再新建一个 项，取名为 command。最终效果如下：\n\n双击 command 项，修改其默认值为：\n&quot;C:\\WINDOWS\\system32\\cmda.exe&quot; &quot;&#x2F;C start D:\\Portable\\spacesniffer\\SpaceSniffer.exe scan %1&quot;\n\n/C 表示执行其它程序\nstart 不会显示 cmd 的黑黢黢的窗口\nscan 路径 作为 SpaceSniffer.exe 的参数\n%1 变量动态获取当前目录路径\n\n","categories":["工具"],"tags":["SpaceSniffer","注册表"]},{"title":"亚特兰大流水账","url":"/2025/03/01/%E4%BA%9A%E7%89%B9%E5%85%B0%E5%A4%A7%E6%B5%81%E6%B0%B4%E8%B4%A6/","content":" 20250301\n突然意识到好久没有记日记了，决定从三月份的第一天开始，坚持记录点东西吧！因为我越来越发现之前的事情忘记太快了。今天 cjj 来找我说 3 月 14-18 号去亚特兰大玩儿，我想不是之前才去奥兰多的，结果就是想不起来啥时候。最后去翻了记账的日期才发觉是 1 月中旬，明明是不到两个月前的事情。之前那次也没怎么记录，现在如果想记也想不起来很多细节了，所以就从这次开始吧。\n刚刚已经确定也定好机票了，计划是 3 月 14 号早上 5 点半的飞机从 Newark 出发，返程是 18 号晚上 8 点 36 分的飞机，差不多一共 5 天。成员的话其实跟上次奥兰多一样，两男一女（我，cjj，byl），咳咳不要想多，大家都是正常的同学关系。不过 cjj 给我说的是不确定另一个女生去不去，打算过两天再问他了。\n 20250314\n早上 3 点多准备出发了。我是前一天晚上就去了他们家顺便到时候一起出发。\n\n到机场了，这个安检仪器怎么给我一种磁共振的感觉笑死。\n\n快降落了，结果外面天还几乎没亮。\n\n7.40 多，刚下飞机，给我困的感觉站着都能睡着了，毕竟 3 点多就出发去机场了，昨晚根本就没怎么睡觉。落地之后还需要坐机场的 ground transportation 去别的站点才可以继续乘坐公共交通。\n\n在机场看到一个漂亮小姐姐，只能拍背影了，正面不好意思拍 hhh。\n\n本来准备做地铁然后转 bus 去租车的地方，结果那个破机器刷了半天卡都买不了票，而且三个人要 10.5，算来算去跟直接打车差不多，最后还得是有个地铁的 staff 给我们说可以坐免费的 shuttle。所以最后还是决定去坐了 shuttle，不过不能直达目的地，本来还得是转一次公交的，但是又有好心人提醒我们有那个租车公司专车接送的 shuttle 能给我们免费送到 car rental 的地方，最后还是给了司机 5🔪 小费表示感谢。\n这次租的车是 NISSAN 的 SUV，反正出门 SUV 就完事了，宽敞好开。5 天一共 200 多，不过不含保险，（保险是他们分开提前网上买的，不然现场在租车这边买会贵很多），还是挺划算的。如果不租车在美国简直是寸步难行，之前去佛州就深有体会了。\n\n不过一晚上没怎么睡觉，大家都感觉有点疲劳驾驶了哈哈，累的不行。去吃午饭前打算先去顺路 starbucks 买点喝的，提前在网上预定然后到时候直接提了就走那种。不过大意的是，我直接给 starbucks（经停点）和 beef grill 的（目的的）弄反了，再加上这个路况确实挺复杂，有时候稍不注意就走错直接下出口了，导致绕了不少远路，耽误了不少时间。\n幸运的是，刚好在中午 11 点左右顺利到达了 beef grill，在这家吃的自助烤肉，一个人只要 20🔪 就能随便吃，太便宜了，感觉随便吃都能回本。还有很多配菜比如水果沙拉鸡蛋炒饭等，只能说吃的撑撑的，性价比超高。\n\n吃完午饭之后我们去了附近一个国家公园（因为实在想不起名字了）转了一圈就去机场接另一个小伙伴了，国家公园里看到的。\n\n还是由于沟通问题，她的航班下午才到达，而且是 18 号中午的飞机（我们三都是晚上），所以最后不得不修改这次原定的计划。不过对于我来说其实无所谓了，毕竟我都是那种，只要不用我做攻略我就可以随便跟着玩，从来不会指手画脚甚至拖累别人。\n傍晚时候终于到了住宿的地方，感觉类似于国内的那种民宿，参观一下。\n\n本来累了一天打算晚上吃点靠谱的，结果网上一搜周围根本没什么好吃的，甚至小红书都搜不到几个，重点是很多店都打烊了，要知道当时才晚上 7 点多。\n最后去吃的一家叫 han mi 韩国菜，只能说比较抽象。毕竟这附近实在是太村了，根本没有几个正经好吃的地方。\n\n其实我觉得还好，当时他们三吃的一样，最后我选的一个不同的，结果就是我这还是最好吃的那个。菜单上看起来吹的天花乱坠结果到了才发现是泡面，然后说的烤肉其实也应该是预制菜，肯定不是现烤的那种，给我旁边那位直接整破防了笑死。\n\n回去的路上，现在能看出多村了吧，没路灯那种。\n\n终于到了，这个角度拍起来还可以。\n\n洗了个澡躺床上刷手机太困了都不晓得啥时候睡着了。\n 20250315\n由于昨晚睡的比较晚，再加上前一天基本上没怎么睡，所以基本上中午才出发。经过了一个叫 Point Park 的地方，好像当时没开放就没进去了。\n\n然后去附近的 Lookout Mountain 下，这跟国内果然不一样，都没有护栏的，那一个平台下面就是悬崖，如果一不小心真的是有可能失足掉下去的。\n\n走进看看\n\n\n右边其实还有个石头可以站人，过去看了下腿软了都。\n\n由于时间比较赶，午饭只好提前预定了附近 Wendy’s 的汉堡快餐然后直接到店自提路上解决了。\n之后就是两个小时的车程去往 gatlinburg，不过真正的目的地是旁边的 cades cove，gatlinburg 只是晚上的落脚点，毕竟还是相当于市区，而 cades cove 就完全是所谓的荒郊野外了，真的一点信号都没得，全程手机都是 SOS 甚至无信号。后果就是，进去了之后想用导航都没办法，只能凭着感觉走了，除非提前下好离线地图或者导上。\n至于为啥要去这个 cades cove，他们主要是想要去看黑熊，不过转了大半天连影子没见着，警示牌倒是有不少。\n\n最后天快黑了我们只好向旁边的 Gatlinburg 市区赶回去了，顺利入住 Gatlinburg Mountain Inn。\n\n周围的环境大概是这样，感觉还可以，人均 50 左右，还是比较便宜的。\n\n没想到酒店还有一本圣经。\n\n安顿好了之后我们就去附近吃饭了，今晚吃的是一家名叫 Chesapeaks 的海鲜店，感觉还是相对来说挺高档的（跟昨晚的相比）。重点是冰水没有纽约的那种特有的铁锈味（每次在纽约去外面吃饭那种免费的冰水都是一股熟悉的自来水味道）。\n\n具体点了些啥我也不记得了，毕竟作为懒人只会吃，看最终的图就完事了，不过面包是送的，好像大多数高档一点的店都会有这种上来送面包的习惯，感觉都能吃饱了。\n\n\n\n\n回到宾馆后有两个人开始发癫枕头互殴乐死我了，具体还是不放视频了。\n半夜竟然开始下雨了，去车里拿了瓶水，给我冻的直啰嗦。\n\n 20250316\n今天早上出发时间算的上中规中矩吧，看看街景。\n\n早餐去的这家 Crocketts 听说有 100 多年历史了，我们早上起床八九点就开始线上预约，结果 11 点到那前面还有两桌需要等。\n\n菜单竟然是张报纸，真是活久见。\n\n最后四人各点了一份然后外加一些甜点，看起来不多，反正我是吃饱了，甜点最后都吃不完直接打包了。\n\n来看看账单，感觉正常价格，至少比昨晚的海鲜便宜多了，没记错的话昨晚应该得一共 200 多（人均 50 多，在纽约呆久了都无感了甚至觉得有点便宜）。\n\n吃饱喝足后，下午又进到山里到处没信号的地方了，对现代人来说没网络简直太折磨了。\n\n路过昨天来的 Cades Cove。\n\n拍的不是很清楚，翻译大概是“大烟山国家公园”，其实跟刚刚那个地方很近，都在一个大区域。只能说美国的国家公园实在是太多了，之前去佛州也是，到哪都有很多。\n\n听说有家冰淇淋挺好吃的也本来打算去尝尝的，但是我们来的时候给这事彻底忘了，因为在之前吃早午餐的 Gatlinburg 城里，于是又得折返。开回去也就算了，奈何他们两个白毛都犯困，只能我上了，好久没开车还是有点不习惯，毕竟上次还是在佛州。然而好不容易开到城里面，停车也太难了，要不就是那种收费死贵的（20 一小时）要不就是那种专用停车（比如住宿什么的），最后找了半天直接破罐子破摔进了那种住宿的专用停车位，实在不行就说找错旅馆了，不过好在没人过问。\n这个冰淇淋其实吃到口中感觉也就那样，谈不上特别好吃也不能说难吃，跟小时候吃的那种三色的有点相似，不过是只选了一种味道罢了。\n\n然后又深入无信号地区，在一个叫 Sugarlands 的游客中心终于看到了熊，不过是标本。\n\n之后我们来到了 Alum Cave Nature Trail，这个 trail 看起来不远，真正走起来可累死人，因为大多都是些崎岖不平的山路，结果走到一半本来大好的天气，破天荒地下起冰雹来了，再加上天色已晚，最后我们只走到第一个点位 Arch Rock（拱石？我也不确定是不是这么翻译，反正字面是这个意思）就返程了。\n\n来看看 Arch Rock，感觉好像也就这样，据说是天然形成的，不知是真是假。\n\n回到车上后又开始下冰雹了。\n\n不过万万没有想到昨天没见着黑熊，今天竟然偶遇麋鹿了，。\n\n由于明天需要去一个南卡的教堂（Pretty Place）看日出，今晚必须得赶路三个小时到那边提前住下，于是果不其然晚饭又是路上看到的汉堡王快餐边走边吃了。\n赶夜路中。\n\n终于到旅馆了，没想到这没信号的荒郊野外还能又这么高大上的地方。\n\n躺到床上已经 1 点多了，明天早上 5 点多又得起来，很好，又只能睡 4 个小时了。\n 20250317\n早上起了个大早属于是，因为需要在日出（7 点半）之前赶到那个教堂，还有接近 1 小时的车程。\n到外面了，这风也太大了。\n\n准备进去了。\n\n等日出中。\n\n竟然还有求婚的。\n\n最后还有个临走前回去拍的。\n\n结果回去的路上那个山路再加上早上没怎么吃东西，给我直接甩吐了都，不过吐出来就舒服多了 hhh。也庆幸没吃早饭，不然也真就白吃了。最后还能在 9 点前赶上酒店的早餐。\n\n之后就是一路往亚特兰大方向回赶了，本来计划今晚吃火锅，不过网上搜了不少也没能找到满意的店，而且肯定也不便宜。纠结半天还是决定自己做，刚好今晚的木屋也类似于民宿那种可以自己做饭，至于食材就得去顺路的中超了解决了，结果还是买了一大车，感觉肯定吃不完。\n到小木屋了，没想到都已经七点多了，不过天还很亮。\n\n这边的垃圾桶都这么大的么，真是量大管饱啊，完全不用担心放不下。\n\n收拾准备了半天，早就看饿了都。\n\n哦对了，这个锅和电热炉是临时在 Target 买的，打算明天早上拿去退货，就可以直接白嫖一晚上了（理论上可以一两个月，但是没必要），虽然说这种行为好像有点缺德。重点是咱们没办法带回去，包里是真的塞不下去了。之后大家一起边吃火锅边看了唐探 1900（只能说现在电视的唯一作用就是用来投屏了），看完还打了一局掼蛋（没想到四川妹子还会这个，听她说是在逆水寒里面学的）。\n 20250318\n早上给那位中午返程的小伙伴送去机场后，我们就去 Target 退货了，顺便买了几个打包盒（昨天的火锅没吃完，今天的伙食有着落了）。\n最后一天的计划就比较休闲了，只打算去 Stone Park，听说那一座山是一整大块石头。上山之前在山脚下找了个吃饭的地方。\n\n不得不说昨天买的货是真多，还剩下五盒，中午吃完甚至还留了两盒，差点忘说了，这个叉子是从路过的 Wendy’s 白嫖的，进去直接拿的那种，感觉这一路上都在白嫖哈哈。\n\n从山底下仰视这个石头山。\n\n\n快到山顶了。\n\n终于登顶了。\n\n看看远处的城市。\n\n下山途中，看到个巨抽象的柱子，上面全是嚼过的口香糖。\n\n下山后基本上就得还车往机场赶了，不过好在还车地点就在机场附近，差不多能赶上。\n难得进到了机场里列车的第一节车厢。\n\n等飞机中。\n\n起飞了。\n\n晚上从 Newark 落地到新泽西已经 11 点多了，还是打算在他们家住一晚，明早再回去了，主要还是太累了。他们住 35 层，是真的高啊。\n\n 20250319\n回 Brooklyn 还得从 WTC 转地铁，好像走这么多次还真没拍过 WTC 呢。\n\n最后看了下自驾的路线，直接打卡了五个州简直是。\n\n","categories":["日记"],"tags":["美国","旅游"]},{"title":"关于ICC","url":"/2024/06/05/%E5%85%B3%E4%BA%8EICC/","content":" 20240605\n\n","categories":["日记"],"tags":["美国","ICC"]},{"title":"Obsidian同步到Github","url":"/2024/09/30/Obsidian%E5%90%8C%E6%AD%A5%E5%88%B0Github/","content":" 创建 Github 新仓库\n\n然后根据自己需求设置名称，如果想要公开笔记就选 public，不想公开就选 private。\n​\n 同步仓库到本地\n这里如果熟悉 git 就用 git clone，不熟悉 git 的话就用Github Desktop，也就是 Github 的桌面端。\n下载完成后选择 clone a repository。\n\n同步完成后选择刚刚创建的仓库，然后 Local Path 是我们要 clone 的地方，随便选个空的文件夹就好，因为后面要把.git 目录移动到 Obsidian 的仓库里面。\n\n 合并 Obsidian 仓库和 Git 仓库\n在 clone 后的 Obsidian-Library 的文件夹中可以看到隐藏的.git 文件夹，如果看不到可能是因为没有勾选显示隐藏的项目，选择勾选就好。\n\n然后将.git 文件夹移动到 Obsidian 笔记所在的仓库，使得其和.obsidian 文件夹在一起\n\n按照我自己的尝试，其实会发现之后装 Obsidian Git 的插件仍然无法链接到仓库,会显示 Git is not ready，最后才发现可能是没有安装 git 的原因，所以还是建议安装一下Git。\n具体的安装过程可以参考这篇文章：Git 详细安装教程（详解 Git 安装过程的每一个步骤）\n 安装 Obsidian Git 插件进行后续的同步\n打开 Obsidian，在的这个准备好的库中，安装一个名为Obsidian Git的插件，具体操作如下。\n首先在左下角设置中的第三方插件中关闭安全模式\n\n然后浏览社区插件市场并搜索 Obsidian Git 选择安装\n\n\n注意要打开插件的开关\n\n然后在左下角插件的配置中可以设置 backup interval（备份时间间隔）\n\n安装完成后应该会自动出现一个 Git Control View 的侧边栏。如果没有，则按下 Ctrl + P 打开命令面板，搜索  Obsidian Git: Open Source Control View ，就可以打开这个面板。\n\n有了这个插件，以后的同步操作你都可以在 Obsidian 内部进行了。\n这个插件顶部的按钮对应了 Git 中最常见的几个操作。如果你对 Git 有一定的了解，应该对这些操作不会陌生。\n\nBackup：备份，提交所有的更改，并且执行推送。\nCommit：确认提交，但不推送。\nStage all：存储当前的变更。\nUnstage all：取消存储变更。\nPush：推送到远端，可以理解为推送到 Github。\nPull：从远端拉取到本地，可以理解为从 Github 拉取最新数据到本地。\nChange Layout：改变下方文件的排布方式。\nRefresh：刷新当前的文件变更情况。\n\n如果你不想了解他们具体是干什么的，只想知道怎么做同步，那其实就两个按键有用。\n\nBackup，第一个按钮，一次性完成提交并推送到 Github。\nPull，第六个按钮，从 Github 同步到本地。\n\n到这一步就完成了所有的配置工作，第一次使用时，点击 Backup 就可以。\n 一键同步 Obsidian 和个人博客\n 一键复制 md 文件从 obdidian 文件夹到博客文件夹\n\n创建一个.bat 批处理文件\n\nstart cmd /k \"d: &amp;&amp; cd notes/study &amp;&amp; python copy_md_obsidian2blog.py\"\n\n在 obsidian 文件夹创建 python 文件\n\nimport osimport shutil# 源文件夹路径source_dir = r'D:\\notes\\study'# 目标文件夹路径target_dir = r'D:\\Hexo\\source\\_posts'# 遍历源文件夹for root, dirs, files in os.walk(source_dir):    for file in files:        # 检查文件扩展名是否为.md        if file.endswith('.md'):            # 构建源文件的完整路径            source_file = os.path.join(root, file)            # 构建目标文件的完整路径            target_file = os.path.join(target_dir, file)            # 复制文件            shutil.copy2(source_file, target_file)            print(f'文件 &#123;file&#125; 已被复制到 &#123;target_dir&#125;')\n 一键 post 文章并备份\n\n创建一个.bat 批处理文件\n\nstart cmd /k \"d: &amp;&amp; cd Hexo &amp;&amp; hexo cl &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add  --all &amp;&amp; git commit -m \"update posts\" &amp;&amp; git push\"\n 一键上传图片到 npm 图床\n\n创建一个.bat 批处理文件\n\nstart cmd /c \"d: &amp;&amp; cd data/npm/xiansakana-blog-img &amp;&amp; npm version patch &amp;&amp; npm publish\"\n 一键修改图床链接\n因为我给上传到 backblaze 的图片加了防盗链，所以在 obsidian 的本地笔记里面无法显示。因此需要将图片上传到 npm 或者其他的图床，然后在 obsidian 笔记中修改之前上传的图片链接，这里以 backblaze 到 jsdelivr 为例。\n\n创建一个.bat 批处理文件\n\nstart cmd /k \"d: &amp;&amp; cd notes/study &amp;&amp; python replace_md_url_backblaze2jsdelivr.py\"\n\n在 obsidian 文件夹创建 python 文件\n\nimport reimport osdef replace_image_links_in_directory(directory, old_link_prefix, new_link_prefix):    # 遍历目录下的所有文件和子文件夹    for root, dirs, files in os.walk(directory):        for filename in files:            filepath = os.path.join(root, filename)            # 仅处理Markdown文件            if filepath.endswith('.md'):                with open(filepath, 'r', encoding='utf-8') as file:                    content = file.read()                # 使用正则表达式替换图片链接                new_content = re.sub(old_link_prefix, new_link_prefix, content)                # 将替换后的内容写回文件                with open(filepath, 'w', encoding='utf-8') as file:                    file.write(new_content)# 指定目录和需要替换的链接前缀directory_path = 'd:/notes/study/'old_link_prefix = 'cdn.jsdelivr.net/npm/xiansakana-blog-img'new_link_prefix = 'cdn.jsdelivr.net/npm/xiansakana-blog-img'# 执行替换操作replace_image_links_in_directory(directory_path, old_link_prefix, new_link_prefix)\n","categories":["笔记"],"tags":["Obsidian"]},{"title":"关于unpaid实习过程的吐槽","url":"/2024/05/02/%E5%85%B3%E4%BA%8Eunpaid%E5%AE%9E%E4%B9%A0%E8%BF%87%E7%A8%8B%E7%9A%84%E5%90%90%E6%A7%BD/","content":" 20240502\n想来想起还是写写日记来记录一下吧，尽管都说正经人谁写日记啊，但是感觉不记录感觉时间久了就啥都不记得了，感觉就算是一年前的事情，就算是靠着图片相册甚至是时评也只能记起个大概。也许只有文字能够让人安心吧哈哈。\n今天呢，主要还是为了吐槽这个实习才打算开始写的，还是从头开始说吧，真的是说来话长了。\n首先，介绍下背景吧。美帝这边计算机最近两年就业有多难，就我个人感觉加上道听途说，大概比国内难至少三到四倍，不过国内难度我也不是很清楚就是了，毕竟没怎么投过简历。不过还是可以列几点问题所在：\n\n实习机会受制于 cpt 身份。美帝的实习是需要有工作许可的，比如 cpt 或者 opt，而工作的话需要 h1b 或者 opt，而如果你作为 f1 学生身份，一般实习就只能是通过 cpt 来获取机会，然而大部分学校要求是至少一年全日制学习后才能申请 cpt，这也就意味着你只能选择第二年的暑期实习（秋季入学），而春季入学的话可能同年的暑期实习还无法参加，也许只能参加第二年的暑期实习或者是日常实习。只有暑期实习才能够 full time，而日常实习由于大多数学校的 cpt 的要求基本上都是 part time，而且市场上的数量相对于暑期实习来说要少很多，会有很大的劣势。全日制满一年后的 cpt 政策对于不同学校可能有所不同，听说即便是有这些硬性要求，但也存在一些捷径，这里就不细说了。\n全职身份受制于 opt 和 h1b。对于一个无美国身份的在校学生来说，找工作压力会大很多，一是因为 opt 的期限在毕业后只有 60 天，如果在此期间无法拿到工作的 offer 就必须卷铺回家，否则就是非法滞留了，同理对于全职的 h1b 工作签证也是如此，如果不幸被裁的话，只有 60 天的缓冲期，所以说只要是没有绿卡都是一律人人平等！\n还有一点就是漂亮国的 zz 正确了，对于男性（非女性，非 lgbtq+）或者非少数族裔来说，可以说是 debuff 拉满了。不过也是据说而已，不保真，具体情况如何就不清楚了，说到底还是看运气。\n最近两年大环境不太行。自从 2020 年和 2021 年疫情后，美股疯涨，各个大厂都疯狂招人，那个时候什么牛魔鬼怪都能进去，据说当年是写个 two sum 都能去亚麻。然而从 2022 年年底加息开始，黑暗降临。大厂开始降本增效疯狂裁员，估计到今年 2024 累计已经裁了百分之好几十了，2023 年暑期实习对于大多数人来说大概率是找不到的，毕竟市场上人实在是太多了，一个词形容的话就是“僧多粥少”。如果没有全职工作经验，最近几年会非常的难找，毕竟市场已经崩了，hc 相对于 applicant 来说少的可怕。不仅有一堆各种 top 校 cs 科班专业+一堆实习经验的跟你卷，甚至还可能会有工作经验 n 年的印度三哥来跟你抢实习的机会。光从投简历上来说，一个岗位放出来不到一小时，已经是 100+的申请了，过一天之后大概率是 1000+的申请，你觉得 hr 能看到你的简历吗？就算看到了估计也会被淹没得连头都看不到。既然人多，肯定得有筛选的手段，首先，把需要 sponsor 的无身份的人砍了。听说有很多申请的后台都是直接过滤掉无身份需要 sponsor 的简历的，因为在填申请的时候大部分都需要去填写各种信息，其中就包括了你的 sponsor 需求。毕竟，对于大厂来说，sponsor 一个员工在财力上到没什么，对于小厂或者中厂来说就很重要了，一来他们并没有很多的预算来 sponsor 一个无身份的人，二来 sponsor 的流程也会复杂很多，如何选择其实已经很简单了吧。其次，肯定是优先选择有全职或者实习经验的候选人，这对于找实习也是如此，毕竟现在这个市场，能用一个 junior 的岗位和价钱招来一个 senior，哪个老板不愿意呢。于是这就导致了，找工作需要全职经验，找实习需要实习经验的死循环。最后一点，OA（Online Assessment）和面试难度飙增。要知道，几年前还没这么夸张，现在的情况真的是 OA 各个都是 hard 题目，没个 300 题朝上的刷题量别说是写完，有没有思路能否写出来都是个问题，就算是写出来了，现在都是要求 bug free，一点错误都能成为挂你的理由，毕竟其他 candidate 真的太优秀辣。不过除此之外，最重要的一点是，能不能收到 OA 或者面试的机会也是个问题，简历投出去连水花都没得。\n美国的应届可以说是 debuff，毕竟可能看成是没有校招。如果说国内的话，分为校招和社招，而校招的难度相当于社招是要低很多的，而且会有名校加成，比如 985 或者 211 之类。而漂亮国这边除了 intern 实习之外就是 junior 然后再往上就是 senior，并没有专门针对应届生的通道，所以说作为应届你得跟社会人来竞争，其中还包括一堆有工作经验被裁的和有美国身份的。而且学校加成并不是很重要，就我看来，重要性大概可以看成是工作经验&gt;实习&gt;项目经验&gt;学校title&gt;其他。其实本来每个阶层的竞争者都是稳定的，每种岗位都有相对的不同的人来竞争，然而由于僧多粥少，最后只能迫不得已市场下沉，senior 去找 junior 岗位，junior 去抢实习。\n\n先暂时列这么多，如果以后想到了再加就是了，还是不要忘了今天的正题。说到我这个实习，还是得说一下来源。\n我当时应该是投的比较晚了，而且理论上来说第二年的暑期实习应该是在第一年的暑期就得开始投了，对于这边是这样的，不过国内好像会晚一点，一般要到前几个月才开启。我硬是磨蹭到了 1 月底才开始投，其实这个时候应该也没多少岗位了，就算有估计也没多少机会，毕竟先到先得，投的早肯定机会多点。其实我这么晚再投还是打算先丰富下简历，毕竟来这边的时候真的是啥都没有，什么经验都没，甚至感觉我都像是所谓的零基础转码那种了，尽管说本科好歹还是 EE 专业吧。但是确实是没有实习经验，只能说是自己硬凑了几个项目上去，而且计算机相关都是 9 月份开学过来才开始自学的，还是本科摆烂了，要是早点行动多好，不过最多也只能说是总比啥都没干要好。\n当时从一月底开始陆陆续续投了快一个月，什么大厂中厂小厂 startup 都投，只要是 SDE 相关的看到岗位就投。管他是什么前端后端，还是全栈，还是 General SDE。大厂一般都不会分的很细，基本上都是 General SDE，然后进去再说，而中小厂可能就会分的细一点，会有相对应的不同的岗位。现在看起来确实当时还是不充分，之后再过几个月投全职的时候，到时候应该还是得准备多份简历，去针对性的投，而不是说一股脑全投一个。\n当时一个月投了大概有快 200 份，每天起来就是看推送的岗位，然后看是否有合适的。这个投递说麻烦也不麻烦，说简单其实也不简单。不过最烦的一点是，对于大多数来说，都需要跳转到官网去投递，而不是说在某个简历投递平台比如 LinkedIn 或者 Indeed 还有 ZipRecuiter 和 Handshake，就可以所谓的一键投递。官网投递就麻烦在，需要填写一大堆个人信息，什么姓名、地址、邮箱、电话，还有一堆奇奇怪怪的比如 Self-Identification 和 Disability 等等，所有的填完之后平均估计得要花上 2-5 分钟，十几份投下去个把小时就没了。投着投着甚至就会有那种“反正也没面试，投了也是白投，浪费时间，有这时间不如干点别的”的想法；不过确实是如此，总结到后面就是看运气，毕竟简历池子实在是太大了，能给你捞起来就是运气好。\n下面是我当时投递的状态记录，可以说是全军覆没了，不过给我发面试的那家也是最早投的那批了，所以说真的是看运气。\n突然想起来前几天 Tandon 群里看到的聊天，分享一下，只能说是 cs 付费上班，指日可待，真不愧是遥遥领先。\n\n回到正题，给我发面试邀请的那家是个 unpaid startup，startup 到什么程度呢，面试我的时候只有两个人，一个 CEO 一个 CTO，CTO 貌似懂点软件开发方面的东西，不过之后我才发现，并不靠谱，总之后面慢慢说了。\n当时面试了大概半个小时，不过距今已经过去了大概两三个月了，记得不是很清楚，也就只能大概说说了。没记错的话一开始应该是自我介绍，还好我早有准备，掏出了提前准备的 behavior question 记录，里面就有一系列常见的问题和我自己的回答。由于是线上的面试，我直接照读其实也没啥问题，毕竟对面也看不出来。然后几个问题都是 CEO 问的，包括什么 why choose us 和 career path 之类的常见 bq 问题，其他好像记不太清了。\n之后的话好像是 CTO 开始问问题，首先说的是看我简历上有个 react 项目，然后让我介绍一下，不过我当时可能是有点紧张，支支吾吾讲不出来，后来我也不记得是咋回事了，对面就像是放弃了一样，然后开始问我关于前端的两个 technical problem（因为我当时申请的是 frontend developer intern）。第一个问题是 How do you ensure cross-browser compatibility when developing a website, and why is it important? 第二个是 How do you approach implementing user-friendly interfaces in collaboration with a design team? 真不愧是第一次面试，我当时听到问题一脸懵逼，争取时间还是装作没听清，让对面重复了好几遍，结果让我惊讶的是，他怕我听不清竟然直接在聊天框把问题给打了出来，当时都给我看呆了，还能这样的么。于是我就将计就计，直接问 chatgpt 了，果然 chatgpt 不负我，我装作一边想，然后边读边总结要点，看似支支吾吾的答完了大概。毕竟这种问题也没有确定的答案，毕竟挺主观的，人人想法不同。\n最后一个环节是经典的反问环节，一般是让你问他们问题。于是我从先前准备的列表中挑了几个：What do you like most about working here? How would you describe the company culture? What are the next steps in the process? 不过我还问了 Do you accept CPT? 不过她好像看起来不知道 cpt 是啥的样子，于是我也没多问了，看起来这个 unpaid intern 估计也用不到 cpt。最后当然是经典的等通知了，然后不到一周给我发了 offer，估计是真缺人，然后我在刚好的时间出现在了合适的地方，大概找工作就是这样的吧，现在看来和所谓的相亲越来越像了，都是一个相互选择看运气看缘分的过程。\n当时这个 startup 对外招人的文件中是有五个 intern 岗位的，分别是 Front-End Developer Intern, Backend Developer Intern, Business Developer Intern, Agriculture Program Coordinator Intern（因为这家公司是农业和 Gardening 相关）, Digital Marketing Intern。结果进去日常会议一看除了 CTO 和 CEO，剩下就是我作为 frontend 和另一个 business intern 了，连个后端都没，给我人整傻了当时。后来想想，尽管说是 unpaid，总比啥都没有要好，只能安慰自己说赚经验了。\n对于日常会议，差不多就是汇报下前一天的工作，然后今天的计划以及遇到的困难或者有什么问题之类的，一般在 10-15 分钟之内，然后剩下的半小时到一小时时间，会分给专门的 software develop meeting 或者 business develop meeting，比如 software 是周一、周三和周四，而 business 是周二。也就是说，每周周一到周四需要抽一段时间出来开会。在 5 月之前，还是 EST 下午 3 点半，从这个月由于 CEO 时间变动，然后征求所有人的意见之后就开始改成 EST 下午 6 点半开始了。\n整个团队进度管理是由 Trello 来完成的，交流基本上是通过 slack，然后开会是 google meet，代码管理仓库是 bitbucket（关于这个我也有个不得不吐槽的点，后面再慢慢谈），还有一个 notion page 展示公司的介绍，最后有个 google drive 里面有相关的资料。\n我来的第一个月，也就是 3 月份，基本上是从零开始，这公司真的啥都没有，别说学到什么了，只能说是丰富简历吧 hhh。我记得当时，说要用 bitbucket 作为代码管理平台，尽管说我加入了 workspace，但是甚至好几天不给编辑的权限，以至于我不能创建仓库，更别说新建工程上传代码了，这个效率是真的难以言喻。他们的计划是先搭建公司的主页，也就是 landing page。我问他们有没有什么页面的参考模板，然后回答说是用 figma 去设计修改然后再用 react 代码实现，让我学 figma，然后转手给了我一个模板，结果我反应了好几天说没有编辑权限，结果还是屁用没有。不过这都不是问题，我直接复制一份到自己账号下改就完事了。最令人无语的是，开会的时候还问我为啥没看到 figma 上面的修改，我当时只想骂 tm 的，不过还是忍住了，也只能心里骂骂，或者闭麦骂。之后就是直接 react 框架前端实现了，其实这都不是难事，毕竟就一个静态网页没什么难度，再加上有 gpt 的加成，几天就把页面的大概架构弄完了。最令人无语的事，还得是后面的缝缝补补。我写完页面花了三天，结果陆陆续续改了快两周。你猜为什么会这么久，要说原因可太多了。首先，我不知道拿什么内容去填充这个网页，毕竟我又不是老板，而且除了那个公司的 notion page 外又没有什么可以参考的信息了，虽然说还有一个该公司的旧网站，也是部署在 netlify 上面的，不知道是谁做的，我甚至感觉那个比现在这个网页好多了，还非得重做一个，不过这个问题我也一直没问，我个人猜测可能是因为那个网站他们没源代码。我实在没内容可以加了，又提了这个问题，结果到后来，竟然是让我把那个旧网站的文本介绍内容直接搬到现在的新网站上，我 tm 真是服了，一开始就说不行么，结果到后面我还加了几个相对应的模块。然后对于页面各种细节需要修改，今天改一点 navbar 明天改一点 footer，我真的服了，难道不能一次性把要求都提清楚么。还有就是根本得不到及时的反馈，我也不知道哪些地方需要修改，然后那个 CTO 也基本上几天才看一次，搞得我每天的会议都要绞尽脑汁想这该说些啥，毕竟是真的没干啥。结果就是，我个人感觉，这一个月的事情，一周就能做完，硬是拖了一个月，后来想想也好，直接开混，反正又不给钱。\n然后到了第二个月 4 月，首页基本上宣告结束，开始步入计划中的 user dashboard，同时也来了一个新的 backend intern，本来以为来了个新人我能少干点，结果后来发现我错了，错的很彻底，同时也意识到了什么叫做人外有人，不过反过来想，好歹人家没有帮倒忙。\n对于这个 user dashboard，CTO 打算用 flutterflow，然后让我们先学习几天这个平台先。我一看，这玩意不是低代码平台么，直接人傻了，要知道低代码平台没几个靠谱的，毕竟前期搭起来简单，后面维护起来才叫难，比如你想加个需求，其实用低代码平台实现起来可能比真正的代码还要麻烦很多。而且，这个平台学习起来也需要成本，同等时间用代码实现效率会高很多，而且代码的可扩展性很高，比这个什么低代码平台靠谱多了。那个 CTO 就一直说什么低代码平台简单啊，直接拖拖拽拽就能把页面搭好啊，而且有什么模板之类的啊，我真的是无语子，你有本事你自己搭啊。\n这个 CTO 有多不靠谱呢，听我慢慢道来。之前在做首页的时候，当时应该是已经快收尾了，然后他自己分享手机屏幕预览页面的时候直接 css 样式根本没加载出来，而且图片也没显示，我让他清理一下缓存，我说可能是你的浏览器缓存满了，我这边是没问题的。然后我无意一扫他那浏览器开着 80 多个标签页，我直接不知道该说啥了。还有就是每次所谓的日常回忆之后的 software develop meeting，都问我能不能分享屏幕，然后看着我屏幕指挥我怎么怎么操作。这都不是重点，重点在于，他就是那种不懂又非要瞎指挥那种，我都看的出来他还没我懂得多，有时候可能一个问题，这边试试那边试试，这个让我点一下，那个让我点一下，结果还解决不了问题，说实话，我自己弄可能早就解决完了。有一次我不耐烦了，直接给他说我在外面用的是手机，然后他只好问另一个 backend 有没有在 pc 前，能不能共享屏幕，那人当然是否定。还有个事情，我上周就在给他提没有 product 和 learning（因为目前要做的 mvp 版本是三个模块 marketplace, learning codex 和 ai assistant）的数据，结果到现在还没给我，聊天频道和嘴上说第二天或者很快就有，而且还把 google drive 的链接分享到 slack 上了，结果我点进去一看，屁都没有，只能说做人还是不要太认真，认真你就输了。说到这三个模块，不得不再吐槽一下，我当时开始之前就提议说分好工，一个人做一个模块，这样好分配工作，不然很模糊，结果他非说要 step by step，一个一个来，结果就是一个都没完成，毕竟我不做根本没人做呢 hhh。突然想起来了，当时讨论说着我先做着那个 learning page 把数据传上去，然后他来弄那个 ai assistant，因为那个 api 始终有问题，结果上周末群里发了一句 ai now active，我点开页面一看哪里 active，完全没成功好吧，是真的不靠谱。\n\n然后就不得不该提到那个 backend intern 了。怎么说呢，我已经不知道该怎么用语言评价了。总能给自己找到理由，我在这点上不得不佩服她的，慢慢来说吧。讲的头头是道，结果啥都没干，我看工程的修订记录，都找不到她的名字。\n\n最离谱的是什么呢，每次那个 CTO 在群里都是@我们两个，然后她屁事都不干，全都是我干，每次分享屏幕也都是第一找我。还有一点存疑的是，那人总说自己网络有问题，是真是假只有她自己知道了，反正我知道的是，上周有两天直接不来参加日常会议了，一下又是没网，一下又是什么重要会议，我真的挺佩服的，真的有这么多意外么。\n\n\n\n\n怎么说呢，我怎么越看越感觉这就跟会哭的孩子有奶喝一个道理呢\n\n看到下面这段话我甚至想打人，你 completed the task? 给我看乐了属于是，你去翻翻编辑记录，看看哪个工作是你做的？\n\n真的是一天一个新理由，我已经开始好奇下周是什么理由了。\n\n至于今天写这个日记的缘由，还是在于今天的 meeting。本来按往常一样，日常会议随便混一混然后就开始 software meeting 了，结果今天这个我是真绷不住了。\n那个 CTO 一开始上来就让我分享屏幕，其实昨天就这样了，但是我说实话不是很想，所以昨天就没这么干，直接给他说我在外面用的是手机，那他自然是没办法啊，马上就去问那个 backend，那人自然是不在电脑旁边。然后他不得不分享自己的屏幕，令我惊讶的是这次竟然是电脑，毕竟我就没看过他用电脑，每次都是手机，结果折腾半天连网站都打不开，可能是因为网速太差了吧，我都好奇他是怎么进会议的，这网速。然后转了半天打开了部署的网站，结果又是加载不出来。我让他清理下缓存试试，结果找了半天没找到怎么清理，后来还不得不用了浏览器的隐私模式打开。\n还是回到今天的情况吧。我想着算了吧今天就分享屏幕吧，毕竟昨天没分享屏幕，看他又那么狼狈。结果上来就是让加一个 header，其实我明明已经在今天的日常会议中讲过昨天干过这事了，很明显根本没听，所以说，这种例行汇报是没有任何意义的，不过这我早就发现了，大概一个月前就意识到了。然后把 learning page 的 header 拷贝到 marketplace 做了些修改，然后就开始打算让我上传 marketplace 的 product data。我进 google drive 一看，这都是什么呀，和 learning data 一样只有五条数据，而且只有名称和描述以及价格，顺带一个 link 指向亚马逊的商品页，我到现在都没搞懂他们打算怎么用这个 marketplace。他看着 flutterflow 上的数据结构（其实是那个模板自带的），感觉数据中少个分类，然后跟 CEO 讨论起来 category 是啥，我趁他们讨论的间隙，打算赶紧把数据对好然后传上去，结果正打算传的时候，才发现这 tm 给的数据是文档形式，而我批量上传所需要的应该是 csv 表格的形式。我还不得不把他给的数据重新新建个表格改写下，然后图片去给的亚马逊的链接的页面中去获取。其实这些都是小事，至少有数据，比啥都没有要好很多了。突然这个时候，会议中断了，原来是一小时的免费通话时间到了，果然过了一会，那个 CTO 发了另一个会议链接到 slack 当中。这已经不是第一次了，毕竟在我的印象中，好多次都是这么干，照理来说不应该拖这么久的。不久之后，他就@我和 backend 的进会议，我就蹲在这会议门口，等那 backend 进，结果就是我不进她也不进，我心想，为了摸鱼也不至于做到这种程度吧，你进去不也是挂着啥都不干么。后来我实在没办法只好进去，然后看我进去之后那人直接秒进，我真的是无语。\n当时算上之前正常会议的一小时，所以已经是 7 点 40 多了。在弄完了 learning 和 product 页面以后，开始修改剩下的 ai assistant 的页面。计划使用 chatgpt 的 api，其实之前已经弄过一遍了结果当然是失败，而且当时用的还是我的 key，反正当时给我整乐了，这个网站到现在，所有的配置全用的我自己的账号，见怪不怪了属于是。然后那个 CTO 又给我瞎指挥半天，一下让我改这里一下改哪里，有个报错还时不时找个什么不靠谱的回答链接发 slack 上，然后一步步指挥我跟着那个做。我真的人麻了，你有这空或者我有这空自己做早就弄完了，也不至于一个 api 调用的问题搞半天发现不了原因还到处瞎找，瞎找就算了，还非得一步步指挥我点哪个，真的是浪费生命说实话。调试半天，他也找不到是哪里出问题导致 api 调用失败。本来以为几个地方写的 api 不一致，检查一遍改成一样的，失败；然后报错说的是不能传 json 格式，他找了个什么奇怪的帖子，打算让我改请求体的格式，让我 copy 那个然后粘贴到这边来。我要再不阻拦的话，估计后面还会花更多的时间，因为那个请求体的变量是通过参数传递的，而不是直接写在里面，而是需要 test 的时候传进去；最后还是报错说什么 api 额度不够，依然失败。这还不是最离谱的，最离谱的是，这个 api call 可以 deploy 到 firebase，然后上面显示 not deployed 他就以为是因为这个没有 deploy，然后一看原因是没有开启 firebase 的 blaze plan，结果就让我顺着这个 firebase 然后去到了控制台，然后让我去开通这个 blaze plan，我直接傻了，你们公司让员工提供付费功能的订阅？他还挺人性化，说如果你不想让我们看到敏感信息可以先停止分享屏幕。我果断停止分享，不过看到这个什么 blaze plan 有个试用，就选了那个，不过还是得绑卡。之后我也开摆了，懒得思考，他就这么瞎指挥半天，也没有什么进展，报错就是报错，测试就是不通过。突然间，他仿佛看到了一丝希望，在设置的最下面看到了 Gemini 的选项。这是 google 的 ai，和 chatgpt 一样，也可以通过 api 来发送请求，点开选项之后，需要输入 gemini 的 apikey。他就跟看到救命稻草一样，竟然开始让我去 gemini 创建 apikey 了。很快啊，然后还发了个 gemini 的视频链接到 slack 当中，我真的是服了。这难道就是传说中的，”解决不了问题，就解决问题本身“是吧。很快，他让我新建一个页面，打算按照视频用 gemini 的 ai，我实在是没耐心了，当时已经 10 点多了，也就是说一晚上时间没了，我直接装作没听到他说话，然后过了一会直接退出了通话。\n\n至于然后过了大概 10 多分钟，我直接断网大法，无法无边。\n之后，我先用 postman 测试了下这个 api 是不是真的有用排除了 flutterflow 本身的问题，然后依然是这个额度不够的问题，我就猜测应该是 openapi 平台没有充值的问题，去那里看了下，果然是有限制，所以充了 10 块钱绑了卡，然后再用 postman 测试了下，就可以用了。所以跟其他什么乱七八糟的一点关系都没，单纯就是没充钱用不了 api。然后我尝试着将 firebase 的 blaze plan 解除，然后取消 private call，因为这个需要通过 cloud function 才可以实现，也正是为什么之前需要 deploy api 到 firebase。果然事实证明这个跟 firebase 一点关系都没，纯粹就是那人不懂非要瞎指挥。两小时没解决，我 tm10 分钟就弄好了。\n这不靠谱的地方还有哪些呢？首先，他们那个官网首页是部署在我自己的账号上的，尽管说代码储存在他们的代码库，但是部署是另一套逻辑，跟那个库没关系，我用的还是自己的账号部署的，因为我之前问过他们有没有 netlify 的团队账号，因为这个网站部署需要，然后我收到的回答是先用自己的账号部署，我想着行吧，反正对我来说也无所谓。其次，这个 flutterflow 的工程当时是我分享屏幕的时候让我建立的，然后拉了他们两个作为协作者，也就是说我有这个工程的绝对控制权，而且里面链接的 firebase 也是用的我的账号，包括 openai 的 api，我只能说我一跑路他们直接白给。\n算了，暂时先写这么多吧，还是先睡觉去了，这外面都天亮了。。。\n 20240503\n好家伙，还有脸过来私聊我，我还特地去工程上看了一眼，结果当然是意料之中\n\n\n 20240513\n前几天忘记记录了，今天补充下哈哈，当乐子看就行\n5 月 8 号的群聊\n\n5 月 9 号\n\n今天的\n\n有一说一这人已经两周没来开会了。\n 20240528\n好久没记录点东西了，不过中午一起来就看到 slack 上面的信息，那人上周四 23 号的最后一次结束会议没来，今天又给我看乐了哈哈，不过我算是见到了，真的哪里都有大混子的存在。\n\n 20240629\n今天心血来潮去 linkedin 上搜了下之前实习的 startup，然后看到了上次那个摆子的 post，点进个人主页一看，好家伙本来啥都没干结果写的倒是天花乱坠。我算是意识到了，这年头最重要的就是比谁会吹牛逼，不管是找工作还是啥都一样，技术什么的永远不是最重要的。你创业也得能吹，不然谁给你投资是吧。\n\n不得不说人家是真能吹，看下面的图就知道了，不过这也是该学习的点就是了。说起来再过一两个月得开始投简历了，前几天想了半天，还是得赌这边，投个至少一两千份再说吧。。。毕竟国内的现状实在是太糟糕了，不过这边也好不到哪去就是了。\n\n","categories":["日记"],"tags":["美国","实习","吐槽"]},{"title":"关于美国身份问题的常识","url":"/2024/09/30/%E5%85%B3%E4%BA%8E%E7%BE%8E%E5%9B%BD%E8%BA%AB%E4%BB%BD%E9%97%AE%E9%A2%98%E7%9A%84%E5%B8%B8%E8%AF%86/","content":" 概述\n美国身份问题通常涉及到以下几个主要方面：\n 公民身份\n\n出生地原则：在美国出生的人自动获得美国公民身份，这是根据美国宪法第十四修正案规定的。\n血统原则：美国公民的子女，即使在国外出生，通常也可以通过父母获得美国公民身份，但需满足特定条件和程序。\n归化：非美国公民经过一定居住年限后，可以申请成为美国公民。这个过程称为归化，需要通过公民考试和宣誓仪式。\n\n 绿卡（永久居民身份）\n\n绿卡持有者：被允许在美国永久居住和工作的非公民。绿卡可以通过多种途径获得，包括家庭关系、雇佣、难民或庇护状态等。\n条件限制：某些绿卡是基于特定条件的，比如婚姻，可能需要在两年后进行条件移除。\n\n 非移民身份\n\n临时访问者：如旅游者、学生、临时工作者等，持有非移民签证，允许在美国停留有限的时间。\n签证种类繁多：美国有多种类型的非移民签证，根据访问目的的不同而不同，包括商务、旅游、学习、工作等。\n\n 无证移民\n\n非法身份：未经许可进入美国或超过签证允许的时间停留的人。他们在美国没有合法居留权，面临被遣返回国的风险。\n\n 庇护和难民地位\n\n庇护：在美国或边境请求保护的人，他们因为种族、宗教、国籍、社会群体成员身份或政治观点而在原籍国面临迫害风险。\n难民：在美国之外请求保护的人，符合相似的迫害标准。\n\n 一些名词\n 签证 VISA\n由美国国务院下属的驻外领事馆签发给外国人进入美国的许可文件。在签证的有效期内，持有者可多次往返美国。它可以被视为是能够进入美国的一张门票。\n 身份 STATUS\n由移民局主管。在持签证和护照获得美国海关进入许可之后，签证持有人就有了停留在美国的一个“身份&quot;，并被允许在一定时间段内合法停留。\n有了签证，只是说明你拥有进入美国的资格，还不一定能保证你就可以进入美国并留下来。决定你能合法在美国逗留多久、在美国从事哪些活动，只和移民局给你的“身份”有关。和你身份息息相关的另外一个重要文件就是 I-94 表。\n 签证有效期\n签证页上的到期时间，在这个时间点之前，可以自由往返。\n 有效停留期\n在美国，有效停留期就是你被允许可以停留的最长时间。I-94 的重要性等同于一张你在美国的身份证，上面清楚写明了你是以何种签证类型、入境时间，以及本次你可以在美国最长可停留的期限（需离境时间）。在美国的外国人，必须在 I-94 卡上标明的到期日或之前离开美国。如果晚于这个时间，就属于非法滞留。\n分清楚签证的有效期时间和可停留期是非常重要的事情，因为两者经常会不一致，一般而言会以 I-94 的有效期时间为准。某 B-2 签证持有者在签证即将到期前一个月入境美国，但作为身份证明的 I-94 上给予的离境时间则为进入美国后的 6 个月。这种情况下，即便持有人的 B-2 签证在进入美国后一个月后过期，此人也依然可以合法在美国停留，直到 I-94 限定的离境那一日。\nF-1 签证是一种特殊的签证，学生的 I-94 没有指定的有效期日，这是因为学生签证的持有人在美国的合法停留时间是以“是否为在校注册学生”作为准则，I-94 上通常只有 D/S 这样的标注（身份延续到学生身份结束）。只要学生的学生身份有效， I-20 也没有过期，那么学生就可以一直留在美国，签证过期并没有关系。在美国境内，F-1 签证和 F-1 身份的待遇几乎一样，都可以作为国际生在美国长期合法停留并读书。\n成功变更在美身份状态为 F-1 的留学生基本上可以享受到持有 F-1 签证的留学生一样的待遇.最大区别为是否需要面试及能否自由出入境。抛开无法出入境自由这一点，在美国境内变更身份为 F-1 其实是一个不错的选择，毕竟通过率高，特别适合想要留美的家长，或者打算先来了后面悄摸摸想要长期留下来的童鞋们。\n 境内身份变更的基本申请步骤\n准备材料，申请学校 → 缴纳 SEVIS 费 → 填写 I-539 表 → 获得 Initial I-20 → 所有材料递交移民局 → 根据通知，完成指纹录入 → 等待批准。\n在美国境内最常见的身份变更情况就是 B 类签证转为 F-1 签证，其他的非移民可变更身份的签证类型还有 E1/E2/J/O/R/H/L 等。\n 关于非移民身份\n非移民身份是指那些被允许暂时进入美国的人，但没有获得永久居住权（绿卡）的资格。非移民身份适用于各种目的，包括旅游、商务、工作、学习和临时居住。下面是一些主要的非移民身份类别及其特点：\n 旅游和商务访问者（B-1/B-2）\n\nB-1 签证：适用于商务访问者，如参加会议、商务谈判或短期培训。\nB-2 签证：适用于旅游、探亲访友或医疗治疗的访问者。\n\n 学生签证（F-1 和 M-1）\n\nF-1 签证：适用于在认证的美国学校或大学进行全日制学术或语言学习的学生。\nM-1 签证：适用于职业或非学术学习的学生。\n\n 交换访问学者（J-1）\n\nJ-1 签证：为各种交换项目参与者提供，包括学生、研究学者、访问教授、实习生等，旨在促进文化和教育交流。\n\n 工作签证\n\nH-1B 签证：适用于在特定专业领域（如 IT、工程、医学等）工作的人士，要求雇主提供担保。\nL-1 签证：为跨国公司内部调派到美国的管理人员或专业人员设置。\nO-1 签证：适用于具有杰出能力的个人，包括在科学、艺术、教育、商业或体育等领域展现出杰出成就的人士。\n\n 特定目的签证\n\nK-1 签证：适用于与美国公民订婚的外国公民，允许其入境与美国公民结婚。\nT 签证和 U 签证：分别为人口贩卖受害者和某些犯罪活动的受害者及其家属提供。\n\n 临时保护状态（TPS）\n\nTPS：为因战争、自然灾害或其他特殊情况无法安全返回本国的人提供临时保护。虽然 TPS 持有者不是非移民签证持有者，但他们被允许在美国临时居住和工作。\n\n 关于 F1 签证\nF-1 签证是美国提供给外国学生的非移民签证，允许他们进入美国从事全日制学术或语言课程的学习。F-1 签证是国际学生获取美国教育的主要途径之一，适用于大多数在美国的高等教育机构、中学及其他学术机构注册全日制学习的学生。以下是 F-1 签证的一些关键特点和要求：\n 申请资格\n\n学校认证：学生必须被一所美国政府批准的学术机构接受，并且该机构必须有权颁发 I-20 表格（证明学生资格的官方文件）。\n全日制学习：申请者必须证明其将从事全日制学术或语言课程学习。\n财务证明：必须证明有足够的经济资源来支付学习和生活费用，不会在美国期间成为公共负担。\n回国意愿：申请者必须证明他们有意愿在课程结束后返回自己的国家。\n\n 签证申请过程\n\n接受录取和获取 I-20 表：首先，学生需要获得美国学校的录取通知书，并从该学校接收到 I-20 表格。\n支付 SEVIS 费：之后，需要支付 SEVIS I-901 费用，这是学生和交换访问者信息系统的注册费。\n填写 DS-160 表格：在线填写并提交非移民签证电子申请表。\n预约面试：在最近的美国领事馆或大使馆预约签证面试。\n准备面试材料：包括有效护照、I-20 表格、面试确认页、照片、学习计划、财务证明等。\n签证面试：参加面试，回答领事官员的问题。\n\n 在美国学习期间的规定\n\n学习要求：F-1 学生必须保持全日制学习状态。\n就业限制：F-1 学生在特定条件下可以工作，包括校内就业和在学习结束后通过可选实习（OPT）或课程相关实习（CPT）计划工作。\n维持身份：学生需要遵守所有 F-1 签证规定，以维持其非移民状态。\n\n 离开和重新进入美国\n\n旅行签证：F-1 学生在学习期间离开美国时可能需要特定的旅行签证和再次进入美国的批准。\n\n 完成学业后\n\n可选实习（OPT） ：学生可以申请 OPT，在学习结束后在自己的专业领域内工作最多 12 个月，STEM（科学、技术、工程和数学）专业的学生可以延长至最多 36 个月。\n\n 关于 CPT (Curricular Practical Training)\nCPT 是一种可以为 F-1 学生提供在其专业领域内的实践工作经验的程序，这种实习必须是他们课程的一部分或者对于他们的学位是必需的。\n\n时间：CPT 可以在学生的学习期间进行，包括学期内或假期。\n资格：学生通常必须至少完成了一学年的全日制学习，才能申请 CPT。但是，研究生项目中，如果实习是课程的一部分，可能会立即开始。\n工作类型：可以是兼职或全职，具体取决于学生的学习阶段和课程要求。\n申请过程：需要通过学校的国际学生办公室（或类似机构）进行，并且通常需要一个工作要约。\n影响 OPT：如果学生进行了 12 个月或以上的全职 CPT，他们将不再有资格获得 OPT。\n\n 关于 OPT (Optional Practical Training)\nOPT 允许 F-1 学生在美国获得与他们学术专业相关的实践工作经验。OPT 可以在学生完成学业前后进行，提供了更多灵活性。\n\n时间：总共最多 12 个月，STEM（科学、技术、工程和数学）专业的学生可以申请额外 24 个月的延期，总计最多 36 个月。\n资格：学生在完成学业前或之后都可以申请 OPT，但必须在完成学位程序前后的指定时间内提交申请。\n工作类型：在 OPT 期间，学生可以进行兼职或全职工作，但工作必须与他们的专业领域相关。\n申请过程：需要向美国移民和海关执法局（USCIS）提交表格 I-765，申请就业授权，并支付相关费用。此过程通常需要几个月的时间。\n学业影响：学生可以在学习期间进行部分 OPT，但这将从他们毕业后的 OPT 时间中扣除。\n\n 关于 H1B 签证\nH-1B 签证是美国提供的一种非移民签证，专为雇佣外籍专业人士在特定领域（如信息技术、工程、医学和数学等）工作的美国公司和组织设计。H-1B 签证使得美国雇主能够暂时雇用外国工人来填补美国劳动力市场上的专业职位空缺。以下是 H-1B 签证的一些关键特点和要求：\n 专业职位\nH-1B 签证适用于所谓的“专业职位”，这些职位通常要求至少是学士学位或等同学历，在特定专业领域的工作经验。申请人必须拥有与职位相关的学位或其等同的资格。\n 数量限制（配额）\nH-1B 签证每个财政年度有数量限制，通常被称为“H-1B 配额”。截至 2023 年 4 月，每个财政年度的常规配额为 65,000 个名额，此外还有 20,000 个名额专门留给拥有美国硕士及以上学位的申请者。这一配额系统导致了高度竞争，尤其是在技术和工程等领域。\n 申请流程\n\n雇主提交申请：H-1B 签证的申请是由美国雇主发起的，而不是由外国工人本人发起。雇主需要提交劳工条件申请（LCA）到美国劳工部，证明雇用 H-1B 工人不会损害同一地区类似职位的美国工人的工资和工作条件。\n注册和抽签：由于 H-1B 签证受到数量限制，USCIS 实施了一个电子注册和随机抽签过程来决定哪些雇主可以提交 H-1B 申请。\n提交 H-1B 申请：被选中的雇主随后可以向 USCIS 提交完整的 H-1B 签证申请，包括表格 I-129。\n\n 工作期限\nH-1B 签证初始批准的最长期限通常为三年，可以延长，但总期限通常不超过六年。在某些情况下，当 H-1B 持有人在绿卡申请过程中达到一定阶段时，可以进一步延长。\n 家属\nH-1B 签证持有者的配偶和未成年子女可以申请 H-4 签证，以陪伴 H-1B 签证持有者居住在美国。在某些情况下，H-4 签证持有者可能有资格工作。\n 转换雇主\nH-1B 签证持有者可以转换雇主，但新雇主必须提交新的 H-1B 申请，并且该申请需要获得批准。\n 永久居留权（绿卡）\nH-1B 签证持有者可以申请美国永久居留权（绿卡）。这个过程通常需要雇主的支持，并且包括多个步骤，如劳动力市场测试（PERM）、提交移民申请（I-140）等。\nH-1B 签证是连接外国专业人才与美国劳动市场需求的重要桥梁，但由于其数量限制、竞争激烈和复杂的申请。\n 关于 PERM\nPERM（Program Electronic Review Management）是美国劳动部（DOL）的一个程序，它是申请雇主担保的永久居留权（即绿卡）的第一步。PERM 过程设计用来确保美国雇主招聘外国工人填补特定职位时，不会对美国工人的工资和工作条件产生负面影响。这个程序要求雇主在正式提交绿卡申请之前，进行一系列的测试劳动市场的活动，以证明没有合格的美国工人可用来填补该职位。\n PERM 的关键步骤：\n\n确定职位需求：雇主必须准确描述该职位的职责、技能、教育和经验要求，以及任何其他必要的资格条件。\n工资确定：雇主必须从劳动部获得该职位的适当工资水平（Prevailing Wage Determination，PWD），以确保拟议的薪酬符合所在地区相似职位的标准工资水平。\n招聘活动：雇主必须在本地劳动市场进行招聘，以证明没有合格的美国工人愿意接受该职位。这通常包括在报纸上发布广告、使用职业招聘网站、参加职业招聘会等。\n提交 PERM 申请：完成招聘活动并证明找不到合适的美国工人后，雇主可以向劳动部提交 Form ETA-9089（PERM 申请表）。该申请详细描述了职位、招聘过程和工资确定的过程。\n审核过程：劳动部将审核 PERM 申请，以确定雇主是否符合所有规定和要求。审核过程可能包括对提交的信息的确认，以及有时对雇主的招聘程序进行审计。\n\n 审核结果\n\n如果 PERM 申请被批准，雇主可以进入下一步，即向美国移民服务局（USCIS）提交 I-140 移民请愿书，为外国工人申请永久居留权。\n如果申请被拒绝，雇主可以根据拒绝的原因选择重新申请或提出上诉。\n\n 关于绿卡\n美国绿卡，正式名称为美国永久居民卡，代表持有者在美国的永久居住权。绿卡持有者享有在美国生活和工作的权利，同时必须遵守美国的法律和规定。绿卡可以通过多种途径获得，包括家庭关系、就业、难民或庇护申请、多样性移民签证抽签，以及其他特定的类别。\n 家庭关系\n\n直系亲属移民：美国公民的直系亲属，如配偶、未婚的子女（年龄在 21 岁以下），以及父母（如果美国公民年满 21 岁）可以申请绿卡。\n其他亲属移民：美国公民的成年子女、已婚子女、兄弟姐妹，以及美国永久居民的配偶和子女也有资格申请，但这些类别受到名额限制。\n\n 就业基础\n\n优先工人：包括拥有杰出能力的个人、杰出教授和研究人员，以及某些跨国公司的经理和高级职员。\n专业人士和技能工人：需要至少学士学位的职位，以及其他非季节性工作的技能工人和其他工人。\n特殊类别的就业：如宗教工作者和某些前美国政府雇员等。\n\n 难民或庇护申请\n\n被授予难民或庇护地位的人在美国至少一年后，可以申请成为永久居民。\n\n 多样性移民签证（DV）\n\n通过每年的多样性签证抽签程序，来自低移民率国家的人有机会获得绿卡。此程序旨在增加来自全球各地的移民多样性。\n\n 特殊移民类别\n\n包括一些特殊情况的人员，如美国武装力量的某些成员、特殊移民少年、某些雇主的国际组织雇员等。\n\n 绿卡申请流程\n申请流程因申请类别而异，通常包括提交申请、提供必要的文件证明、进行健康检查、接受面试以及等待处理结果。对于就业类别的申请，通常还需要经过劳动市场测试（PERM 过程）和雇主的担保。\n 权利与义务\n绿卡持有者除了拥有在美国居住和工作的权利外，还有权申请美国公民的配偶和未成年子女的绿卡，参加某些政府援助项目，并在满足条件后申请成为美国公民。同时，他们也必须遵守美国的法律，报税，以及在特定条件下支持美国的国防。\n 持有绿卡的限制\n尽管绿卡提供了许多权利，但持有者不能投票或担任某些政府职务。此外，如果犯有严重罪行，或在外国停留过长，可能会失去永久居民身份。\n 关于就业赞助（Sponsor）\n就业赞助在美国移民法律框架内是一个关键概念，尤其针对那些希望通过工作机会获得临时工作签证或永久居留权（绿卡）的外国人。就业赞助通常意味着一个美国雇主愿意担保外国工人的签证申请，以使其能够合法在美国工作。这个过程根据申请的签证类型不同而有所差异，下面是就业赞助的几种常见情况。\n H-1B 签证赞助\nH-1B 签证是最常见的非移民工作签证，适用于在专业职位工作的外国专业人士。雇主必须证明所提供的职位需要专业知识（通常是指需要至少一个学士学位或等同学历的专业领域）。\n\n赞助流程包括提交劳工条件申请（LCA）到美国劳工部，以及向美国移民服务局（USCIS）提交 H-1B 签证申请。雇主需要承担相关费用，并证明雇佣外国工人不会损害美国工人的工资和工作条件。\n\n L-1 签证赞助\nL-1 签证为跨国公司内部调派员工到美国工作提供了机会。这适用于那些在美国公司的母公司、子公司、附属公司或分公司工作的管理人员、执行人员或具有专门知识的员工。\n\n赞助流程涉及证明外籍员工对美国公司是必不可少的，以及证明外籍员工与公司之间的关系。L-1 签证不需要劳工部的批准，但需要向 USCIS 提交详细申请。\n\n E-3 签证赞助\nE-3 签证专为澳大利亚公民设计，允许他们在美国的专业职位上工作。与 H-1B 签证类似，但专为澳大利亚公民保留。\n\n赞助流程包括提交 LCA 和证明职位符合专业职位的要求。E-3 签证对澳大利亚公民来说是一个较为简便的工作签证选项。\n\n 永久居留权（绿卡）赞助\n对于希望永久移居美国的外国工人，雇主可以通过就业基础的绿卡程序进行赞助。这个过程通常包括几个步骤，如劳动市场测试（通过 PERM 程序）、提交移民请愿书（I-140 表格）等。\n\n赞助流程要求雇主证明没有合适的美国工人能够填补该职位，且雇佣外国工人不会影响美国工人的工资和工作条件。这一过程既复杂又耗时，需要雇主和申请人密切合作，以确保符合所有要求。\n\n 赞助人的责任和义务\n\n赞助雇主需承担一定的责任，包括但不限于承诺支付合适的工资、在某些情况下支付申请人回国的费用，以及确保工作环境符合所有适用的法律和规定。\n在绿卡赞助的情况下，雇主还必须通过劳动部的审查，证明他们进行了充分的努力在美国劳动力市场上寻找合适的候选人，但未能找到。\n\n 留学生相关\n对于留学生而言，就业赞助主要涉及到两个方面：在学习期间的实习机会以及毕业后的全职工作机会。对于希望在美国工作的留学生来说，找到愿意提供就业赞助的雇主是一项重要任务，尤其是对于那些希望通过工作机会获得 H-1B 签证或其他工作签证，进而在美国长期居住和工作的留学生。\n 实习赞助：CPT（Curricular Practical Training）\nCPT 允许持 F-1 签证的留学生在学习期间获得与其学习领域相关的实习或就业机会。在这种情况下，赞助通常不需要雇主提交复杂的移民文件，因为 CPT 是学生身份的一部分。然而，雇主可能需要与学生的学校合作，确保提供的职位满足 CPT 程序的要求，并且学生能够获得相应的学术学分（如果适用）。这种赞助相对简单，重点在于提供实践工作经验。\n 毕业后就业赞助：OPT（Optional Practical Training）和 H-1B 签证\nOPT 赞助：OPT 允许留学生在完成学业后在美国获得一年（非 STEM 专业）或最多三年（STEM 专业）的工作经验。虽然 OPT 期间的工作不需要雇主直接参与赞助或提交特定的移民文件，但找到一份职位仍然至关重要。在 OPT 期间工作的留学生可能希望将这一机会转变为长期职业发展路径，这通常意味着需要找到愿意为其提供 H-1B 签证赞助的雇主。\nH-1B 签证赞助：对于希望在 OPT 后继续在美国工作的留学生，最常见的路径是通过 H-1B 签证程序。H-1B 要求雇主赞助留学生申请工作签证。这一过程包括：\n\n劳工条件申请（LCA） ：雇主必须向美国劳工部证明拟议的工资不低于该地区相同职位的标准工资，并且雇佣外籍工人不会损害美国工人的工作条件。\n提交 H-1B 签证申请：雇主必须在每年的 H-1B 申请窗口期间向美国移民局（USCIS）提交申请，并且因为 H-1B 签证有年度名额限制，所以存在通过抽签选中的不确定性。\n\n","categories":["常识"],"tags":["美国"]},{"title":"前后端分离项目云服务器部署","url":"/2024/09/30/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/","content":" 前端配置\nvue 配置后台地址\n/public/config.json\n&#123;  \"serverUrl\": \"http://localhost:8080\"&#125;\nmain.js\nimport axios from \"axios\";//读取外部配置文件axios.get(\"/config.json\").then((res) =&gt; &#123;  app.config.globalProperties.$config = res.data;&#125;);export const globals = app.config.globalProperties;\nrequest.js\nimport &#123; globals &#125; from \"@/main\";import axios from \"axios\";const serverUrl = globals.$config?.serverUrl || \"http://localhost:8080\";const request = axios.create(&#123;  baseURL: serverUrl,  timeout: 30000,&#125;);\n如果有跨域问题，则可以在 vite.config.js 中引入\nimport &#123; defineConfig, loadEnv &#125; from \"vite\";const serverUrl = globals.$config?.serverUrl || \"http://localhost:8080\";export default (&#123; mode &#125;) =&gt;  defineConfig(&#123;    server: &#123;      proxy: &#123;        \"/api\": &#123;          //获取路径中包含了/api的请求          target: loadEnv(mode, process.cwd()).VITE_APP_URL, //后台服务所在的源          changeOrigin: true, //修改源          rewrite: (path) =&gt; path.replace(/^\\/api/, \"\"), //api替换为''        &#125;,      &#125;,    &#125;,  &#125;);\n然后在.env.development 和.env.production 中写好环境变量\n# dev.developmentVITE_APP_URL&#x3D;&quot;http:&#x2F;&#x2F;localhost:8080&quot;\n# dev.productionVITE_APP_URL&#x3D;&quot;http:&#x2F;&#x2F;114.55.132.144:8080&quot;\nvue 打包：npm run build\n 后端配置\n给服务器安全组添加 8888 端口规则\n这里以阿里云为例\n​​\n安装宝塔\nyum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec\n然后用打开显示的外网 ip 并用账号密码登陆\n本地配置\nspringboot 打包：mvn clean package\nXshell (命令)和 Xftp (上传文件)\nifconfig 命令可以查看内网 ip，配置 application-prod.yml 的数据库 url\nspring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://172.27.133.111:3306/big_event    username: root    password:  data:    redis:      host: localhost      port: 6379server:  port: 8080\n常用命令\n# 查看端口占用netstat -nlp | grep 8085# 关闭对应PIDkill -9 372027# 查看logtail -f server.log# 运行jar，nohup 不挂断的运行cd /home/big-eventnohup java -jar big-event-0.0.1-SNAPSHOT.jar &gt; server.log 2&gt;&amp;1 &amp;# 创建脚本echo \"nohup java -jar big-event-0.0.1-SNAPSHOT.jar &gt; server.log 2&gt;&amp;1 &amp;\" &gt; start.sh# 文件所有者有读、写、执行权限，文件组有读、写、执行权限，其他用户没有权限chmod 770  start.sh# 运行脚本./start.sh\n 服务器配置\n安装 nginx\n# 安装gccyum install gcc-c++# 安装PCRE pcre-develyum install -y pcre pcre-devel# 安装zlibyum install -y zlib zlib-devel# 安装Open SSLyum install -y openssl openssl-devel\n进入 tmp\ncd /tmp/wget http://nginx.org/download/nginx-1.24.0.tar.gztar -zxvf nginx-1.24.0.tar.gz\n解压\ncd /usr/localmkdir nginxcd nginxcp -R /tmp/nginx-1.24.0 ./cd nginx-1.24.0#编译，执行命令，考虑到后续安装ssl证书，添加两个模块，如不需要则直接执行./configure即可./configure --with-http_stub_status_module --with-http_ssl_modulemake &amp;&amp; make install\n进入 nginx\ncd /usr/local/nginx-1.24.0/sbin./nginx./nginx -s stop #停止./nginx -s start #启动./nginx -s reload #重启\n编辑/usr/local/nginx/conf/nginx.conf，使得 root 指向前端文件所在目录\ncd ..cd confvi nginx.conf# \"a\"进入编辑模式# \"esc\"退出编辑模式# \":wq\"保存\nserver &#123;        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / &#123;            root   /home/big-event/dist;            index  index.html index.htm;        &#125;\n然后\ncd ..cd sbin/./nginx -s reload# 可能报错# nginx: [error] open() \"/usr/local/nginx/logs/nginx.pid\" failed (2: No such file or directory)# 于是/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf# 显示端口占用# nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)# 查看端口netstat -ntlp|grep 80# tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      152578/nginx: maste# kill -9无效fuser -k 80/tcp# 重启nginxcd /usr/local/nginx/sbin./nginx\nredis\ncd /usr/local/redis-6.0.8/src# 关闭redis-cli shutdown# 重启redis-server redis.conf# 查看ps -ef|grep redis# 端口netstat -ntlp|grep 6379./redis-server /etc/redis.conf./redis-server /usr/local/redis-6.0.8/redis.conf\n重启服务器\ncd /home/big-event# 运行脚本./start.sh# 重启nginxcd /usr/local/nginx/sbin\n","categories":["计算机"],"tags":["运维"]},{"title":"图床使用方案","url":"/2024/09/30/%E5%9B%BE%E5%BA%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88/","content":"图床就是将你的本地图片上传到相关服务商或者个人服务器，然后获取图片对应的网络访问地址，使用者可以方便快速的将图片插入到文章中，后续图片二次使用、迁移、分享都会非常简单。这里主要介绍我的个人方案。\n Github\n 创建 Github 新仓库\n​\n一定要勾选 public，不然别人看不到图，然后建议加一个 README 文件。\n​\n看到如下界面就说明图床已经创建好了，接下来就是上传图片了。\n\n 下载 PicGo\n推荐使用一个开源图床工具  PicGo  来作为我们的图片上传工具，打开链接的官网后点击免费下载后会跳转到 Github 的界面。\n\n一般前几个是 beta 版本，也就是测试版本，所以我们选择后面的正式版。\n\n在所需下载版本的最后的 https://assets.saoyu.fun 中选择对应的系统版本，windows 系统 32 位就选 ia32，64 位就选 x64，或者直接直接选下面那个 setup exe 的，ios 系统选 dmg。\n\n安装之后软件的界面大概是这样。\n\n 创建 Github token\n在 Github 里打开 Settings\n\n然后翻到最下面左侧选择 Developer settings\n\n进入 Developer settings 后选择左边 Personal access tokens 里的的 tokens (classic)，最后点击 Generate new token (classic)。\n\n填写用途，我选择的是永不过期，并勾选 repo，然后点 Generate token 即可\n\n这个 token 只会显示一次，所以最好把它复制下来存好，方便下次使用，否则下次有需要重新新建。我的话直接在 Github 上新建一个 private 库来存这个 token，这样想用也能随时找到。\n\n 配置 PicGo\n打开 PicGo，选择图床设置中的 GitHub 然后设置如下，其中仓库名是刚刚创建的仓库，分支名一般是 main，Token 就是刚刚生成的那个，最后点击确定。\n\n我一般直接选择 qq 或者 snipaste 截图然后直接剪切板图片快捷上传，或者直接拖动图片上传。\n​\n也可以通过快捷键上传，默认为 ctrl + shift +P。\n\n如果在国内的话 Github 图片访问可能会很慢，所以这时候我们就可以用  jsDelivr  进行免费加速，而设置的方法也很简单，只需要在我们 PicGo 图床配置中添加如下自定义域名即可\n\nhttps://cdn.jsdelivr.net/gh/用户名/仓库名\n\n\n NPM\n 注册账号\n首先访问npm 注册页面，注册一个 npm 的账号。\n 完成验证\n注册完成后进入账号管理界面:头像-&gt;Account，你会看到Two-Factor Authentication的栏目，点击以后按提示步骤完成双重验证，这里我选择的是 app，下载一个 google 或者 microsoft 的 Authenticator 就行。\n\n然后打开下载的 app 扫描二维码就能添加好了。\n 上传图片\n在需要上传的文件夹中打开终端或者 git bash，输入以下指令切换回原生源\nnpm config set registry https://registry.npmjs.org\n添加本地 npm 用户设置\n# 仅第一次使用需要添加用户，之后会提示你输入你的npm账号密码以及注册邮箱npm adduser# 非第一次使用直接登录即可，之后会提示你输入你的npm账号密码以及注册邮箱npm login\n运行 npm 初始化指令，把整个图床仓库打包，按照指示进行配置，注意需要事先确认你的包名没有和别人已发布的包重复，可以在 npm 官网搜索相应包名，搜不到就说明还没被占用。\nnpm init\n接下来要填写一些信息\n#npm包名称，建议用id+仓库名，可以避免重名package name:xiansakana-https://assets.saoyu.fun#版本号version:1.0.0#描述，可以不写description:#入口点，默认即可entry point:#测试命令，默认即可test command:#关联的github仓库，也可以不写git repository:#关键词，也可以不写keywords:#作者名author:xiansakana#许可证，默认即可license:\n然后输入发布指令，我们就可以把包发布到 npm 上了\nnpm publish\n\nnpm 每次 publish 更新前都需要在 package.json 修改 version 版本号，所以可以用更新 package.json 里的版本号的指令，效果是末尾版本号+1，例如0.0.1=&gt;0.0.2、1.1.3=&gt;1.1.4，免去了打开package.json再修改版本号的麻烦。（大版本更新还是需要手动改的）\n\n// patch：补丁号，修复bug，小变动，如 v1.0.0-&gt;v1.0.1npm version patch// minor：次版本号，增加新功能，如 v1.0.0-&gt;v1.1.0npm version minor// major：主版本号，不兼容的修改，如 v1.0.0-&gt;v2.0.0npm version major\n我个人的做法是用 bat 批处理，新建一个npm publish.bat文件\nstart cmd /c \"d: &amp;&amp; cd data/npm/xiansakana-blog-img &amp;&amp; npm version patch &amp;&amp; npm publish\"\n当然除此之外也还可以添加 github action 自动发布 npm 包\n首先进入 github 仓库的 action，然后 choose a workflw，选择 simple workflow，修改该 yml\nname: Node.js Packageon:  push:    branches:      - mainjobs:  publish-npm:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - uses: actions/setup-node@v1        with:          node-version: \"12.x\"          registry-url: https://registry.npmjs.org/      - run: npm publish        env:          NODE_AUTH_TOKEN: $&#123;&#123;secrets.npm_token&#125;&#125;\n然后去 npmjs 创建 npm token，选择 automation\n\n在 github 仓库的 secrets 中创建 new repository secret\n\n在本地的仓库文件夹下打开终端，运行以下指令，上传新增内容至 github，即可触发部署。\n# 将更改提交git add .git commit -m \"npm publish\"# 更新package版本号npm version patch# 推送至github触发actiongit push\n 引用图片\nnpm 的很大优点是，节点有很多，可以任意挑一个使用。目前节点有：\njsDelivr+npm\nhttps://cdn.jsdelivr.net/npm/package@version/file\n百度节点\nhttps://code.bdstatic.com/npm/package@version/file\n饿了么节点，回源是 Unpkg\nhttps://npm.elemecdn.com/package@version/file\n饿了么节点，回源是 JSdelivr\nhttps://shadow.elemecdn.com/npm/package@version/file\nunpkg 自建(UNPKG 是一个内容源自 npm 的全球快速 CDN。它部署在 cloudflare 上，在大陆地区访问到的是香港节点。所以速度也不错。)\nhttps://cdn.cbd.int/package@version/file\nhttps://unpkg.com/package@version/file\n另外，如果是直接通过包名和文件的方式不添加版本号访问，默认是最新版本的 package，比如\nhttps://cdn.jsdelivr.net/npm/[NpmPackageName]/[file]\n\n关于图片缓存服务：\n可以将有防盗链的图片引用到网页，并成功显示。\n可以将 http 图片引用到 https 页面而不出现证书问题。\n可以将 xxx 的图片，成功加载。\n可以将比较慢的图片资源，加快显示。\n\n\n国内网宿节点，只能加载特定图床图片如 imgur\nhttps://search.pstatic.net/common/?src=\nAkamai 节点，没有使用限制\nhttps://imageproxy.pimg.tw/resize?url=\nCloudFlare 节点\nhttps://images.weserv.nl/?url=\nCloudFlare 节点\nhttps://pic1.xuehuaimg.com/proxy/\n\n Backblaze + Cloudflare + PicGo\n这个方案有以下优势：\n\n每月前 10G 流量免费\nCloudflare 做 CDN 加速\n可自定义域名\n\n开始前，你需要有以下条件：\n\n域名\nBackblaze 账户\nCloudflare 账户: 按照网站提示接入域名即可\n\n Backblaze\nBackblaze 是一个云存储解决方案，为什么选用他呢，是因为其前 10G 存储是完全免费的，这用于做图床是非常够用的。\n先注册一个账号（输入邮箱就行），然后点击Create a Bucket，创建一个存储桶，填写名称，记得选择Public权限，注意存储桶名称在 Backblaze 中必须是全局唯一的，\n\n之后点击生命周期的设置，将其设置为Keep only the last version of the file，只保留 bucket 内最新版本的文件。\n\n为了获取桶域名，点击Browse Files直接上传一张图片，上传成功后直接点击图片，会看到如下信息：\n​\n Cloudflare\n打开Cloudflare 官网并进行注册\n根据提示前往域名注册商修改 DNS 解析服务器到 Cloudflare 提供给你的服务器地址，不同用户地址不同，个人使用选择免费计划即可。\n\n提取之前在 Backblaze 中Friendly URL显示的域名信息，比如我这里是：https://f005.backblazeb2.com/，然后在 Cloudflare 添加新的 CNAME 记录，二级域名可以根据喜好选择\n\n接下来点击左侧的SSL/TLS，设置完全(严格) 模式：\n\n为了避免无法命中缓存或回源次数过多导致加载速度低下，我们需要回到 Backblaze 进行桶信息设置，添加{&quot;cache-control&quot;:&quot;max-age=86400&quot;}，意味 86400 秒内 Cloudflare 不再返回源站重新获取信息。\n\n注意，回源时为 CDN 节点回源站重新拉去数据，然后再传递给用户，并不是将源站地址直接转给用户，所以无需担心回源过多导致的免费流量配额消耗完毕。max-age 可以不用太长，太长的话若源文件发生更改，且站点没有主动推送到 CDN 节点时会导致用户不能及时得到最新版本。（BackBlaze也存在免费请求次数显示，B 类 C 类请求每天各 2500 次，暂时未确定 Cloudflare 访问是否计算请求次数，故也不建议太短）\n\n\n接下来使用 Cloudflare 的转换规则隐藏 bucket 名称，选择左侧规则中的转换规则，然后创建一个新的转换规则\n\n之后将Friendly URL中的f005.backblazeb2.com/file/saltedfish-img/替换为刚刚自定义的域名后，就能正常打开图片了。\n在浏览器中打开开发人员工具（默认快捷键是 F12），可以看到在请求链接时，响应头有一些 X-Bz 开头的字段，这些都是和 Backblaze 云存储相关的，要把它们都隐藏掉。\n在 Cloudflare 打开 Rules&gt;Transform Rules，选择 Modify Response Header，点击 Create rule 创建响应头修改规则。选择 All incoming requests，通过点击 Set new header 来添加一行 Header 配置，将类型设置为 Remove，将所有 X-Bz 开头的字段添加进去，然后点击 Deploy 部署规则即可\nX-Bz-Content-Sha1X-Bz-File-IdX-Bz-File-NameX-Bz-Info-Src_last_modified_millisX-Bz-Upload-Timestamp\n最后再次测试、查看响应头信息中，规则配置好的字段是否都已移除。\n进入 cloudflare 控制台，缓存-&gt;Cache Rules，创建新缓存规则。\n\n匹配规则(http.host eq “图床域名”)\n缓存资格：选择符合缓存条件\n边缘 TTL：选择忽略缓存控制标头，使用此 TTL，缓存时间设置为一个月\n浏览器 TTL：选择替代源服务器，使用此 TTL，缓存时间设置为一个月\n缓存密钥：开启缓存欺骗盔甲\n\n PicGo\n图床搭建完毕后，若不进行其他操作，每次上传图片都需要打开 Backblaze 的网站并在完成身份验证后进入桶设置页面进行上传，即不便捷也不友好。因此介绍一款跨平台且同时支持命令行与可视化界面的图片上传工具——PicGo。主要功能即为上传图片到你指定的位置，并获取图片链接，搭配 typora 编辑器可以直接在粘贴图片时就自动上传并将链接写入 Markdown 文档，避免图片在其它网站或放在本地后移动文档导致的图片丢失。\n进入项目主页，下载并安装 PicGo。\n选择插件设置，搜索s3或进入插件项目主页下载并安装该插件。\n为了让第三方软件可以使用Backblaze，接下来需要获取Application Keys，打开的Backblaze 官网的 AppKeys 设置页面，添加一个新的 Key 建议不要使用建议不要使用Master Application Key。\n\n注意：Key 的最长有效时间为 1000 天，即 86400000 秒，过期后请重新申请\n\n\n当密钥创建成功，记录得到的Key ID、applicationKey、桶名称、桶的Endpoint地址，因为页面关闭后就自动不再展示。分别填写到对应位置。\n\n之后就是一边写博客，一边把图片往支持额外命令行的编辑器（比如typora）里拖放或者黏贴就行了。\n 阿里云 oss\n首先放上官网：https://oss.console.aliyun.com\n 创建一个 Bucket\n\n 绑定域名（若无则跳过）\n试了下结果要备案，毕竟我是托管在 github 上面的就没必要备案，而且备案听说很麻烦，所以…嗯。咕咕咕\n 上传文件\n然后就可以在文件列表中上传文件了，但是这样管理起来会不太方便，所以可以考虑下载客户端：安装并登录 ossbrowser\n\n同时，阿里云 oss 也可以通过 PicGo 来上传，但是需要添加 key。首先选择右上角的 AccessKey 管理然后创建 AccessKey 就行了。\n\n同样，记下生成的AccessKey ID和AccessKey Secret，然后添加到 PicGo 中就可以使用啦。\n\n","categories":["笔记"],"tags":["图床"]},{"title":"常用Linux操作","url":"/2024/09/30/%E5%B8%B8%E7%94%A8Linux%E6%93%8D%E4%BD%9C/","content":" 端口占用\nnetstat -aon|findstr \"8888\"taskkill /T /F /PID 8888\n‍\n","categories":["计算机"],"tags":["Linux"]},{"title":"炒股日记2025","url":"/2025/02/24/%E7%82%92%E8%82%A1%E6%97%A5%E8%AE%B02025/","content":" 2 月\n 20250224（周一）\n国内市场这一波算是赚的盆满钵满，不管是 a 股还是港股个人感觉都即将回调，遂轻仓，落袋为安。\n\n美股市场由于上周五的全线大跌，加上一系列利空消息，今天也状况不佳。首先阿里的买入点有很大问题，一般最佳的操作时间是开盘时（趋势明显）和接近收盘时，而我这次却在震荡时候冲动买入 put，好在后面为了对冲风险又加了个 call；而英伟达（26 号盘后财宝）这个 call 也是在震荡时候买入，结果买完发现没钱买 put 了去对冲了，结果就是错过了快收盘时的一波行情。\n\n\n看到一天-200 的浮亏还是挺难受的，心态上还是难以接受，毕竟之前都是吃分红股很稳健。所以还是要提醒一下自己，期权一定要控制在 1k 以内。\n总结：\n\n不要在震荡行情买期权。\n期权日内交易尽量开盘看准方向后果断买入。\n不确定的时候一定要对冲。\n\n 20250225（周二）\n今天把昨天的两个期权都清仓了，还是别玩了，除非当天看准方向玩单腿的，不然纯粹就是赌博，真不如按兵不动。不过好在国内股票这个月还可以涨了不少，只能说还是得按部就班来，不能总想着暴富，毕竟别人期权很多都是用来对冲正股的。\n\n 20250226（周三）\n今早看 SMCI（超微电脑）夜盘因为补充了财报猛猛涨，想着开盘肯定很多人跑路就买了 48 的 put，结果其中本来是有两次机会盈利跑路的，结果没跑掉直接被多头干翻。果然还是得搞价值投资，不能投机了，这个月的期权也算买教训了吧。\n\n所以目前把 BBAE 账户里的看好的公司都买了，其中有些（COST, PLTR, SOFI, NKE, AMD）都是在一个 youtube 博主上看到推荐的，他的频道基本上都是各种公司的分析，在这里 mark 一下FinancialEducation。然后目前 BBAE 里面的持仓大概是 5k 刀，这些不打算动了，感觉越操作会越亏，甚至金融危机美股崩盘都不会去动。接下来大概率会专注于国内市场，毕竟最近刚好有行情，而美股这边看起来非常的乏力，不一定能涨的动。所以目前的打算是，等汇率掉下来之后再去美股市场，到时候应该会有一个很大的底可以抄。唯一可惜的是昨天的国内港股市场没来得及补仓，导致今天的大涨没吃到多少仓位，只能等接下来的回调了。\n\n美股收盘一看差点给我气死，之前的超微期权刚好出在顶上，后面其实一直往下掉，如果我不操作的话可以说是稳赚而且还不少。只能说期权这玩意太考验人性了，最好还是别单独碰了。\n\n 20250227（周四）\n今天的 a 股和港股都是大跌，不过我的仓位已经很低了，只有 5%不到，决定加仓 2k 到恒生科技 ETF，看看明天情况再做定夺。\n至于美股，昨天英伟达财宝超预期，结果今天开盘直接大跳水，结果我每跌一块买一股都感觉不敢买了，最后干脆直接上了一个 111 的 put 作为对冲，不过是末日期权，如果明天继续这么跌那就血赚了，不过没跌的话也亏不到哪去，毕竟只买了一张。\n\n\n 20250228（周五）\n今天 a 股和港股直接大跌，本来决定继续持有的，不过看到已经掉下 10 日均线还是挺危险的，决定直接做 T，看看下周一如何变化，如果下周一还不见好转的话，就到了跑路的时间了。\n\n美股开盘我直接挂单 118 继续加仓，毕竟能便宜买到优质公司的股票，为什么要怕呢？不过尽管看起来这个赚了，但之前买的用来对冲的 put 直接亏没了，所以感觉还是不该碰期权，老老实实按部就班做正股交易就好，别老想一步登天。\n\n 3 月\n 20250301（周一）\n今天美股又是暴跌的一天，qqq 也差不多快到 200 天均线了，感觉这下真的要衰退崩盘了，准备明天就把所有股票清仓了开摆，刚好够我在美国这最后三个月的开销，不然还得从国内电汇过来（现在这个汇率太高了）。国内市场还是老样子，开始往下阴跌了，只能国债逆回购躺平了。\n\n\n 20250306（周四）\n今天美股又是暴跌啊，画了条线，确实挺好用的。\n\n至于港股这周直接突破了，上周回调我还以为行情快结束了直接全跑了，血亏。不过也可能跟最近开两会有关系，听说今年应该还会降准降息，感觉国内的牛市是真要来了，后面再看看机会如果有回调感觉可以继续建个仓了。\n\n 20250307（周五）\n今天买了一张 21 号的英伟达 120 的看涨期权，感觉已经到压力位了，看看后两周效果如何。\nCostco 由于财报不及预期直接暴跌 7%，之前那个 youtube 博主就推荐了 250815880 的 put，估计今天已经有快 70%的收益了，可惜我之前没买。至于理由，我觉得他说的还是挺有道理的。\n\n首先，costco 的估值太高，再加上利润率可能会出现问题，相当于是一直处于一个紧绷的位置，所以一点点其他的风吹草动都有可能造成大跌。\n其次，之所以买今年 8 月 15 的看跌期权，一个是因为到期时间较长，期权的时间价值损耗并不是很明显，还有就是随着股价的波动也并不是很明显，只需要一个很小的利空消息，就可以获得可观的收益。\n最后，我看他最新的视频上已经跑路了，毕竟见好就收才是活的久的原因。\n\n\n 20250312（周三）\n今天 CPI 数据还符合预期，所以上周买的英伟达期权终于可以跑了，落袋为安。主要是到期时间太近了，如果下个月到期的话还可以等一等。毕竟如果公司的基本面和宏观经济数据都没出问题，就没有理由再继续跌了，也该是时候反弹了，果然有时候还是得坚定自己的想法。今天直接冲了，买了 20 股英伟达和 50 股 tqqq，感觉美股有短期反弹的迹象，已经到压力位了，加上 CPI 还可以，没有继续再跌的理由了感觉。\n\n 4 月\n 20250407（周一）\n好久没记录了，就不提前段时间因为关税美股崩盘了。今天等到个机会直接把前几天抄底的一些股票获利了结了。a 股的话，债券和股票全部开盘清仓，准备换美元转过去，一是手上美元不够用了，其次感觉快到慢慢部署美股的好机会了，而且钱多操作起来也方便些。\n\n 20250408（周二）\n昨天买了点 tqqq 抄底，因为感觉今天会有点反弹，结果真的 tqqq 直接反弹了 10 个点，于是赶紧跑路，果真刚跑路大盘就开始跳水了。a 股最近也不太关注了，毕竟还是打算把资金全转到美股这边来。\n\n 20250409（周三）\n今天算是见证历史了，盘中 Trump 的关税除中国延缓 90 天，大盘直接拉涨 10 多个点。本来我是听说 2 点钟 Trump 有动作的，没想到反应这么大，其实这种找不准方向的时候多空双买肯定能赚的，毕竟波动实在是太大了。果然昨天那波的假消息就是提前放出来测试下效果的，可惜没当回事诶。这波踏空，之后感觉能找准机会开始做空了，毕竟经济衰退肯定是会来的，而且关税也只是暂缓，就懂王这朝令夕改的政策，谁知道下次反转是啥时候。\n\n 20250416（周三）\n下午一点半的时候出了个消息：鲍威尔表示，关税可能会在控制通胀和促进经济增长之间给美联储带来挑战。然后大盘又往下跳水，于是便顺势而为，买了一百股 sqqq。只能说现在美股真是处处是机会，波动太大了，同时也给人摇摇欲坠的感觉，稍微一个风吹草动就会掀起巨浪。\n\n快收盘的时候有反转的趋势，果断跑路了。\n\n 20250417（周四）\n今天看盘看到英伟达局势不对，直接买了 10 张 put，结果 nvda 股价果然一路下行，中途一度浮盈超过 300 刀。\n\n其实当时盘中是有一个大反弹的，不过我以为是反转所以就跑路了，不然如果能拿到之后那波应该可以赚 1k 刀的，只能说还是经验不足吧，还有一种原因可能就是我的成本太高，不敢拿太久，不然稍微反弹起来可能就是亏损了。当时唯一的失误可能就是只看了 1 分钟的 k 线，其实之后看了 15 分才发现还没有到反弹的点位，所以不用太担心，其次就是不应该直接卖空了的，好歹留一两张看看情况，不然错过后面的行情只能拍大腿咯。\n\n 20250421（周一）\n今天开盘大跌，直接顺势而为，买了十张第二天到期的 put，然后盘中有一点反转的迹象就卖了一半，最后还是因为没有拿到最后，只赚了 1000 刀（本金 3000），不然不出意外应该是能翻倍的，当然见好就收也是一种不错的选择。\n\n 20250422（周二）\n也不知道为啥，可能是因为波飘了，昨天盘尾直接快盘尾的时候买了 QQQ 的 7 月 31 号到期 350 的 put 和 TSLA7 月 18 号到期 200 的 put，后面复盘起来才意识到不应该这个点进的，毕竟对于这个楔形走势，差不多到了底部了，就算买远期 put 也应该选择更好的点位，而不是无脑进，结果就是第二天就有个大的反弹，导致 put 浮亏很多，不过越是这个时候就越得沉得住气，不然就是被来回割的剧本。其次，我也不知道为啥会去买 TSLA 的期权，可能是觉得财报吧，毕竟大概率财报不行，但是别忘了，TSLA 的财报不是股价走势的决定因素，Musk 才是，所以很可能是财报差但是涨。另一方面，TSLA 的 IV 太高，根本没办法买期权，只能说盈亏比太差，我买了之后才意识到这点，果然还是不能去碰自己不熟悉的领域，不然稍有不慎就会翻车。\n\n总体来说，今天的走势非常的动荡，反复横跳，一天下来至少反转了三四次，不过我只做了第一波反转的下跌段，买了三张 5 月 1 号到期的 put，然后中间止盈了两张，最后一张本来打算看情况，结果就没机会跑了。原因之一是正股上涨的时候根本没有人去买比较远一点的 put，导致流动性极差，也就没有跑掉，所以就留着了，但是这个下周到期还是有点麻烦，时间上太近了。\n除此之外，还买了一张 QQQ 的 8 月 15 到期的 410 的 put，截止到收盘浮亏 5 个点。\n\n盘后 Trump 又开始讲话，导致盘后大涨，这下我的 put 又得打折扣了，好在大多都是远期的，但也不好受，果然还是得顺势而为，长期期权对我来说还是太难了，我还是比较适合做日内的短线。\n\n最后有几个点需要反思注意下。\n\n一定不要买在压力位，卖在支撑位，\n控制期权的仓位，短期期权不过夜。\n做日内尽量买近的期权，流动性强，快进快出。\n期权的行权价格不要买太远的，即使是远期期权。\n不做不熟悉的股票。\n\n 20250423（周三）\n今天最大的失误就是做了太多的日内，而且容易受情绪主导，非常容易被反复割，因为行情转变实在是太快了，反复无常的政策。今后每天最多只做一笔，一成仓位以下的日内，其他的最好买正股（杠杆 ETF 也能接受），因为期权的风险实在是太大了。前几天的 put 期权在这两天的上涨中基本上腰斩了，但是好在还有很长时间，希望后面能够砸盘下来让我跑路。\n另外，突然发现做空美股还不如做多黄金，毕竟这两一般情况下是负相关，而且目前黄金还是处在一个上升通道里面，如果美债问题没有起色的话，黄金应该短期内不会崩盘。所以今天大跌后又加仓了 10 股 UGL（两倍做多黄金 ETF），而且买了一张 6 月 30 号到期 320 价格 GLD 的 call（花费 600 多刀），如果后面再跌的话可以考虑加仓，毕竟仓位不大。\n 20250424（周四）\n今天从开盘到结尾都是猛涨，空头没有一点机会，而且还突破了重要点位，看来之后可能得向上突破了，甚至可能回到 3 月底的水平。最后平仓了 7 月和 8 月的看跌期权，准备缓缓，还是别碰长期期权了，顶多小仓位玩玩日内的，不然长期期权方向错了硬扛真是太难受了，不太适合我。另外，还加仓了 2 成仓位的黄金，包括 GLD 和 GDXU，把看涨期权出了，实在是不敢拿，怕了。\n 20250501（周四）\n最近真的有点没什么信心了，买啥亏啥，前天 4 月 30 号买了 sqqq，又亏了几百，今天受不了割了，美股还是不能空，如果空也不能加杠杆。还是不要操作了，这几个月，休息一下干点别的。\n 20250505（周一）\n今天决定用小资金买正股做日内交易，毕竟一上杠杆感觉我的判断就会出错，果然，不上杠杆就会好很多，不管是心态上还是判断上，而且就算硬抗也不会很难受。选择的是对标 BTC 的 MSTR，看 BTC 的 1h 线个人感觉是有一个双底的，然后刚好又有要突破的意思，就直接进场了，最后盘尾清仓跑路，不想过夜，毕竟日内就要有日内的规矩，能赚就行，真正的中长线感觉还是得找更好的入场时机。\n\n","categories":["日记"],"tags":["股票"]},{"title":"秋招吐槽","url":"/2024/08/01/%E7%A7%8B%E6%8B%9B%E5%90%90%E6%A7%BD/","content":" 20240801\n转眼八月了，现在是凌晨 3 点多，突然想起来好久没记点什么了。\n因为改简历越改越难蚌，不如来写点东西分散下注意力。\n其实差不多这个时候就得开始准备秋招了，不管是国内还是在美国。美国这边要相对来说早一点，基本上现在就可以开始投明年的 fulltime 了，国内大部分可能要到 9 月份。现在的状况是，leetcode 没刷多少，八股也还没怎么背，毕竟今天背明天忘，完全不进脑子，无论是国内还是国外，感觉都让人寸步难行。现在越来越后悔出来留学，真不如当初把出国的钱理财，然后找个国企躺平，感觉会远远胜过回国卷大厂卷加班什么的。真要算起来，如果说存在能进国内大厂用时间和生命换钱的可能性，除去在大城市必要的开，销粗略算下来一年最多也就能攒 10 来 w，还不考虑运气不好被裁的情况。如此一来，感觉至少得七、年才能回留学的本，计算机这行业能不能干七、八年都是个问题，更别说其他身体和精神因素了。\n现在越来越觉得，学历这个东西，既是最有用的，也是最没用的，关键看场合。要说它有用吧，也只有在国内校招或者国企什么的，可能用处比较大，会有相对优势存在；而一旦参加工作成为社畜之后，学历的作用就会像失去信用的货币一样，成为一张废纸，因为大多数都会更在意工作经验。尽管不能否认可能某些情况下它会有一定的作用，比如老生常谈的落户问题，或是相亲时候作为门当户对的一纸凭证，但在当今这个社会环境下，这些其实都不是最必要的因素。一是因为落户虽然有一系列国家对于高学历人才的扶持政策，但并不是说其他人就没有机会，只是高学历人才优先而已。其次，真正的落户，其目的之一是为了在一线城市长期的社保福利以及住房优惠，然而，这其实与大多数普通人不可能在一线买房的现实所相悖。特别是计算机专业，大部分进入大厂的思路都是干几年攒钱，然后退回二线城市养老或者快到年龄限制的时候直接考公回老家，毕竟能一直在大厂里干下去的是少数。还有一种思路就是直接国企稳定躺平，如果我没有来米国，我很大可能会考虑，因为这比起私企来说相对稳定。当然，如果回国之后仍然冲着这条路，不得不说会给人一种落差感，毕竟，可能凭着本科的学历，就完全足够找到适合的国企，而且不用花费巨额特地去留学，这就显得留学其实像是一笔完全不合理的投资，甚至是消费。\n有人说，你出去留学，换来了高学历，知识，人脉，各种资源，其实只有当事人自己心里才知道，所谓的光环，有时候只是不愿意脱下那层遮羞布罢了。面对国内经济开始步入滑坡的阶段，当我们这代人可能一辈子也无法超越甚至是达到父辈所积累的财富或取得的成就时，这不禁让人沉思，我们会不会也会是像日本上个世纪 90 年代一样作为失去的一代呢。当然，这个问题只能交给 30 年后的我们了。\n说完国内，再来看看米国。其实当初出国申请是在米国和港新当中纠结的，考虑到性价比的问题，港新无疑是划算的。然而最后还是选择了米国，最主要的缘由不过于出来赌一赌。毕竟不试一试怎么知道不行呢。来米国，大多数都是寄希望于找到工作，特别是码农的工作，这样才是回本甚至是通往财富自由的一条可行之路，毕竟这已经被大多数先辈们复刻很多次了。直到 2022 年年底的大裁员，有人说是 21 年疫情期间美联储开闸放水太狠，导致各大科技公司扩张过度。真正的原因我相信肯定不止一个，这也是为什么现在米国这边这么难留。供过于求，就是如此简单的道理。\n其实，我在一年前，就有着先工作观望局势的想法，奈何当时已经太晚，基本上完成了对外研的申请，再加上家里的施压，不得不做出硬着头皮冲的决定。现在看来，也许根据当时的想法走会有不一样的结果吧。\n不能否认，工资的确是个人积累财富的最好方式，但不乏会存在其他的机遇和可能性，如果被高工资和高工作时长所造成的低时薪蒙蔽，也许会忽视其他可能的机会。\n 20240910\n今天开始投国内的简历了，毕竟美国这边已经不能抱有多大的希望了，一百多份下去水花都看不到。\n不过这里不得不再次吐槽下某些国企的网站真的是一坨，填网申填的我绷不住了。上传简历直接解析，然后把下面锁定的内容清空了，我想改还改不了。有点过于抽象，填了半天结果又得重来。\n\n本来我以为美国这边投简历操作算麻烦的了，结果投了国内的国企才知道什么叫“抽象”。\n 20241122\n不得不提一下宁德时代这公司简直有毒，之前只投过第一个后端然后竟然发了个英语测评然后秒挂。\n\n结果后面我根本就没投，他倒好，一直自动给我投新的，还都是完全不匹配的那种，无力吐槽了都，我还撤回不了。\n\n","categories":["日记"],"tags":["吐槽","秋招"]},{"title":"笔记软件测评","url":"/2024/09/30/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%84/","content":" Obsidian\nobsidian 是基于本地储存的 markdown 类型的笔记软件。\n之前用 Obsidian 的时候，我就发现有这么几个问题\n\n同步困难\n不支持块结构\n图片大小无法编辑\n有时外链图片加载失败\n无 TOC\n\n不过好处在于 Obsidian 的插件众多，到是可以通过第三方插件Obsidian Git​ 扩展功能自动定时推送到 github 起到自动备份的作用，而且也有Floating TOC​ 可以用来展示 TOC 文章目录。下面是我常用的几个第三方插件\n\nEmoji Shortcodes\nFloating TOC\nMarkdown Prettifier\nMedia Extended\nMousewheel Image Zoom\nObsidian Git\nRemember Cursor Position\n\n后来我又解锁了新的用法，将 Gitbook 同步 Obsidian 的自动 git 备份库，就可以起到笔记 web 浏览的作用了，解决了本地笔记的痛点之一。\n‍\n 思源笔记\n我一直以为它是那种普通的富文本形式，结果试了才发现竟然也是基于块编辑器和 markdown 编辑器于一体的那种，再加上本地储存，数据安全和隐私有保障，算是完全撞上我的 xp 了。\n各种功能基本上齐全，而且本地储存和服务端储存相比最大的优势就是流畅不卡，不管你的文件有多大，基本上不会很卡，而之前体验过的 notion 和类 notion 的产品比如 wolai、FlowUS 等等文件一大都有卡顿的诟病，而且容量以及上传的图片大小都会有限制，最重要的是笔记的迁移问题，这些本地都不是问题。\n但是，本地笔记最大的问题就是同步，尽管说思源笔记官方给了付费版的同步方案，但是对于白嫖党这显然当然不能接受，好在办法总比困难多，很快我就找到了一个替代方案。\n思源笔记第三方网盘自动备份，单向同步内容到安卓手机的解决办法\n简单来说，就是通过 SiYuan 的导入导出功能来备份 Data\n​\n因为这个导出 Data 的功能相当于是给 data 文件夹打了个压缩包，于是我们可以直接用命令行自动定时打包，然后将压缩包放到网盘同步文件夹，比如 OneDrive 或者 GoogleDrive 等。思源笔记的文件夹是不支持直接放到网盘同步盘目录中的，如果直接同步会崩溃，所以不得不另辟蹊径。\n具体的 bat 代码如下，目录可自行修改，如果不想加上时间戳可删除相应部分。\n@ECHO OFFSETLOCALREM 获取系统时间，并处理小时数可能的空格问题SET \"h=%time:~0,2%\"SET \"N=%h: =0%\"REM 构造年月日和时分秒的字符串SET \"ymd=%date:~0,4%%date:~5,2%%date:~8,2%\"SET \"hms=%N%%time:~3,2%%time:~6,2%\"REM 组合日期和时间以创建时间戳SET \"dt=%ymd%%hms%\"REM 使用 Bandizip 压缩文件，并将时间戳添加到文件名中bz c \"D:\\data\\OneDrive - nyu.edu\\backup\\SiYuan\\SiYuanBackup-%dt%.zip\" \"D:\\data\\SiYuan\\data\\\"ECHO Backup completed successfully.\n然后通过 windows 的任务计划程序给这个 bat 文件添加一个定时任务，定期自动备份就可以了。\n‍\n Notion\nnotion 尽管可以说是业界标杆了，优点就不提了，因为实在是太多了，包括功能齐全、流畅度以及页面观感但对于我来说还是有很多可以改进的地方\n\n缺少 TOC\n导入 md 文件后，代码块不会换行和格式化\n页面的样式设定无法保存应用到全部页面，以至于每个不同的页面都需要重新设定\n虽然说可以嵌入云盘中的媒体，但对于音频和视频进度条无法拖动\n\n‍\n‍\n 钉钉个人版\n可以嵌入阿里云盘\n‍\n","categories":["笔记"],"tags":["Obsidian"]},{"title":"八字基础总结","url":"/2025/05/04/%E5%85%AB%E5%AD%97%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","content":" 基础知识\n\n","categories":["命理"],"tags":["八字"]},{"title":"绝区零开服体验","url":"/2024/07/03/%E7%BB%9D%E5%8C%BA%E9%9B%B6%E5%BC%80%E6%9C%8D%E4%BD%93%E9%AA%8C/","content":"今天绝区零开服去体验了一下。我个人感觉总体来说中规中矩，甚至对我来说还有些晕 3d。之前原神也是，玩到后面感觉对玩家的要求太肝了，20 天一个小版本倒还好，就是动不动有新图，然后凭借所谓的重复机械劳动，换取原石，跟现实又有什么不同呢？绝区零也继承了米家原神和崩铁的种种套路，也是那种二次元抽卡的养成游戏。这种类型游戏玩到后期就会给人一种天天给游戏打工的感觉，包括且不限于每日任务，清体力，以及攒资源抽新角色然后养角色的死循环中，以至于最后陷入游戏玩“我”，而不是“我”玩游戏的怪圈。自从上周 torncity 因为所谓的多号被封了半个月之后，我就意识到，这一切都是徒劳。所以说还是应该把重心放到看书和刷题学习的自我提升上来，即脱离游戏对现实的种种约束，以旁观者的角度去看待，尽量减少扮演参与者的角色，采取高性价比的游戏方式，让自己在现实生活中忙起来，达到转虚向实的目的。\n","categories":["日记"],"tags":["游戏","绝区零","米哈游"]},{"title":"Deep into Operating System","url":"/2024/04/25/Deep%20into%20Operating%20System/","content":" 第一章\n\n第一章的主要内容是 : 操作系统的一些知识\n\n 操作系统是什么？\n用户角度：操作系统是一个控制软件\n\n\n\n\n管理应用程序\n为应用程序提供服务\n杀死应用程序\n\n程序角度：操作系统是资源管理器\n\n\n管理外设、分配资源\n\n\n抽象\n\n将 CPU 抽象成进程\n将磁盘抽象成文件\n将内存抽象成地址空间\n\n\n\n 操作系统层次\n位于硬件之上，应用程序之下。\n 操作系统的界面和内核\nLinux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于 Shell 之下。\n 操作系统内部组件\n\nCPU 调度器\n物理内存管理\n虚拟内存管理\n文件系统管理\n中断处理与设备驱动\n\n 操作系统特征\n\n\n并发\n\n一段时间内运行多个进程（并行 : 一个时间点运行多个进程，一般要求有多个 CPU)\n需要 OS 管理和调度\n\n\n\n共享\n\n“同时”共享\n互斥共享\n\n\n\n虚拟\n\n让每一个用户觉得的有一个计算机专门为他服务\n\n\n\n异步\n\n程序是走走停停，而不是一直运行\n\n\n\n 第二章\n\n第二章的主要内容是 : 操作系统的异常/中断/系统调用\n\n 探究计算机启动过程\n作用解析\nDisk : 存放 OS 和 Bootloader\nBOIS : 基于 I/O 处理系统\nBootloader : 加载 OS，将 OS 放入内存\n结构\nDisk\n|___ OS\n|___ Bootloader\n开机流程\n\n\nBIOS\n\n开机后，寻找显卡和执行 BIOS (此时, CS : IP = 0xF000 : 0xFFF0, CS/IP 两个寄存器)\n将 Bootloader 从磁盘的引导扇区加载到 0x7C00 (Bootloader 一共占用 512M 字节的内存)\n跳转到 CS : IP = 0x0000 : 0x7C00\n\n\n\nBootloader\n\n将操作系统的代码和数据从硬盘加载到内存中\n跳转到操作系统的起始地址\n\n\n\n 中断、异常、系统调用\n 中断\n中断来源于外设，来自不同的硬件设备的计时器和网络的中断。\n中断流程\n硬件：设置中断标记（CPU 初始化）\n\n将内部、外部事件设置中断标记\n中断事件的 ID\n\n软件\n\n保存当前处理状态（寄存器之类的一些数据）\n根据中断事件的 ID 跳转到中断服务程序，中断服务程序处理\n清楚中断标记\n\n 异常\n异常来源于不良的应用程序，非法指令或者其他坏的处理状态（如：内存出错）。\n异常处理流程\n\n\n保存现场\n\n\n异常处理\n\n杀死了产生异常的程序\n重新执行异常指令\n\n\n\n恢复现场\n\n\n 系统调用\n系统调用来源于应用程序，应用程序主动向操作系统发出服务请求。程序访问主要是通过高层次的 API，而不是直接调用系统调用函数。\nAPIs\n\nWin32 API 用于 Windows\nPOSIX API 用于 POSIX-based systems（包括 UNIX，LINUX，Mac OS X）\nJava API 用于 JAVA 虚拟机\n\n特点\n\n\n通常情况下，每个系统调用有对应的序号\n\n系统调用接口根据这些序号来维护表的索引\n\n\n\n系统调用接口调用内核态中预期的系统调用\n\n并返回系统调用的状态和其他任何返回值\n\n\n\n用户不需要知道系统调用是如何实现的\n\n只需要获取 API 和了解操作系统将什么作为返回结果\n操作系统接口的细节大部分都隐藏在 API 中\n\n\n\n用户态：操作系统运行中，CPU 处于的特权级别，不能直接执行特权指令\n内核态：操作系统运行中，CPU 处于的特权级别，可以执行任何一条指令\n系统调用：触发 CPU 从用户态到内核态的转换，切换程序和内核的堆栈，需要一定的开销\n跨越操作系统边界的开销（值得的且必须的，保证了操作系统的安全性）\n\n\n在执行时间上的开销超过程序调用\n\n\n开销：\n\n建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销\n建立内核堆栈\n验证参数\n内核态映射到用户态的地址空间（更新页面映射权限）\n内核态独立地址空间（TLB）\n\n\n\n 区别\n\n\n\n类型\n源头\n处理时间\n响应\n\n\n\n\n中断\n外设\n异步\n持续，对应用程序透明\n\n\n异常\n应用程序意向不到的行为\n同步\n杀死或重新执行指令\n\n\n系统调用\n应用程序请求系统提供服务\n同步或异步\n等待和持续\n\n\n\n\n异步：应用程序不知道什么时候会发生中断\n\n\n同步：执行到某一条指令一定会发生该事件\n\n 为什么应用程序不能直接访问硬件？\n\n在计算机运行时，内核是被信任的第三方\n只有内核可以执行特权指令\n为了方便应用程序\n\n 第三章\n\n第三章的主要内容是 : 操作系统的物理内存管理\n\n 计算机体系结构\n\nCPU\n内存\nI/O\n\n 内存分层体系\n 内存分层体系\n运行内存(主存) / 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.\nCPU 可以访问的内存包括两大类 : 寄存器 / cache(L1 缓存 / L2 缓存)\n层次\n微处理器(CPU 访问)\n|___CPU 寄存器 / L1 缓存\n|___L2 缓存\n主存(程序访问)\n磁盘(程序访问)\n\n从 CPU 寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。\n\n 内存管理目标\n\n抽象：逻辑地址空间\n保护：独立地址空间\n共享：访问相同内存\n虚拟：更多的地址空间\n\n 内存管理方法\n\n程序重定位\n分段\n分页\n虚拟内存\n按需分页虚拟内存\n\n\n实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理 CPU 的内存访问请求\n\n 地址空间\n地址空间的定义\n\n物理地址空间 —— 硬件支持的地址空间( address : [0, Max_sys] )\n逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] )\n\n 连续内存分配\n 内存碎片问题\n内存碎片问题指的是空闲的内存无法被利用\n\n外部碎片 : 分配单元间的未使用内存\n内部碎片 : 分配单元内的未使用内存\n\n 分区的动态分配\n分区的动态分配方式有以下三种 :\n\n第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序\n最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序\n最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序\n\n分配方式的区别\n\n\n\n分配方式\n第一匹配分配\n最优适配分配\n最差适配分配\n\n\n\n\n分配方式实现需求\n1. 按地址排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配需要寻找一个合适的分区3. 重分配需要检查是否可以合并相邻空闲分区\n1. 按尺寸排序的空闲块列表2. 分配最大的分区3. 重分配需要检查是否可以合并相邻空闲分区\n\n\n优势\n简单 / 易于产生更大空闲块\n比较简单 / 大部分分配是小尺寸时高效\n分配很快 / 大部分分配是中尺寸时高效\n\n\n劣势\n产生外部碎片 / 不确定性\n产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片\n产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配\n\n\n\n\n三种分配方式并无优劣之分，因为我们无法判断内存请求的大小\n\n 碎片整理方法\n可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。\n\n\n压缩式碎片整理\n\n\n重置程序以合并碎片\n\n\n要求所有程序是动态可重置的\n\n\n问题 :\n\n何时重置 ? (在程序处于等待状态时才可以重置)\n需要考虑内存拷贝的开销\n\n\n\n\n\n交换式碎片整理\n\n\n运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存\n\n\n问题 :\n\n哪些程序应该被回收 ?\n\n\n\n情况 :\n运行中 : P3\n等待中 : P1 P2 P4\n内存分布 -&gt; 主存 : OS / P1 / P3 / P2 / P4 磁盘 : 空\n当 P3 程序需要更大的内存时 -&gt;\n内存分布 -&gt; 主存 : OS / P1 / P3 / P2 磁盘 : P4\n\n\n\n\n 第四章\n\n第四章的主要内容是：操作系统的非连续内存分配\n\n第三章介绍的是连续内存管理, 即 : 操作系统加载到内存以及程序加载到内存中时, 分配一块连续的空闲(内存)块. 但是容易出现碎片问题, 这一章介绍的非连续内存分配可以有效的减少碎片的出现.\n 非连续内存分配的必要性\n 连续内存分配的缺点\n\n分配给一个程序的物理内存是连续的\n内存利用率低\n有外碎片 / 内碎片的问题\n\n 非连续内存分配的优点\n\n一个程序的物理地址空间是非连续的\n更好的内存利用和管理\n允许共享代码与数据(共享库等…)\n支持动态加载和动态链接\n\n 非连续内存分配的缺点\n\n\n建立虚拟地址和物理地址的转换难度大\n\n软件方案\n硬件方案(采用硬件方案) : 分段 / 分页\n\n\n\n 非连续内存分配\n 分段(Segmentation)\n段 : 在程序中会有来自不同文件的函数 ; 在程序执行时, 不同的数据也有不同的字段, 比如 : 堆 / 栈 / .bss / .data 等\n**分段 : ** 更好的分离和共享\n程序的分段地址空间如下图所示 :\n\n\n\n分段寻址方案\n逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联.\n一个段 : 一个内存&quot;块&quot;\n程序访问内存地址需要 : 一个二维的二元组(s, addr) → (段号, 地址)\n操作系统维护一张段表, 存储(段号, 物理地址中的起始地址, 长度限制)\n物理地址 : 段表中的起始地址 + 二元组中的偏移地址\n 分页(Paging)\n 分页地址空间\n划分物理内存至固定大小的帧(Frame)\n\n大小是 2 的幂, 512 / 4096 / 8192\n\n划分逻辑地址空间至相同大小的页(Page)\n\n大小是 2 的幂, 512 / 4096 / 8192\n\n建立方案 → 转换逻辑地址为物理地址(pages to frames)\n\n页表\nMMU / TLB\n\n帧(Frame)\n物理内存被分割为大小相等的帧. 一个内存物理地址是一个二元组(f, o) → (帧号, 帧内偏移)\n帧号 : F 位, 共有 2^F 个帧\n帧内偏移 : S 位, 每帧有 2^S 个字节\n物理地址 = 2^S * f + o\n(例子 : 16-bit 地址空间, 9-bit(512 byte) 大小的页帧 物理地址 = (3,6) 物理地址 = 2^9 * 3 + 6 = 1542)\n\n分页和分段的最大区别 : 这里的 S 是一个固定的数, 而分段中的长度限制不定\n\n页(Page)\n一个程序的逻辑地址空间被划分为大小相等的页. 页内偏移的大小 = 帧内偏移的大小 页号大小 &lt;&gt; 帧号大小\n一个逻辑地址是一个二元组(p, o) → (页号, 页内偏移)\n页号 : P 位, 共有 2^P 个页\n页内偏移 : S 位, 每页有 2^S 个字节\n虚拟地址 = 2^S * p + o\n 页寻址方案\n操作系统维护一张页表, 页表保存了逻辑地址——物理地址之间的映射关系\n存储 : (页号, 帧号)\n\n逻辑地址空间应当大于物理内存空间\n页映射到帧\n页是连续的虚拟内存\n帧是非连续的物理内存(有助于减少碎片的产生)\n不是所有的页都有对应的帧\n\n 页表(Page Table)\n 页表概述\n每一个运行的程序都有一个页表\n\n属于程序运行状态, 会动态变化\nPTBR : 页表基址寄存器\n\n转换流程\nCPU 根据程序的 page 的页号的若干位, 计算出索引值 index, 在页表中搜索这个 index, 得到的是帧号, 帧号和原本的 offset 组成物理地址.\n页表中还有一些特殊标志位\n\ndirty bit,\nresident bit, (0 : 对应的物理页帧在内存中不存在 ; 1 : 存在)\nclock / reference bit\n\n转换实例\n16 位地址的系统\n\n32KB 的物理内存\n每页的 1024 byte\n\n逻辑地址空间 : (4, 0) … (3, 1023)\n页表 :\nFlags | Frame nums\n1 0 1 0 0 0 0 0 → 内存访问异常(可能要杀死程序)\n0 1 1 0 0 1 0 0 → 页帧是 4 偏移是 1023 → 物理地址 (4, 1023)\n 分页机制的性能问题\n访问一个内存单元需要 2 次内存访问\n\n一次用于获取页表项\n一次用于访问数据\n\n页表可能非常大\n\n64 位机器如果每页 1024 字节, 那么一个页表的大小会是多少？(264 / 210 = 2^54 存放不下)\n每一个运行的程序都需要有一个页表\n\n如何处理？\n\n缓存(Caching)\n间接(Indirection)访问\n\n 转换后备缓冲区(TLB)\n缓解时间问题\nTranslation Look-aside Buffer(TLB) 是一个缓冲区. CPU 中有快表 TLB(可以将经常访问的页表存放在这边)\n缓存近期访问的页帧转换表项\n\nTLB 使用关联内存实现, 具备快速访问性能\n如果 TLB 命中, 物理页号可以很快被获取\n如果 TLB 未命中, 对应的表项被更新到 TLB 中(x86 的 CPU 由硬件实现, 其他的可能是由操作系统实现)\n\n 二级/多级页表\n时间换空间\n二级页表\n\n将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.\n一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号\n节约了一定的空间, 在一级页表中如果 resident bit = 0, 可以使得在二级页表中不存储相关 index,而只有一张页表的话, 这一些 index 都需要保留\n\n多级页表\n\n通过把页号分为 k 个部分, 来实现多级间接页表, 建立一棵页表&quot;树&quot;\n\n 反向页表\n解决大地址空间问题\n目的 : 根据帧号获得页号\n反向页表只需要存在一张即可\n\n有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了 5 级页表\n不是让页表与逻辑地址空间的大小相对应, 而是当页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间\n\n 基于页寄存器(Page Registers)的方案\n存储 (帧号, 页号) 使得表大小与物理内存大小相关, 而与逻辑内存关联减小.\n每一个帧和一个寄存器关联, 寄存器内容包括 :\n\nresident bit : 此帧是否被占用\noccupier : 对应的页号 p\nprotection bits : 保护位\n\n实例 :\n\n物理内存大小是 : 4096 _ 4096 = 4K _ 4KB = 16 MB\n页面大小是 : 4096 bytes = 4 KB\n页帧数 : 4096 = 4 K\n页寄存器使用的空间(假设 8 bytes / register) : 8 * 4096 = 32 Kbytes\n页寄存器带来的额外开销 : 32K / 16M = 0.2%\n虚拟内存大小 : 任意\n\n优势 :\n\n转换表的大小相对于物理内存来说很小\n转换表的大小跟逻辑地址空间的大小无关\n\n劣势 :\n\n需要的信息对调了, 即根据帧号可以找到页号\n如何转换回来? (如何根据页号找到帧号)\n在需要在反向页表中搜索想要的页号\n\n 基于关联内存(associative memory)的方案\n硬件设计复杂, 容量不大, 需要放置在 CPU 中\n\n\n如果帧数较少, 页寄存器可以被放置在关联内存中\n\n\n在关联内存中查找逻辑页号\n\n成功 : 帧号被提取\n失败 : 页错误异常 (page fault)\n\n\n\n限制因素:\n\n大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)\n\n\n\n 基于哈希(hash)的方案\n哈希函数 : h(PID, p) 从 PID 标号获得页号\n在反向页表中通过哈希算法来搜索一个页对应的帧号\n\n\n对页号做哈希计算, 为了在帧表中获取对应的帧号\n\n\n页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数\n\n\n为了查找页 i , 执行下列操作 :\n\n计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器\n检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败\n\n\n\n 第五章\n\n第五章的主要内容是：操作系统的虚拟内存管理技术\n\n 虚拟内存的起因\n使用硬盘/磁盘使更多的程序在有限的内存中运行\n理想的存储器 : 更大更快更便宜和非易失性的存储区\n 覆盖技术\n如果是程序太大, 超出了内存的容量, 可以采用手动的概率(overlay)技术, 只把需要的指令和数据保存在内存当中\n目的 : 是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用.\n原理 :\n把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行.\n\n必要部分(常用功能)的代码和数据常驻内存;\n可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存;\n不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区.\n\n\n也就是说,程序松耦合的部分可以按需装入内存,不需要的时候放在外存中,多个不常用部分共用一个分区.\n\n实例 :\nA(20k) **B(50k) __ D(30k)| __** C(30k) ____ E(20k)|**** F(40k)\n因此不需要将整个程序 190k 的数据全部放入内存中, 而是划分为 常驻区(20k) 覆盖区 0(50k) 覆盖区 1(40k) 压缩至了 110k 的内存空间使用\n缺点 :\n\n由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度;\n覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省.\n\n 交换技术\n如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中\n目的 : 多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源\n原理 :\n可将暂时不能运行的程序送到外存, 从而获得空闲内存空间. 操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间.\n存在问题 :\n\n交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出;\n交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取\n程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法\n\n 覆盖技术和交换技术的对比\n特点 :\n\n覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构.\n交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构.\n换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部.\n\n在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :\n\n覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担.\n交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销.\n\n 虚拟内存管理技术\n如果想要在有限容量的内存中, 以更小的页粒度为单位装入更多更大的程序, 可以采用自动的虚拟存储技术\n\n\n目标\n像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉.\n像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换.\n\n\n程序局部性原理\n程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域.\n\n时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内 ;\n空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内.\n\n程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果.\n实例 :\n题目描述 :页面大小为4k, 分配给每个进程的物理页面是1.在一个进程中, 定义了如下的二维数组 int A[1024][1024]. 该数组按行存放在内存, 每一行放在一个页面中.考虑一下程序的编写方法对缺页率的影响?程序编写方法1 : (发生了1024*1024次缺页中断)for(j = 0; j &lt; 1024; j++)\t\tfor(i = 0; i &lt; 1024; i++)\t\t\t\tA[i][j] = 0;程序编写方法2 : (发生了1024次缺页中断)for(i = 0; i &lt; 1024; i++)\t\tfor(j = 0; j &lt; 1024; j++)\t\t\t\tA[i][j] = 0;\n\n\n基本概念\n可以在页式或段式内存管理的基础上实现\n\n在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行;\n在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序;\n另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段.\n\n\n\n基本特征\n\n大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如 32 位的虚拟地址理论上可以访问 4GB, 而可能计算机上仅有 256M 的物理内存, 但硬盘容量大于 4GB.\n部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的;\n不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性.\n\n\n\n虚拟页式内存管理\n页式内存管理\n页表 : 完成逻辑页到物理页帧的映射\n根据页号去页表中寻找索引, 先查看 resident bit 是否为 0, 0 表示不存在, 1 表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址.\n虚拟页式内存管理\n\n\n大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能.\n\n\n基本思路\n\n当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.\n在运行的过程中, 如果发现要运行的程序或要访问的数据不再内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行.\n\n\n\n页表表项\n逻辑页号 | 访问位 | 修改位 | 保护位 | 驻留位 | 物理页帧号\n驻留位 : 表示该页是在内存中还是在外存.\n保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等\n修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存\n访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法.\n\n\n缺页中断处理过程 :\n\n如果在内存中有空闲的物理页面, 则分配一物理页帧 f, 然后转第 4 步; 否则转到第 2 步;\n采用某种页面置换算法, 选择一个将被替换的物理页帧 f, 它所对应的逻辑页为 q, 如果该页在内存期间被修改过, 则需要把它写回外存;\n对 q 所对应的页表项修改, 把驻留位置为 0;\n将需要访问的页 p 装入到物理页面 f 当中;\n修改 p 所对应的页表项的内容, 把驻留位置为 1, 把物理页帧号置为 f;\n重新运行被中断是指令.\n\n\n在何处保存未被映射的页?\n\n能够简单地识别在二级存储器中的页\n交换空间(磁盘或者文件) : 特殊格式, 用于存储未被映射的页面\n\n\n后备存储(二级存储) :\n\n一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)的某个位置\n代码段 : 映射到可执行二进制文件\n动态加载的共享库程序段 : 映射到动态调用的库文件\n其他段 : 可能被映射到交换文件(swap file)\n\n\n\n虚拟内存性能\n为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)\nEAT = 访存时间 _ 页表命中几率 + page fault 处理时间 _ page fault 几率\n实例 :\n访存时间 : 10 ns\n磁盘访问时间 : 5 ms\n参数 p = page fault 几率\n参数 q = dirty page 几率(对页面写操作)\nEAT = 10*(1-p) + 5000000*p*(1+q)\n\n\n\n\n 第六章\n\n第六章的主要内容是：操作系统的虚拟内存管理技术中的页面置换算法\n\n 功能与目标\n功能 : 当缺页中断发生, 需要调入新的页面而内存已满时, 选择内存当中哪个物理页面被置换.\n目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数). 具体来说, 把未来不再使用的或短期内较少使用的页面换出, 通常只能在局部性原理指导下依据过去的统计数据来进行预测.\n页面锁定 : 用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程. 实现的方式是 : 在页表中添加锁定标记位(lock bit).\n 实验设置与评价方法\n实例 :\n记录一个进程对页访问的一个轨迹\n\n\n举例 : 虚拟地址跟踪(页号, 偏移)…\n\n(3,0) (1,9) (4,1) (2,1) (5,3) (2,0) …\n\n\n\n生成的页面轨迹\n\n3, 1, 4, 2, 5, 2, 1, …\n\n\n\n模拟一个页面置换的行为并且记录产生页缺失数的数量\n\n更少的缺失, 更好的性能\n\n 局部页面置换算法\n 最优页面置换算法\n基本思路 : 当一个缺页中断发生时, 对于保存在内存当中的每一个逻辑页面, 计算在它的下一次访问之前, 还需等待多长时间, 从中选择等待时间最长的那个, 作为被置换的页面.\n这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.\n可用作其他算法的性能评价的依据.(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况, 在第二遍运行时即可使用最优算法)\n 先进先出算法\n基本思路 : 选择在内存中驻留时间最长的页面淘汰. 具体来说, 系统维护着一个链表, 记录了所有位于内存当中的逻辑页面. 从链表的排列顺序来看, 链首页面的驻留时间最长, 链尾页面的驻留时间最短. 当发生一个缺页中断时, 把链首页面淘汰出去, 并把新的页面添加到链表的末尾.\n性能较差, 调出的页面有可能是经常要访问的页面. 并且有 belady 现象. FIFO 算法很少单独使用.\n 最近最久未使用算法\nLRU(Least Recently Used)\n基本思路 : 当一个缺页中断发生时, 选择最久未使用的那个页面, 并淘汰.\n它是对最优页面置换算法的一个近似, 其依据是程序的局部性原理, 即在最近一小段时间(最近几条指令)内, 如果某些页面被频繁地访问, 那么再将来的一小段时间内, 他们还可能会再一次被频繁地访问. 反过来说, 如果过去某些页面长时间未被访问, 那么在将来它们还可能会长时间地得不到访问.\nLRU 算法需要记录各个页面使用时间的先后顺序, 开销比较大.\n两种可能的实现方法是 :\n\n系统维护一个页面链表, 最近刚刚使用过的页面作为首节点, 最久未使用的作为尾结点. 再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 每次缺页中断发生时, 淘汰链表末尾的页面.\n设置一个活动页面栈, 当访问某页时, 将此页号压入栈顶, 然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的.\n\n 时钟页面置换算法\n基本思路 :\n需要用到页表项的访问位, 当一个页面被装入内存时, 把该位初始化为 0. 然后如果这个页面被访问, 则把该位置设为 1;\n把各个页面组织成环形链表(类似钟表面), 把指针指向最老的页面(最先进来);\n当发生一个缺页中断时, 考察指针所指向的最老页面, 若它的访问位为 0, 立即淘汰; 若访问位为 0, 然后指针往下移动一格. 如此下去, 直到找到被淘汰的页面, 然后把指针移动到下一格.\n流程 :\n如果访问页在物理内存中, 访问位置 1.\n如果不在物理页, 从指针当前指向的物理页开始, 如果访问位 0, 替换当前页, 指针指向下一个物理页; 如果访问位为 1, 置零以后访问下一个物理页再进行判断. 如果所有物理页的访问位都被清零了, 又回到了第一次指针所指向的物理页进行替换.\n 二次机会算法\n因为考虑到时钟页面置换算法, 有时候会把一些 dirty bit 为 1(有过写操作)的页面进行置换, 这样的话, 代价会比较大. 因此, 可以结合访问位和脏位一起来决定应该置换哪一页.\nused dirty → used dirty\n0 0 replace\n0 1 0 0\n1 0 0 0\n1 1 0 1\n相当于说, 替换的优先级, 没有读写也没写过, 那么直接走, 如果写过或者访问过, 那么给你一次机会, 如果又写过, 又访问过, 那么久给你两次机会.\n 最不常用算法\nLeast Frequently used, LFU\n基本思路 : 当一个缺页中断发生时, 选择访问次数最少的那个页面, 并淘汰.\n实现方法 : 对每一个页面设置一个访问计数器, 每当一个页面被访问时, 该页面的访问计数器加 1. 当发生缺页中断时, 淘汰计数值最小的那个页面.\nLRU 和 LFU 的对比 : LRU 考察的是多久未访问, 时间越短越好. 而 LFU 考察的是访问的次数和频度, 访问次数越多越好.\n Belady 现象(科学家名字)\n在采用 FIFO 算法时, 有时会出现分配的物理页面数增加, 缺页率反而提高的异常现象;\n出现原因 : FIFO 算法的置换特征与进程访问内存的动态特征是矛盾的, 与置换算法的目标是不一致的(即替换较少使用的页面), 因此, 被他置换出去的页面不一定是进程不会访问的.\n LRU / FIFO 和 Clock 的比较\nLRU 和 FIFO 都是先进先出的思路, 只不过 LRU 是针对页面最近访问时间来进行排序, 所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了). 而 FIFO 是针对页面进入内存的时间来进行排序, 这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的. 如果一个页面在进入内存后没有被访问, 那么它的最近访问时间就是它进入内存的时间. 换句话说, 如果内存当中的所有页面都未曾访问过, 那么 LRU 算法就退化为了 FIFO 算法.\n例如 : 给进程分配 3 个物理页面, 逻辑页面的访问顺序是 : 1,2,3,4,5,6,1,2,3 …\n 全局页面置换算法\n 工作集模型\n前面介绍的各种页面置换算法, 都是基于一个前提, 即程序的局部性原理. 但是此原理是否成立?\n\n如果局部性原理不成立, 那么各种页面置换算法就没有说明分别, 也没有什么意义. 例如 : 假设进程对逻辑页面的访问顺序是 1,2,3,4,5,6,6,7,8,9…, 即单调递增, 那么在物理页面数有限的前提下, 不管采用何种置换算法, 每次的页面访问都必然导致缺页中断.\n如果局部性原理是成立的, 那么如何来证明它的存在, 如何来对它进行定量地分析? 这就是工作集模型.\n\n 工作集\n工作集 : 一个进程当前正在使用的逻辑页面集合.\n可以使用一个二元函数 W(t, delta) 来表示 :\nt 是当前的执行时刻;\ndelta 称为工作集窗口, 即一个定长的页面访问的时间窗口;\nW(t, delta) = 在当前时刻 t 之前的 delta 时间窗口当中的所有页面所组成的集合(随着 t 的变化, 该集合也在不断的变化)\n|W(t, delta)| 是工作集的大小, 即逻辑页的数量.\n工作集大小的变化 : 进程开始执行后, 随着访问新页面逐步建立较稳定的工作集. 当内存访问的局部性区域的位置大致稳定时, 工作集大小也大致稳定; 局部性区域的位置改变时, 工作集快速扩张和收缩过渡到下一个稳定值.\n 常驻集\n常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合.\n\n工作集是进程在运行过程中固有的性质, 而常驻集取决于系统分配给进程的物理页面数目, 以及所采用的页面置换算法;\n如果一个进程的整个工作集都在内存当中, 即常驻集 包含 工作集, 那么进程将很顺利地运行, 而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态);\n当进程常驻集的大小达到某个数目之后, 再给它分配更多的物理页面, 缺页率也不会明显下降.\n\n 工作集页置换算法\n当工作集窗口在滑动过程中, 如果页面不在集合中, 那么就会直接丢失这个不在窗口中页面, 而不会等待缺页中断再丢弃.\n 缺页率置换算法\n可变分配策略 : 常驻集大小可变. 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小.\n\n可采用全局页面置换的方式, 当发生一个缺页中断时, 被置换的页面可以是在其他进程当中, 各个并发进程竞争地使用物理页面.\n优缺点 : 性能较好, 但增加了系统开销.\n具体实现 : 可以使用缺页率算法来动态调整常驻集的大小.\n\n缺页率 : 表示 “缺页次数 / 内存访问次数”\n影响因素 : 页面置换算法, 分配给进程的物理页面数目, 页面本身的大小, 程序的编写方法.\n 抖动问题\n\n如果分配给一个进程的物理页面太少, 不能包含整个的工作集, 即常驻集 属于 工作集, 那么进程将会造成很多的缺页中断, 需要频繁的在内存与外存之间替换页面, 从而使进程的运行速度变得很慢, 我们把这种状态称为 “抖动”.\n产生抖动的原因 : 随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以 OS 要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡.\n\n 第七章\n\n第七章的主要内容是：进程\n\n 进程(process)描述\n 进程定义\n进程 : 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程.\n 进程的组成\n进程包括 :\n\n程序的代码\n程序处理的数据\n程序计数器中的值, 指示下一条将运行的指令\n一组通用的寄存器的当前值, 堆, 栈\n一组系统资源(如打开的文件)\n\n进程和程序的联系 :\n\n程序是产生进程的基础\n程序的每次运行构成不同的进程\n进程是程序功能的体现\n通过多次执行, 一个程序可以对应多个进程, 通过调用关系, 一个进程可包括多个程序.\n\n进程和程序的区别 :\n\n进程是动态的, 程序是静态的 : 程序是有序代码的集合. 进程是程序的执行, 进程有核心态 / 用户态.\n进程是暂时的, 程序是永久的. 进程是一个状态变化的过程, 程序可以长久保存.\n进程和程序的组成不同 : 进程的组成包括程序, 数据和进程控制块(进程状态信息)\n\n 进程的特点\n动态性 : 可动态地创建, 结果进程;\n并发性 : 进程可以被独立调度并占用处理机运行; (并发:一段, 并行:一时刻)\n独立性 : 不同进程的工作不相互影响;(页表是保障措施之一)\n制约性 : 因访问共享数据, 资源或进程间同步而产生制约.\n\n抛出了一个问题 : 如果你要设计一个 OS, 怎么样来实现其中的进程管理机制?\n\n 进程控制结构\n描述进程的数据结构 : 进程控制块 (Process Control Block)\n操作系统为每个进程都维护了一个 PCB, 用来保存与该进程有关的各种状态信息.\n进程控制块 : 操作系统管理控制进程运行所用的信息集合.\n进程的创建 : 为该进程生成一个 PCB\n进程的终止 : 回收它的 PCB\n进程的组织管理 : 通过对 PCB 的组织管理来实现\n(PCB 具体包含什么信息? 如何组织的? 进程的状态转换?)\nPCB 有以下三大类信息 :\n\n\n进程标志信息. 如本进程的标志, 本进程的产生者标志(父进程标志). 用户标志\n\n\n处理机状态信息保存区 : 保存进程的运行现场信息 :\n\n用户可见寄存器. 用户程序可以使用的数据, 地址等寄存器\n控制和状态寄存器. 如程序计数器(PC), 程序状态字(PSW)\n栈指针. 过程调用, 系统调用, 中断处理和返回时需要用到它\n\n\n\n进程控制信息\n\n调度和状态信息. 用于操作系统调度进程并占用处理机使用.\n进程间通信信息. 为支持进程间与通信相关的各种标志, 信号, 信件等, 这些信息都存在接收方的进程控制块中.\n存储管理信息. 包含有指向本进程映像存储空间的数据结构.\n进程所用资源. 说明由进程打开, 使用的系统资源. 如打开的文件等.\n有关数据结构的链接信息. 进程可以连接到一个进程队列中, 或连接到相关的其他进程的 PCB.\n\n\n\n进程的组织方式\n链表 : 同一状态的进程其 PCB 成一链表, 多个状态对应多个不同的链表.(各状态的进程形成不同的链表 : 就绪链表, 阻塞链表)\n索引表 : 同一状态的进程归入一个 index 表(由 index 指向 PCB), 多个状态对应多个不同的 index 表(各状态的进行形成不同的索引表 : 就绪索引表, 阻塞索引表)\n 进程状态(state)\n 进程的生命期管理\n 进程创建\n引起进程创建的 3 个主要事件 :\n\n系统初始化;\n用户请求创建一个新进程;\n正在运行的进程执行了创建进程的系统调用.\n\n 进程运行\n内核选择一个就绪的进程, 让它占用处理机并执行\n(为何选择?如何选择?)\n 进程等待(阻塞)\n在以下情况下, 进程等待(阻塞):\n\n请求并等待系统服务, 无法马上完成\n启动某种操作, 无法马上完成\n需要的数据没有到达\n\n进程只能自己阻塞自己, 因为只有进程自身才能知道何时需要等待某种事件的发生.\n 进程唤醒\n唤醒进程的原因 :\n\n被阻塞进程需要的资源可被满足\n被阻塞进程等待的事件到达\n将该进程的 PCB 插入到就绪队列\n\n进程只能被别的进程或操作系统唤醒\n 进程结束\n在以下四种情况下, 进程结束 :\n\n正常退出(自愿)\n错误退出(自愿)\n致命错误(强制性)\n被其他进程杀死(强制性)\n\n 进程状态变化模型\n进程的三种基本状态 : 进程在生命结束前处于三种基本状态之一.\n不同系统设置的进程状态数目不同.\n三种基本状态\n\n运行状态(Running) : 当一个进程正在处理机上运行时\n就绪状态(Ready) : 一个进程获得了除处理机之外的一切所需资源, 一旦得到处理机即可运行\n等待状态(阻塞状态 Blocked) : 一个进程正在等待某一时间而暂停运行时. 如等待某资源, 等待输入/输出完成.\n\n进程其它的基本状态\n创建状态(New) : 一个进程正在被创建, 还没被转到就绪状态之前的状态\n结束状态(Exit): 一个进程正在从系统中消失时的状态, 这是因为进程结束或由于其它原因所导致.\n可能的状态变化如下 :\nNULL → New : 一个新进程被产生出来执行一个程序\nNew → Ready: 当进程创建完成并初始化后, 一切就绪准备运行时, 变为就绪状态\nReady → Running : 处于就绪态的进程被进程调度程序选中后, 就分配到处理机上来运行\nRunning → Exit : 当进程表示它已经完成或者因出错, 当前运行进程会由操作系统作结束处理\nRunning → Ready : 处于运行状态的进程在其运行过程中, 由于分配它的处理机时间片用完而让出处理机\nRunning → Blocked: 当进程请求某样东西且必须等待时\nBlocked → Ready : 当进程要等待某事件到来时, 它从阻塞状态变到就绪状态\n 进程挂起\n进程挂起, 为了合理且充分地利用系统资源.\n进程在挂起状态时, 意味着进程没有占用内存空间, 处在挂起状态的进程映像在磁盘上.(把进程放到磁盘上)\n两种挂起状态\n\n阻塞挂起状态 : 进程在外存并等待某事件的出现;\n就绪挂起状态 : 进程在外存, 但只要进入内存, 即可运行.\n\n与挂起相关的状态转换\n挂起 : 把一个进程从内存转到外存, 可能有以下几种情况 :\n\n阻塞到阻塞挂起 : 没有进程处于就绪状态或就绪进程要求更多内存资源时, 会进行这种转换, 以提交新进程或运行时就绪进程.\n就绪到就绪挂起 : 当有高优先级阻塞(系统认为会很快就绪的)进程和低优先级就绪进程时, 系统会选择挂起低优先级就绪进程.\n运行到就绪挂起 : 对抢先式分时系统, 当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时, 系统可能会把运行进程转导就绪挂起状态.\n\n在外存时的状态转换 :\n\n阻塞挂起到就绪挂起 : 当有阻塞挂起因相关事件出现时, 系统会把阻塞挂起进程转换为就绪挂起进程.\n\n解挂, 激活 : 把一个进程从外存转到内存; 可能有以下几种情况 :\n\n就绪挂起到就绪 : 没有就绪进程或挂起就绪进程优先级高于就绪进程时, 会进行这种转换.\n阻塞挂起到阻塞 : 当一个进程释放足够内存时, 系统会把一个高优先级阻塞挂起(系统认为会很快出现所等待的事件)进程转换为阻塞进程.\n\n\n抛出一个问题 : OS 怎么通过 PCB 和定义的进程状态来管理 PCB, 帮助完成进程的调度过程?\n\n 状态队列\n\n由操作系统来维护一组队列, 用来表示系统当中所有进程的当前状态;\n不同的状态分别用不同的队列来表示(就绪队列, 各种类型的阻塞队列);\n每个进程的 PCB 都根据它的状态加入到相应的队列当中, 当一个进程的状态发生变化时, 它的 PCB 从一个状态中脱离出来, 加入到另外一个队列.\n\n 线程(thread)\n 为什么使用线程?\n实例 : 编写一个 MP3 播放软件.\n核心功能 : (1)从 MP3 音频文件中读取数据; (2)对数据进行解压缩; (3)把解压缩后的音频数据播放出来.\n//单进程方式while(1)&#123;\tRead();\tDecompress();\tPlay();&#125;//问题: 播放出来的声音能否连贯? 各个函数之间不是并发执行, 影响资源的使用效率.\n//多进程//进程1while(1)&#123;\tRead();&#125;//进程2while(1)&#123;\tDecompress();&#125;//进程3while(1)&#123;\tPlay();&#125;//问题: 进程之间如何通信,共享数据?另外,维护进程的系统开销较大://创建进程时,分配资源,建立PCB;撤销进程时,回收资源,撤销PCB;进程切换时,保存当前进程的状态信息\n因此需要提出一种新的实体, 满足以下特征:\n\n实体之间可以并发执行;\n实体之间共享相同的地址空间.\n\n这实体就是线程.\n 什么是线程\n线程是进程当中的一条执行流程.\n从两个方面重新理解进程:\n\n从资源组合的角度: 进程把一组相关的资源组合起来,构成了一个资源平台(环境),包括地址空间(代码段,数据段),打开的文件等各种资源;\n从运行的角度: 代码在这个资源平台上的一条执行流程(线程).\n\n线程 = 进程 - 共享资源\n 线程的优缺点\n线程的优点:\n\n一个进程中可以同时存在多个线程;\n各个线程之间可以并发地执行;\n各个线程之间可以共享地址空间和文件等资源.\n\n线程的缺点:\n\n\n一个线程崩溃, 会导致其所属进程的所有线程崩溃.(给它了&quot;权限&quot;就得有更高的&quot;责任&quot;)\n\n\n线程所需的资源\n不同的线程需要独立的寄存器和堆栈, 共享代码,数据和文件等.\n\n\n 线程和进程的比较\n\n\n进程是资源分配单位, 线程是 CPU 调度单位;\n\n\n进程拥有一个完整的资源平台, 而线程只独享必不可少的资源, 如寄存器和栈;\n\n\n线程同样具有就绪,阻塞和执行三种基本状态,同样具有状态之间的转换关系;\n\n\n线程能减少并发执行的时间和空间开销:\n\n线程的创建时间比进程短;(直接利用所属进程的一些状态信息)\n线程的终止时间比进程短;(不需要考虑把这些状态信息给释放)\n同一进程内的线程切换时间比进程短;(同一进程不同线程的切换不需要切换页表)\n由于同一进程的各线程之间共享内存和文件资源, 可直接进行不通过内核的通信.(直接通过内存地址读写资源)\n\n\n\n 线程的实现\n主要有三种线程的实现方式:\n\n用户线程 : 在用户空间实现; POSIX Pthreads, Mach C-threads, Solaris threads\n内核线程 : 在内核中实现; Windows, Solaris, Linux\n轻量级进程: 在内核中实现,支持用户线程; Solaris\n\n用户线程\n操作系统只能看到进程, 看不到线程, 线程的 TCB 在线程库中实现;\n在用户空间实现的线程机制, 它不依赖于操作系统的内核, 由一组用户级的线程库来完成线程的管理, 包括进程的创建,终止,同步和调度等.\n\n由于用户线程的维护由相应的进程来完成(通过线程库函数),不需要操作系统内核了解用户进程的存在,可用于不支持线程技术的多进程操作系统;\n每个进程都需要它自己私有的线程控制块(TCB)列表,用来跟踪记录它的各个线程的状态信息(PC,栈指针,寄存器),TCB 由线程库函数来维护;\n用户线程的切换也是由线程库函数来完成,无需用户态/核心态切换,所以速度特别快;\n允许每个进程拥有自定义的线程调度算法.\n\n用户线程的缺点:\n\n阻塞性的系统调用如何实现?如果一个线程发起系统调用而阻塞,则整个进程在等待;\n当一个线程开始运行时,除非它主动地交出 CPU 的使用权,否则它所在的进程当中的其他线程将无法运行;\n由于时间片分配给进程,所以与其他进程比,在多线程执行时,每个线程得到的时间片较少,执行会较慢.\n\n内核线程\n操作系统能够看到进程也可能看到线程,线程在内核中实现;\n内核线程是在操作系统的内核当中实现的一种线程机制,由操作系统的内核来完成线程的创建,终止和管理.\n\n在支持内核线程的操作系统中,由内核来维护进程和线程的上下文信息(PCB 和 TCB);\n线程的创建,终止和切换都是通过系统调用,内核函数的方式来进行,由内核来完成,因此系统开销较大;\n在一个进程当中,如果某个内核线程发起系统调用而被阻塞,并不会影响其他内核线程的运行;\n时间片分配给线程,多线程的进程获得更多 CPU 时间;\nWindows NT 和 Windows 2000/XP 支持内核线程.\n\n轻量级进程\n它是内核支持的用户线程.一个进程可以有一个或多个轻量化进程,每个量级进程由一个单独的内核线程来支持.(Solaris,Linux)\n 上下文切换\n停止当前运行进程(从运行状态变成其他状态),并且调度其他进程(转变为运行状态)\n\n必须在切换之前存储许多部分的进程上下文\n必须能够在之后恢复他们,所以进程不能显示它曾经被暂停过\n必须快速(上下文切换时非常频繁)\n\n需要存储什么上下文?\n\n寄存器(PC,SP…),CPU 状态等信息\n一些时候可能会费时,所以我们应该尽可能避免\n\n操作系统为活跃进程准备了进程控制块\n操作系统将进程控制块放置在一个合适的队列中\n\n就绪队列\n等待 IO 队列(每个设备的队列)\n僵尸队列\n\n 进程控制\n 创建进程\nfork()的简单实现\n\n对子进程分配内存\n复制父进程的内存和 CPU 寄存器到子进程\n开销昂贵\n\n在 99%的情况下,我们在调用 fork()之后调用 exec()\n\n在 fork()操作中内存复制是没有作用的\n子进程将可能关闭打开的文件和连接\n开销因此是最高的\n为什么不能结合它们在一个调用中(OS/2, windows)?\n\nvfork()\n\n一个创建进程的系统调用,不需要创建一个同样的内存映像\n一些时候称为轻量级 fork()\n子进程应该几乎立即调用 exec()\n现在不再使用如果我们使用 copy on write 技术\n\n 加载和执行进程\n系统调用 exec()加载程序取代当前运行的进程\nexec()调用允许一个进程&quot;加载&quot;一个不同的程序并且在 main 开始执行(事实上 _start)\n它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv)\n如果调用成功(相同的进程,不同的程序)\n代码,stack,heap 重写\nint pid = fork(); //创建子进程if(pid == 0) &#123;    //子进程\texec_status = exec(\"calc\", argc, argv0,argv1,...);\tprintf(\"Why would I execute?\");&#125; else if(pid &gt; 0) &#123; //父进程\tprintf(\"Whose your daddy?\");\t...\tchild_status = wait(pid);&#125;\n 等待和终止进程\nwait()系统调用是被父进程用来等待子进程的结束\n\n\n一个子进程向父进程返回一个值,所以父进程必须接受这个值并处理\n\n\nwait()系统调用担任这个要求\n\n它使父进程去睡眠来等待子进程的结束\n当一个子进程调用 exit()的时候,操作系统解锁父进程,并且将通过 exit()传递得到的返回值作为 wait 调用的一个结果(连同子进程的 pid 一起)如果这里没有子进程存活,wait()立刻返回\n当然,如果这里有为父进程的僵尸等待,wait()立即返回其中一个值(并且解除僵尸状态)\n\n\n\n进程结束执行之后,它调用 exit()\n\n\n这个系统调用:\n\n\n将这程序的&quot;结果&quot;作为一个参数\n\n\n关闭所有打开的文件,连接等等\n\n\n释放内存\n\n\n释放大部分支持进程的操作系统结构\n\n\n检查是否父进程是存活着的:\n\n如果是的话,它保留结果的值直到父进程需要它;在这种情况里,进程没有真正死亡,但是它进入了僵尸状态\n如果没有,它释放所有的数据结构,这个进程死亡\n\n\n\n清理所有等待的僵尸进程\n\n\n\n\n进程终止是最终的垃圾收集(资源回收)\n\n\n 第八章\n\n第八章的主要内容是：调度算法(感觉清华这门课程前几章比较精彩,后续讲的有点混乱)\n\n 背景\n 上下文切换\n\n切换 CPU 的当前任务, 从一个进程/线程到另一个\n保存当前进程/线程在 PCB/TCB 中的执行上下文(CPU 状态)\n读取下一个进程/线程的上下文\n\n CPU 调度\n\n从就绪队列中挑选一个进程/线程作为 CPU 将要运行的下一个进程/线程\n调度程序: 挑选进程/线程的内核函数(通过一些调度策略)\n什么时候进行调度?\n\n 内核运行调度程序的条件(满足一条即可)\n\n一个进程从运行状态切换到等待状态\n一个进程被终结\n\n 不可抢占\n\n调度程序必须等待事件结束\n\n 可以抢占\n\n调度程序在中断被相应后执行\n当前的进程从运行切换到就绪, 或者一个进程从等待切换到就绪\n当前运行的进程可以被换出\n\n 调度原则\n\n\n调度策略\n人们通常都需要&quot;更快&quot;的服务\n什么是更快?\n\n传输文件时的高带宽\n玩游戏时的低延迟\n这两个因素是独立的\n\n和水管类比\n\n低延迟: 喝水的时候想要一打开水龙头水就流出来\n高带宽: 给游泳池充水时希望从水龙头里同时流出大量的水,并且不介意是否存在延迟\n\n我们的目标:\n\n减少响应时间: 及时处理用户的输出并且尽快将输出提供给用户\n减少平均响应时间的波动: 在交互系统中,可预测性比高差异性低平均更重要\n增加吞吐量: 减少开销(操作系统开销,上下文切换);系统资源的高效率用(CPU,IO 设备)\n减少等待时间: 减少每个进程的等待时间\n\n\n\n程序执行模型\n执行模型 : 程序在 CPU 突发和 IO 中交替\n\n每个调度决定都是关于在下一个 CPU 突发时将哪个工作交给 CPU\n在时间分片机制下,线程可能在结束当前 CPU 突发前被迫放弃 CPU\n\n\n\n评价指标\nCPU 使用率: CPU 处于忙状态所占时间的百分比\n吞吐量: 在单位时间内完成的进程数量\n周转时间: 一个进程从初始化到结束,包括所有等待时间所花费的时间\n等待时间: 进程在就绪队列中的总时间\n响应时间: 从一个请求被提交到产生第一次相应所花费的总时间\n各指标在操作系统上的表现:\n低延迟调度增加了交互式表现(如果移动了鼠标,但是屏幕中的光标却没动,我们可能会重启电脑)\n操作系统需要保证低吞吐量不受影响(我想要结束长时间的编程,所以操作系统必须不时进行调度,即使存在许多交互任务)\n吞吐量是操作系统的计算带宽\n响应时间是操作系统的计算延迟\n\n\n公平的目标\n举例:\n\n保证每个进程占用相同的 CPU 时间\n这公平嘛?如果一个用户比其他用户运行更多的进程怎么办\n\n举例:\n\n保证每个进程都等待相同的时间\n\n公平通常会增加平均响应时间\n\n\n 调度算法\n\n\nFCFS(先来先服务)\nFirst come, First Served\n如果进程在执行中阻塞,队列中的下一个会得到 CPU\n优点: 简单\n缺点:\n\n平均等待时间波动较大\n花费时间少的任务可能排在花费时间长的任务后面\n可能导致 IO 和 CPU 之间的重叠处理(CPU 密集型进程会导致 IO 设备闲置时,IO 密集型进程也在等待)\n\n\n\nSPN(SJF) SRT(短进程优先(短作业优先)短剩余时间优先)[最优平均等待时间]\nShortest Process Next(Shortest Job First) Shortest Remaining Time\n选择预测的完成时间来将任务入队\n可以是抢占的或者是不可抢占的\n可能导致饥饿\n\n连续的短任务流会使场任务饥饿\n短任务可用时的任何场任务的 CPU 时间都会增加平均等待时间\n\n需要预测未来\n\n怎么预估下一个 CPU 突发的持续时间\n简单的解决: 询问用户\n如果用户欺骗就杀死进程\n如果不知道怎么办?\n\n\n\nHRRN(最高响应比优先)\nHighest Response Ratio Next\n\n\nRound Robin(轮循)\n使用时间切片和抢占来轮流执行任务\n在叫做量子(或者时间切片)的离散单元中分配处理器\n时间片结束时,切换到下一个准备好的进程\n花销: 额外的上下文切换\n时间量子太大:\n\n等待时间过长\n极限情况退化成 FCFS\n\n时间量子太小:\n\n反应迅速\n吞吐量由于大量的上下文切换开销受到影响\n\n目标:\n\n选择一个合适的时间量子\n经验规则: 维持上下文切换开销处于 1%以内\n\n\n\nMultilevel Feedback Queues(多级反馈队列)\n优先级队列中的轮循\n就绪队列被划分成独立的队列: 比如前台(交互),后台(批处理)\n每个队列拥有自己的调度策略: 比如前台(RR),后台(FCFS)\n调度必须在队列间进行:\n\n固定优先级: 先处理前台,然后处理后台;可能导致饥饿\n时间切片: 每个队列都得到一个确定的能够调度其进程的 CPU 总时间;比如 80%使用 RR 的前台,20%使用 FCFS 的后台\n\n一个进程可以在不同的队列中移动\n例如,n 级优先级-优先级调度在所有级别中,RR 在每个级别中\n\n时间量子大小随优先级级别增加而增加\n如果任务在当前的时间量子中没有完成,则降到下一个优先级\n\n优点: CPU 密集型任务的优先级下降很快;IO 密集型任务停留在高优先级\n\n\nFair Share Scheduling(公平共享调度)\nFSS 控制用户对系统资源的访问\n\n一些用户组比其他用户组更重要\n保证不重要的组无法垄断资源\n未使用的资源按照每个组所分配的资源的比例来分配\n没有达到资源使用率目标的组获得更高的优先级\n\n\n\n 评价方式\n确定性建模: 确定一个工作量,然后计算每个算法的表现\n队列模型: 用来处理随机工作负载的数学方法\n实现/模拟: 建立一个允许算法运行实际数据的系统;最灵活,最具一般性\n 实时调度\n\n\n实时系统\n定义: 正确性依赖于其时间和功能两方面的一个操作系统\n性能指标: 时间约束的及时性;速度和平均性能相对不重要\n主要特征: 时间约束的可预测性\n分类:\n\n强实时系统: 需要在保证时间内完成重要的任务,必须完成\n弱实时系统: 要求重要的进程的优先级更高,尽量完成,并非必须\n\n任务(工作单元): 一次计算,一次文件读取,一次信息传递等\n属性: 去的进展所需要的资源;定时参数.\n\n\n单调速率(RM)\n\n最佳静态优先级调度\n通过周期安排优先级\n周期越短优先级越高\n执行周期最短的任务\n\n\n\n截止日期最早优先(EDF)\n\n最佳的动态优先级调度\nDeadline 越早优先级越高\n执行 Deadline 最早的任务\n\n\n\n 多处理器调度\n多处理器的 CPU 调度更复杂:\n\n多个相同的单处理器组成一个多处理器\n优点: 复杂共享\n\n对称多处理器(SMP)\n\n每个处理器运行自己的调度程序\n需要在调度程序中同步\n\n 优先级反转\n可以发生在任务基于优先级的可抢占的调度机制中\n当系统内的环境强制使高优先级任务等待低优先级任务时发生\n 第九章\n\n第九章的主要内容是：同步\n\n 背景\n第一章到第八章内容, 到目前为止\n\n多道程序设计: 现代操作系统的重要特性\n并行很有用(为什么?) 提示: 多个并发实体: CPU IO 用户 等\n进程,线程: 操作系统抽象出来用于支持多道程序设计\nCPU 调度: 实现多道程序设计的机制\n调度算法: 不同的策略\n\n独立的线程:\n\n不和其他线程共享资源或状态\n确定性: 输入状态决定结果\n可重现: 能够重现起始条件, IO\n调度顺序不重要\n\n合作线程:\n\n在多个线程中共享状态\n不确定性\n不可重现\n\n不确定性和不可重现意味着 bug 可能是间歇性发生的\n进程,线程;计算机,设备需要合作\n合作优点:\n\n\n共享资源\n\n一台电脑,多个用户\n一个银行存款余额,多台 ATM 机\n嵌入式系统\n\n\n\n加速\n\nIO 操作和计算可以重叠\n多处理器\n\n\n\n模块化\n\n将大程序分解成小程序 gcc 会调用 cpp,cc1,cc2,as,ld\n使系统易于扩展\n\n\n\n程序可以调用函数 fork()来创建一个新的进程\n\n\n操作系统需要分配一个新的并且唯一的进程 ID\n\n\n因此在内核中,这个系统调用会运行 new_pid = next_pid++;\n\n\n翻译成机器指令:\n\nLoad next_pid Reg1\nSTORE Reg1 new_pid\nINC Reg1\nSTORE Reg1 next_pid\n\n\n\n假设两个进程并发执行\n\n如果 next_pid 等于 100, 那么其中一个进程得到的 ID 应该是 100, 另一个进程的 ID 应该是 101, next_pid 应该增加到 102\n可能在 INC 前进行了上下文切换, 最终导致两个进程的 pid 都是 100,而 next_pid 也是 101\n\n无论多个线程的指令序列怎样交替执行,程序都必须正常工作\n\n多线程程序具有不确定性和不可重现的特点\n不经过专门设计,调试难度很高\n\n不确定性要求并行程序的正确性\n\n先思考清楚问题,把程序的行为设计清楚\n切忌给予着手编写代码,碰到问题再调试\n\n 一些概念\n前面的现象称为 Race Condition(竞态条件)\n系统缺陷: 结果依赖于并发执行或者时间的顺序,时间\n\n不确定性\n不可重现\n\n怎么样避免竞态?\nAtomic Operator(原子操作)\n原子操作是指一次不存在任何终端或者失败的执行\n\n该执行成功结束\n或者根本没有执行\n并且不应发生任何部分执行的状态\n\n实际上操作往往不是原子的\n\n有些看上去是原子操作,实际上不是\n连 x++这样的简单语句,实际上是由三条指令构成的\n有时候甚至连单条假期指令都不是原子的(Pipeline,super-scalar,out-of-order,pape fault)\n\n临界区(Critical section)是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域\n互斥(Mutual exclusion)是指当一个 进程处于临界区并访问共享资源时,没有其他进程会处于临界区并且访问任何相同的共享资源\n死锁(Dead lock)是指两个或以上进程,在相互等待完成特定任务,而最终没法将自身任务进行下去\n饥饿(Starvation)是指一个可执行的进程,被调度器持续忽略,以至于虽然处于可执行状态却不被执行\n 临界区\n互斥: 同一时间临界区中最多存在一个线程\nProgress: 如果一个线程想要进入临界区,那么它最终会成功\n有限等待: 如果一个线程 i 处于入口区,那么在 i 的请求被接受之前,其他线程进入临界区的时间是有限制的\n无忙等待(可选): 如果一个进程在等待进入临界区,那么在它可以进入之前会被挂起\n 方法 1:禁用硬件中断\n没有中断,没有上下文切换,因此没有并发\n\n硬件将中断处理延迟到中断被启用之后\n大多数现代计算机体系结构都提供指令来完成\n\n进入临界区\n\n禁用中断\n\n离开临界区\n\n开启中断\n\n一旦中断被禁用,线程就无法被停止\n\n整个系统都会为你停下来\n可能导致其他线程处于饥饿状态\n\n要是临界区可以任意长怎么办?\n\n无法限制响应中断所需的时间(可能存在硬件影响)\n\n要小心使用,适合于较小的操作\n 方法 2:基于软件的解决方案\n满足进程 Pi 和 Pj 之间互斥的经典的基于软件的解决方法(1981 年)\n使用两个共享数据项\n\nint turn; //指示该谁进入临界区\nbool flag[]; //指示进程是否准备好进入临界区\n\n进入临界区:\nflag[i] = true;turn = j;while(flag[j] &amp;&amp; turn == j);\n退出临界区:\nflag[i] = false;\n实例:\ndo&#123;\tflag[i] = true;\tturn = j;\twhile(flag[j] &amp;&amp; turn == j);\tCRITICAL SECTION\tflag[i] = false;\tREMAINDER SECTION&#125;while(true);\nBakery 算法(N 个进程的临界区)\n\n进入临界区之前,进程接收一个数字\n得到的数字最小的进入临界区\n如果进程 Pi 和 Pj 收到相同的数字,那么如果 i&lt;j,Pi 先进入临界区,否则 Pj 先进入临界区\n编号方案总是按照枚举的增加顺序生成数字\n\nDekker 算法(1965): 第一个针对双线程例子的正确解决方案\nBakery 算法(1979): 针对 n 线程的临界区问题解决方案\n复杂: 需要两个进程的共享数据项\n需要忙等待: 浪费 CPU 时间\n没有硬件保证的情况下无真正的软件解决方案: Perterson 算法需要原子的 LOAD 和 STORE 指令\n 方法 3:更高级的抽象\n硬件提供了一些原语\n\n像中断禁用, 原子操作指令等\n大多数现代体系结构都这样\n\n操作系统提供更高级的编程抽象来简化并行编程\n\n例如,锁,信号量\n从硬件原语中构建\n\n锁是一个抽象的数据结构\n\n一个二进制状态(锁定,解锁),两种方法\nLock::Acquire() 锁被释放前一直等待,然后得到锁\nLock::Release() 锁释放,唤醒任何等待的进程\n\n使用锁来编写临界区\n\n\n前面的例子变得简单起来:\nlock_next_pid-&gt;Acquire();new_pid = next_pid++;lock_next_pid-&gt;Release();\n\n\n大多数现代体系结构都提供特殊的原子操作指令\n\n通过特殊的内存访问电路\n针对单处理器和多处理器\n\nTest-and-Set 测试和置位\n\n从内存中读取值\n测试该值是否为 1(然后返回真或假)\n内存值设置为 1\n\n交换\n\n交换内存中的两个值\n\nbool TestandSet(bool *target)&#123;\t\tbool rv = *target;\t\t*target = true;\t\treturn rv;&#125;void Exchange(bool *a, bool *b)&#123;\t\tbool tmp = *a;\t\t*a = *b;\t\t*b = tmp;&#125;\n\n\n总结\n锁是更高等级的编程抽象\n\n互斥可以使用锁来实现\n通常需要一定等级的硬件支持\n\n常用的三种实现方法\n\n禁用中断(仅限于单处理器)\n软件方法(复杂)\n原子操作指令(单处理器或多处理器均可)\n\n可选的实现内容:\n\n有忙等待\n无忙等待\n\n\n\n 第十章\n\n第十章的主要内容是：信号量和管程\n\n 信号量\n信号量的抽象数据类型\n\n一个整形(sem),具有两个原子操作\nP(): sem 减一,如果 sem&lt;0,等待,否则继续\nV(): sem 加一,如果 sem≤0,唤醒一个等待的 P\n\n信号量是整数\n信号量是被保护的变量\n\n初始化完成后,唯一改变一个信号量的值的办法是通过 P()和 V()\n操作必须是原子\n\nP()能够阻塞,V()不会阻塞\n我们假定信号量是公平的\n\n没有线程被阻塞在 P()仍然堵塞如果 V()被无限频繁调用(在同一个信号量)\n在实践中,FIFO 经常被使用\n\n两个类型信号量\n\n二进制信号量: 可以是 0 或 1\n计数信号量: 可以取任何非负数\n两者相互表现(给定一个可以实现另一个)\n\n信号量可以用在 2 个方面\n\n互斥\n条件同步(调度约束——一个线程等待另一个线程的事情发生)\n\n 信号量使用\n\n\n用二进制信号量实现的互斥\nmutex = new Semaphore(1);mutex-&gt;P();...mutex-&gt;V();\n\n\n用二进制信号量实现的调度约束\ncondition = new Semaphore(0);//Thread A...condition-&gt;P(); //等待线程B某一些指令完成之后再继续运行,在此阻塞...//Thread B...condition-&gt;V(); //信号量增加唤醒线程A...\n\n\n一个线程等待另一个线程处理事情\n比如生产东西或消费东西(生产者消费者模式),互斥(锁机制)是不够的\n有界缓冲区的生产者-消费者问题\n\n一个或者多个生产者产生数据将数据放在一个缓冲区里\n单个消费者每次从缓冲区取出数据\n在任何一个时间只有一个生产者或消费者可以访问该缓冲区\n\n正确性要求\n\n在任何一个时间只能有一个线程操作缓冲区(互斥)\n当缓冲区为空时,消费者必须等待生产者(调度,同步约束)\n当缓存区满,生产者必须等待消费者(调度,同步约束)\n\n每个约束用一个单独的信号量\n\n二进制信号量互斥\n一般信号量 fullBuffers\n一般信号了 emptyBuffers\n\nclass BoundedBuffer&#123;\t\tmutex = new Semaphore(1);\t\tfullBuffers = new Semaphore(0);   //说明缓冲区初始为空 \t\temptyBuffers = new Semaphore(n);  //同时可以有n个生产者来生产&#125;;BoundedBuffer::Deposit(c)&#123;\t\temptyBuffers-&gt;P();\t\tmutex-&gt;P();\t\tAdd c to the buffer;\t\tmutex-&gt;V();\t\tfullBuffers-&gt;V();&#125;BoundedBuffer::Remove(c)&#123;\t\tfullBuffers-&gt;P();\t\tmutex-&gt;P();\t\tRemove c from buffer;\t\tmutex-&gt;V();\t\temptyBuffers-&gt;V();&#125;\n\n\n 信号量实现\n使用硬件原语\n\n禁用中断\n原子指令\n\n类似锁\n\n禁用中断\n\nclass Semaphore&#123;\t\tint sem;\t\tWaitQueue q;&#125;;Semaphore::P()&#123;\t\t--sem;\t\tif(sem &lt; 0)&#123;\t\t\t\tAdd this thread t to q;\t\t\t\tblock(p);\t\t&#125;&#125;;Semaphore::V()&#123;\t\t++sem;\t\tif(sem &lt;= 0)&#123;\t\t\t\tRemove a thread t from q;\t\t\t\twakeup(t);\t\t&#125;&#125;\n信号量的双用途\n\n互斥和条件同步\n但等待条件是独立的互斥\n\n读,开发代码比较困难\n\n程序员必须非常精通信号量\n\n容易出错\n\n使用的信号量已经被另一个线程占用\n忘记释放信号量\n\n不能够处理死锁问题\n 管程\n目的: 分离互斥和条件同步的关注\n什么是管程\n\n一个锁: 指定临界区\n0 或者多个条件变量: 等待,通知信号量用于管程并发访问共享数据\n\n一般方法\n\n收集在对象,模块中的相关共享数据\n定义方法来访问共享数据\n\nLock\n\nLock::Acquire() 等待直到锁可用,然后抢占锁\nLock::Release() 释放锁,唤醒等待者如果有\n\nCondition Variable\n\n\n允许等待状态进入临界区\n\n允许处于等待(睡眠)的线程进入临界区\n某个时刻原子释放锁进入睡眠\n\n\n\nWait() operation\n\n释放锁,睡眠,重新获得锁放回\n\n\n\nSignal() operation(or broadcast() operation)\n\n唤醒等待者(或者所有等待者),如果有\n\n\n\n实现\n\n需要维持每个条件队列\n线程等待的条件等待 signal()\n\nclass Condition&#123;\t\tint numWaiting = 0;\t\tWaitQueue q;&#125;;Condition::Wait(lock)&#123;\t\tnumWaiting++;\t\tAdd this thread t to q;\t\trelease(lock);\t\tschedule(); //need mutex\t\trequire(lock);&#125;Condition::Signal()&#123;\t\tif(numWaiting &gt; 0)&#123;\t\t\t\tRemove a thread t from q;\t\t\t\twakeup(t); //need mutex\t\t\t\tnumWaiting--;\t\t&#125;&#125;\n管程解决生产者-消费者问题\nclass BoundedBuffer&#123;\t\tLock lock;\t\tint count = 0;  //buffer 为空\t\tCondition notFull, notEmpty;&#125;;BoundedBuffer::Deposit(c)&#123;\t\tlock-&gt;Acquire();    //管程的定义:只有一个线程能够进入管程\t\twhile(count == n)\t\t\t\tnotFull.Wait(&amp;lock); //释放前面的锁\t\tAdd c to the buffer;\t\tcount++;\t\tnotEmpty.Signal();\t\tlock-&gt;Release();&#125;BoundedBuffer::Remove(c)&#123;\t\tlock-&gt;Acquire();\t\twhile(count == 0)\t\t\t\tnotEmpty.Wait(&amp;lock);\t\tRemove c from buffer;\t\tcount--;\t\tnotFull.Signal();\t\tlock-&gt;Release();&#125;\n开发,调试并行程序很难\n\n非确定性的交叉指令\n\n同步结构\n\n锁: 互斥\n条件变量: 有条件的同步\n其他原语: 信号量\n\n怎么样有效地使用这些结构\n\n制定并遵循严格的程序设计风格,策略\n\n 经典同步问题\n\n\n读者-写者问题\n动机: 共享数据的访问\n两种类型的使用者: 读者(不修改数据) 写者(读取和修改数据)\n问题的约束:\n\n允许同一时间有多个读者,但在任何时候只有一个写者\n当没有写者时,读者才能访问数据\n当没有读者和写者时,写者才能访问数据\n在任何时候只能有一个线程可以操作共享变量\n\n多个并发进程的数据集共享\n\n读者: 只读数据集;他们不执行任何更新\n写者: 可以读取和写入\n\n共享数据\n\n数据集\n信号量 CountMutex 初始化为 1\n信号量 WriteMutex 初始化为 1\n整数 Rcount 初始化为 0(当前读者个数)\n\n读者优先设计\n只要有一个读者处于活动状态, 后来的读者都会被接纳.如果读者源源不断的出现,那么写者使用处于阻塞状态.\n//信号量实现//writersem_wait(WriteMutex);write;sem_post(WriteMutex);//readersem_wait(CountMutex);if(Rcount == 0)\t\tsem_wait(WriteMutex); //确保后续不会有写者进入++Rcount;read;--Rcount;if(Rcount == 0)\t\tsem_post(WriteMutex); //全部读者全部离开才能唤醒写者sem_post(CountMutex);\n写者优先设计\n一旦写者就绪,那么写者会尽可能的执行写操作.如果写者源源不断的出现的话,那么读者就始终处于阻塞状态.\n//writerDatabase::Write()&#123;\t\tWait until readers/writers;\t\twrite database;\t\tcheck out - wake up waiting readers/writers;&#125;//readerDatabase::Read()&#123;\t\tWait until no writers;\t\tread database;\t\tcheck out - wake up waiting writers;&#125;//管程实现AR = 0; // # of active readersAW = 0; // # of active writersWR = 0; // # of waiting readersWW = 0; // # of waiting writersCondition okToRead;Condition okToWrite;Lock lock;//writerPublic Database::Write()&#123;\t\t//Wait until no readers/writers;\t\tStartWrite();\t\twrite database;\t\t//check out - wake up waiting readers/writers;\t\tDoneWrite();&#125;Private Database::StartWrite()&#123;\t\tlock.Acquire();\t\twhile((AW + AR) &gt; 0)&#123;\t\t\t\tWW++;\t\t\t\tokToWrite.wait(&amp;lock);\t\t\t\tWW--;\t\t&#125;\t\tAW++;\t\tlock.Release();&#125;Private Database::DoneWrite()&#123;\t\tlock.Acquire();\t\tAW--;\t\tif(WW &gt; 0)&#123;\t\t\t\tokToWrite.signal();\t\t&#125;\t\telse if(WR &gt; 0)&#123;\t\t\t\tokToRead.broadcast(); //唤醒所有reader\t\t&#125;\t\tlock.Release();&#125;//readerPublic Database::Read()&#123;\t\t//Wait until no writers;\t\tStartRead();\t\tread database;\t\t//check out - wake up waiting writers;\t\tDoneRead();&#125;Private Database::StartRead()&#123;\t\tlock.Acquire();\t\twhile(AW + WW &gt; 0)&#123;    //关注等待的writer,体现出写者优先\t\t\t\tWR++;\t\t\t\tokToRead.wait(&amp;lock);\t\t\t\tWR--;\t\t&#125;\t\tAR++;\t\tlock.Release();&#125;private Database::DoneRead()&#123;\t\tlock.Acquire();\t\tAR--;\t\tif(AR == 0 &amp;&amp; WW &gt; 0)&#123;  //只有读者全部没有了,才需要唤醒\t\t\t\tokToWrite.signal();\t\t&#125;\t\tlock.Release();&#125;\n\n\n哲学家就餐问题(学习自 github.com/cyc2018)\n共享数据:\n\nBowl of rice(data set)\nSemaphone fork [5] initialized to 1\n\n#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N    // 右邻居#define THINKING 0#define HUNGRY   1#define EATING   2typedef int semaphore;int state[N];                // 跟踪每个哲学家的状态semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥semaphore s[N];              // 每个哲学家一个信号量void philosopher(int i) &#123;    while(TRUE) &#123;        think(i);        take_two(i);        eat(i);        put_two(i);    &#125;&#125;void take_two(int i) &#123;    down(&amp;mutex);    state[i] = HUNGRY;    check(i);    up(&amp;mutex);    down(&amp;s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去&#125;void put_two(i) &#123;    down(&amp;mutex);    state[i] = THINKING;    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了    check(RIGHT);    up(&amp;mutex);&#125;void eat(int i) &#123;    down(&amp;mutex);    state[i] = EATING;    up(&amp;mutex);&#125;// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行void check(i) &#123;    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;        state[i] = EATING;        up(&amp;s[i]);    &#125;&#125;\n\n\n 第十一章\n\n第十一章的主要内容是：死锁和进程通信\n\n 死锁问题\n一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源\n示例:\n\n系统有 2 个磁带驱动器\nP1 和 P2 各有一个,都需要另外一个\n\n 系统模型\n资源类型 R1,R2,…,Rm(CPU, memory space, IO devices)\n每个资源类型 Ri 有 Wi 个实例.\n每个进程使用资源如下:\n\nrequire,get ← free resource\nuse,hold ← requested,used resource\nrelease ← free resource\n\n可重复使用的资源\n\n在一个时间只能有一个进程使用且不能被删除\n进程获得资源,后来释放由其他进程重用\n处理器,IO 通道,主和副存储器,设备和数据结构,如文件,数据库和信号量\n如果每个进程拥有一个资源并请求其他资源,死锁可能发生\n\n使用资源\n\n创建和销毁\n在 IO 缓存区的中断,信号,消息,信息\n如果接收消息阻塞可能会发生死锁\n可能少见的组合事件会引起死锁\n\n资源分配图\n一组顶点 V 和边 E 的集合\n\n\nV 有两种类型:\n\nP={P1,P2,…,Pn},集合包括系统中的所有进程\nR={R1,R2,…,Rm},集合包括系统中的所有资源类型\n\n\n\nrequesting,claiming edge - directed edge Pi → Rj\n\n\nassignment,holding edge - directed edge Rj → Pi\n\n\n基本情况\n如果图中不包含循环:\n\n没有死锁\n\n如果图中包含循环:\n\n如果每个资源类只有一个实例,那么死锁\n如果每个资源类有几个实例,可能死锁\n\n 死锁特征\n死锁出现一定会出现以下四个条件,但是出现以下四个条件不一定死锁:\n\n互斥: 在一个时间只能有一个进程使用资源\n持有并等待: 进程保持至少一个资源正在等待获取其他进程持有的额外资源\n无抢占: 一个资源只能被进程资源释放,进程已经完成了它的任务之后\n循环等待: 存在等待进程集合{P0,P1,…,Pn},P0 正在等待 P1 所占用的资源,P1 正在等待 P2 占用的资源…Pn-1 在等待 Pn 的资源,Pn 正在等待 P0 所占用的资源\n\n 死锁处理方法\n常见方法\n\n确保系统永远不会进入死锁状态\n运行系统进入死锁状态,然后恢复.\n忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统,包括 UNIX\n\n Deadlock Prevention 预防\n限制申请方式\n\n\n互斥 - 共享资源不是必须的,必须占用非共享资源\n\n\n占用并等待 - 必须保证当一个进程请求的资源,它不持有任何其他资源\n\n需要进程请求并分配其所有资源,它开始执行之前或允许进程请求资源仅当进程没有资源\n资源利用率低,可能发生饥饿\n\n\n\n无抢占 -\n\n如果进程占有某些资源,并请求其他不能被立即分配的资源,则释放当前正占有的资源\n被抢占资源添加到资源列表中\n只有当它能够获得旧的资源以及它请求新的资源,进程可以得到执行\n\n\n\n循环等待 - 对所有资源类型进行排序,并要求每个进程按照资源的顺序进行申请\n\n\n Deadlock Avoidance 避免\n需要系统具有一些额外的先验信息提供\n\n\n最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目\n\n\n资源的分配状态是通过限定提供与分配的资源数量,和进程的最大需求\n\n\n死锁避免算法动态检查的资源分配状态,以确保永远不会有一个环形等待状态\n\n\n当一个进程请求可用资源,系统必须判断立即分配是否能使系统处于安全状态\n\n\n系统处于安全状态指: 针对所有进程,存在安全序列\n\n\n序列&lt;P1,P2,…,Pn&gt;是安全的: 针对每个 Pi,Pi 要求的资源能够由当前可用的资源+所有的 Pj 持有的资源来满足,其中 j&lt;i.\n\n如果 Pi 资源的需求不是立即可用,那么 Pi 可以等到所有 Pj 完成\n当 Pi 完成后,Pi+1 可以得到所需要的资源,执行,返回所分配的资源,并终止.\n用同样的方法,Pi+2,Pi+3 和 Pn 能获得其所需的资源.\n\n\n\n如果系统处于安全状态 → 无死锁\n\n\n如果系统处于不安全状态 → 可能死锁\n\n\n避免死锁: 确保系统永远不会进入不安全状态\n\n\n Deadlock Detection 检测\n每个资源类型单一实例\nMaintain wait-for graph\n\n节点是进程\nPi→Pj: Pi 等待 Pj\n\n定期调用检测算法来搜索图中是否存在循环\n算法需要 n^2 次操作,n 是图中顶点的数目\n数据结构:\n\nAvailable: 长度为 M 的向量表示每种类型可用资源的数量\nAllocation: 一个 nxm 矩阵定义了当前分配给各个进程每种类型资源的数量,如果 Alocation[i, j] = k, 进程 Pi 拥有资源 Rj 的 k 个实例\nRequest: 一个 nxm 矩阵表示各进程的当前请求.如果 Request[i, j] = k,表示进程 Pi 请求 k 个资源 Pj 的实例\n\n具体算法(跳过了,看视频)\n检查算法使用\n何时,使用什么样的频率来检测依赖于:\n\n死锁多久可能会发生?\n多少进程需要被回滚? one for each disjoint cycle\n\n如果检测算法多次被调用,有可能是资源图有多个循环,所以我们无法分辨出多个可能死锁进程中的哪些&quot;造成&quot;死锁\n Recovery from Deadlock 恢复\n终止所有的死锁进程\n在一个时间内终止一个进程直到死锁消除\n终止进程的顺序应该是:\n\n进程的优先级\n进程运行了多久以及需要多少时间才能完成\n进程占用的资源\n进程完成需要的资源\n多少进程需要被终止\n进程是交互还是批处理\n\n选择一个受孩子 - 最小的成本\n回滚 - 返回到一些安全状态,重启进程到安全状态\n饥饿 - 同一进程可能一直被选作受害者,包括回滚的数量\n IPC\n 概述\n进程通信的机制及同步\n不使用共享变量的进程通信\nIPC facility 提供 2 个操作:\n\nsend(message) - 消息大小固定或者可变\nreceive(message)\n\n如果 P 和 Q 想通信,需要:\n\n在它们之间建立通信链路\n通过 send/recevie 交换消息\n\n通信链路的实现\n\n物理(例如,共享内存,硬件总线)\n逻辑(例如,逻辑属性)\n\n 直接通信\n进程必须正确的命名对方:\n\nsend(P, message) - 发送消息到进程 P\nreceive(Q, message) - 从进程 Q 接收信息\n\n通信链路的属性\n\n自动建立链路\n一条链路恰好对应一对通信进程\n每对进程之间只有一个链路存在\n链路可以是单向的,但通常是双向的\n\n 间接通信\n定向从消息队列接收消息\n\n每个消息对垒都有一个唯一的 ID\n只有它们共享了一个消息队列,进程才能够通信\n\n通信链路的属性\n\n只有进程共享一个共同的消息队列,才建立链路\n链接可以与许多进程相关联\n每对进程可以共享多个通信链路\n链接可以是单向或者双向\n\n操作\n\n创建一个新的消息队列\n通过消息队列发送和接收消息\n销毁消息队列\n\n原语的定义如下:\n\n\nsend(A, message)\n\n\nreceive(A, message)\n\n\n通信链路缓冲\n通信链路缓存大小:\n\n0 容量 - 0 message : 发送方必须等待接收方\n有限容量 - n messages 的有限长度 : 发送方必须等待,如果队列满\n无限容量 - 无限长度 : 发送方不需要等待\n\n\n\n 信号\n信号 Signal\n\n软件中断通知事件处理\nExamples: SIGFPE, SIGKILL, SIGUSRI, SIGSTOP, SIGCONT\n\n接收到信号时会发生什么?\n\ncatch: 指定信号处理函数被调用\nignore: 依靠操作系统的默认操作(abort, memory dump, suspend or resume process)\nmask: 闭塞信号因此不会传送(可能是暂时的,当处理同样类型的信号)\n\n不足:\n\n不能传输要交换的任何数据\n\n 管道\n数据交换\n子进程从父进程继承文件描述符(0 stdin, 1 stdout, 2 stderr)\n进程不知道(或不关心)从键盘,文件,程序读取或写入到终端,文件,程序.\n例如: $ ls | more (两个进程, 管道是缓存,对于 ls 来说是 stdout,对于 more 来说是 stdin )\n 消息队列\n消息队列按 FIFO 来管理消息\n\nmessage: 作为一个字节序列存储\nmessage queues: 消息数组\nFIFO &amp; FILO configuration\n\n 共享内存\n进程\n\n每个进程都有私有地址空间\n在每个地址空间内,明确地设置了共享内存段\n\n优点\n\n快速,方便地共享数据\n\n不足\n\n必须同步数据访问\n\n最快的方法\n一个进程写另一个进程立即可见\n没有系统调用干预\n没有数据复制\n不提供同步\n\nSocket\n\n 第十二章\n\n第十二章的主要内容是：文件管理\n\n 基本概念\n 文件系统和文件\n文件系统: 一种用于持久性存储的系统抽象\n\n在存储上: 组织,控制,导航,访问和检索数据\n在大多数计算机系统包含文件系统\n个人电脑,服务器,笔记本电脑\nipod,tivo,机顶盒,手机,电脑\ngoogle 可能也是由一个文件系统构成的\n\n文件: 文件系统中的一个单元的相关数据在操作系统中的抽象\n文件系统的功能:\n\n\n分配文件磁盘空间\n\n管理文件块(哪一块属于哪一个文件)\n管理空闲空间(哪一块是空闲的)\n分配算法(策略)\n\n\n\n管理文件集合\n\n定位文件及其内容\n命名: 通过名字找到文件的接口\n最常见: 分层文件系统\n文件系统类型(组织文件的不同方式)\n\n\n\n提供的便利及特征\n\n保护: 分层来保护数据安全\n可靠性,持久性: 保持文件的持久即使发生崩溃,媒体错误,攻击等\n\n\n\n文件和块:\n文件属性: 名称,类型,位置,大小,保护,创建者,创建时间,最久修改时间…\n文件头: 在存储元数据中保存了每个文件的信息,保存文件的属性,跟踪哪一块存储块属于逻辑上文件结构的哪个偏移\n 文件描述符\n文件使用模式:\n使用程序必须在使用前先&quot;打开&quot;文件\nf = open(name, flag);...... = read(f, ...);...close(f);\n内核跟踪每个进程打开的文件:\n\n操作系统为每个进程维护一个打开文件表\n一个打开文件描述符是这个表中的索引\n\n需要元数据来管理打开文件:\n文件指针: 指向最近的一次读写位置,每个打开了这个文件的进程都这个指针\n文件打开计数: 记录文件打开的次数 - 当最后一个进程关闭了文件时,允许将其从打开文件表中移除\n文件磁盘位置: 缓存数据访问信息\n访问权限: 每个程序访问模式信息\n用户视图: 持久的数据结构\n系统访问接口:\n字节的集合(UNIX)\n系统不会关心你想存储在磁盘上的任何的数据结构\n操作系统内部视角:\n块的集合(块是逻辑转换单元,而扇区是物理转换单元)\n块大小&lt;&gt; 扇区大小: 在 UNIX 中, 块的大小是 4KB\n当用户说: 给我 2-12 字节空间时会发生什么?\n获取字节所在的快\n返回快内对应部分\n如果要写 2-12 字节?\n获取块\n修改块内对应部分\n写回块\n在文件系统中的所有操作都是在整个块空间上进行的: getc() putc() 即使每次只访问 1 字节的数据,也会缓存目标数据 4096 字节(一个磁盘块)\n用户怎么访问文件: 在系统层面需要知道用户的访问模式\n顺序访问: 按字节依次读取(几乎所有的访问都是这种方式)\n随机访问: 从中间读写(不常用,但是仍然重要,如: 虚拟内存支持文件,内存页存储在文件中;更加快速,不希望获取文件中间的内容的时候也必须先获取块内所有字节)\n内容访问: 通过特征\n文件内部结构:\n无结构: 单词,比特的队列\n简单记录结构: 列,固定长度,可变长度\n复杂结构: 格式化的文档(word, PDF), 可执行文件, …\n多用户系统中的文件共享是很必要的\n访问控制:\n谁能够获得哪些文件的哪些访问权限\n访问模式: 读,写,执行,删除,列举等\n文件访问控制列表(ACL):\n&lt;文件实体, 权限&gt;\nUNIX 模式:\n&lt;用户|组|所有人,读|写|可执行&gt;\n用户 ID 识别用户,表明每个用户所允许的权限及保护模式\n组 ID 允许用户组成组,并指定了组访问权限\n指定多用户,客户如何同时访问共享文件:\n和过程同步算法相似\n因磁盘 IO 和网络延迟而设计简单\nUNIX 文件系统(UFS)语义:\n对打开文件的写入内容立即对其他打开同一文件的其他用户可见\n共享文件指针允许多用户同时读取和写入文件\n会话语义:\n写入内容只有当文件关闭时可见\n锁:\n一些操作系统和文件系统提供该功能\n 目录\n文件以目录的方式组织起来\n目录是一类特殊的文件: 每个目录都包含了一张表&lt;name, pointer to file header&gt;\n目录和文件的树形结构: 早期的文件系统是扁平的(只有一层目录)\n层次名称空间: /spell/mail/prt/first /programs/p/list\n典型操作:\n搜索文件\n创建文件\n删除文件\n枚举目录\n重命名文件\n在文件系统中遍历一个路径\n操作系统应该只允许内核模式修改目录: 确保映射的完整性,应用程序能够读目录(ls)\n文件名的线性列表,包含了指向数据块的指针: 编程简单,执行耗时\nHash 表 - hash 数据结构的线性表: 减少目录搜索时间,碰撞,固定大小\n名字解析: 逻辑名字转换成物理资源(如文件)的过程:\n在文件系统中: 到实际文件的文件名(路径)\n遍历文件目录直到找到目标文件\n举例: 解析&quot;/bin/ls&quot;:\n读取 root 的文件头(在磁盘固定位置)\n读取 root 的数据块: 搜索 bin 项\n读取 bin 的文件头\n读取 bin 的数据块: 搜索 ls 项\n读取 ls 的文件头\n当前工作目录:\n每个进程都会指向一个文件目录用于解析文件名\n允许用户指定相对路径来代替绝对路径\n一个文件系统需要先挂载才能被访问\n一个未挂载的文件系统被挂载在挂载点上\n 文件别名\n两个或多个文件名关联同一个文件:\n硬链接: 多个文件项指向一个文件\n软链接: 以快捷方式指向其他文件\n通过存储真实文件的逻辑名称来实现\n如果删除一个有别名的文件会如何呢? : 这个别名将成为一个悬空指针\nBackpointers 方案:\n每个文件有一个包含多个 backpointers 的列表,所以删除所有的 Backpointers\nbackpointers 使用菊花链管理\n添加一个间接层: 目录项数据结构\n链接: 已存在文件的另外一个名字(指针)\n链接处理: 跟随指针来定位文件\n我们如何保证没有循环呢?\n只允许到文件的链接, 不允许在子目录的链接\n每增加一个新的链接都用循环检测算法确定是否合理\n限制路径可遍历文件目录的数量\n 文件系统种类\n磁盘文件系统: 文件存储在数据存储设备上,如磁盘; 例如: FAT,NTFS,ext2,3,ISO9660 等\n数据库文件系统: 文件根据其特征是可被寻址的; 例如: WinFS\n日志文件系统: 记录文件系统的修改,事件; 例如: journaling file system\n网络,分布式文件系统: 例如: NFS,SMB,AFS,GFS\n特殊,虚拟文件系统\n 虚拟文件系统\n分层结构:\n顶层: 文件,文件系统 API\n上层: 虚拟(逻辑)文件系统 (将所有设备 IO,网络 IO 全抽象成为文件,使得接口一致)\n底层: 特定文件系统模块\n目的: 对所有不同文件系统的抽象\n功能:\n提供相同的文件和文件系统接口\n管理所有文件和文件系统关联的数据结构\n高效查询例程,遍历文件系统\n与特定文件系统模块的交互\n数据结构:\n卷[第四声]控制块(UNIX: “superblock”)\n每个文件系统一个\n文件系统详细信息\n块,块大小,空余块,计数,指针等\n文件控制块(UNIX: “vnode” or “inode”)\n每个文件一个\n文件详细信息\n许可,拥有者,大小,数据库位置等\n目录节点(Linux: “dentry”)\n每个目录项一个(目录和文件)\n将目录项数据结构及树形布局编码成树形数据结构\n指向文件控制块,父节点,项目列表等\n其中: 卷控制块(每个文件系统一个),文件控制块(每个文件一个),目录节点(每个目录项一个)\n持续存储在二级存储中: 在分配在存储设备中的数据块中\n当需要时加载进内存:\n卷控制块: 当文件系统挂载时进入内存\n文件控制块: 当文件被访问时进入内存\n目录节点: 在遍历一个文件路径时进入内存\n 数据块缓存\n数据块按需读入内存:\n提供 read() 操作\n预读: 预先读取后面的数据块\n数据块使用后被缓存:\n假设数据将会再次被使用\n写操作可能被缓存和延迟写入\n两种数据块缓存方式:\n普通缓冲区缓存\n页缓存: 同一缓存数据块和内存页\n分页要求: 当需要一个页时才将其载入内存\n支持存储: 一个页(在虚拟地址空间中)可以被映射到一个本地文件中(在二级存储中)\n 打开文件的数据结构\n打开文件描述:\n每个被打开的文件一个\n文件状态信息\n目录项,当前文件指针,文件操作设置等\n打开文件表:\n一个进程一个\n一个系统级的\n每个卷控制块也会保存一个列表\n所以如果有文件被打开将不能被卸载\n一些操作系统和文件系统提供该功能\n调节对文件的访问\n强制和劝告:\n强制 - 根据锁保持情况和需求拒绝访问\n劝告 - 进程可以查找锁的状态来决定怎么做\n 文件分配\n大多数文件都很小:\n需要对小文件提供强力的支持\n块空间不能太小\n一些文件非常大:\n必须支持大文件(64-bit 文件偏移)\n大文件访问需要相当高效\n如何为一个文件分配数据块\n分配方式:\n连续分配\n链式分配\n索引分配\n指标:\n高效: 如存储利用(外部碎片)\n表现: 如访问速度\n连续分配:\n文件头指定起始块和长度\n位置,分配策略: 最先匹配,最佳匹配,…\n优势: 文件读取表现好;高效的顺序和随机访问\n劣势: 碎片;文件增长问题\n链式分配:\n文件以数据块链表方式存储\n文件头包含了到第一块和最后一块的指针\n优势: 创建,增大,缩小很容易;没有碎片\n劣势: 不可能进行真正的随机访问;可靠性\n索引分配:\n为每个文件创建一个名为索引数据块的非数据数据块(到文件数据块的指针列表)\n文件头包含了索引数据块\n优势: 创建,增大,缩小很容易;没有碎片;支持直接访问\n劣势: 当文件很小时,存储索引的开销大;处理大文件难\n 空闲空间列表\n跟踪在存储中的所有未分配的数据块\n空闲空间列表存储在哪里?\n空闲空间列表的最佳数据结构怎么样?\n用位图代表空闲数据块列表: 11111101101110111 如果 i = 0 表明数据块 i 是空闲的,反之是分配的\n使用简单但是可能会是一个 big vector:\n160GB disk → 40M blocks → 5MB worth of bits\n然而,如果空闲空间在磁盘中均匀分布,那么再找到&quot;0&quot;之前需要扫描 磁盘上数据块总数 / 空闲块的数目\n需要保护:\n指向空闲列表的指针\n位图:\n必须保存在磁盘上;在内存和磁盘拷贝可能有所不同;不允许 block[i]在内存中的状态为 bit[i]=1 而在磁盘中 bit[i]=0\n解决:\n在磁盘上设置 bit[i] = 1; 分配 block[i]; 在内存中设置 bit[i] = 1\n 多磁盘管理 - RAID\n通常磁盘通过分区来最大限度减小寻道时间:\n一个分区是一个柱面的集合\n每个分区都是逻辑上独立的磁盘\n分区: 硬件磁盘的一种适合操作系统指定格式的划分\n卷: 一个拥有一个文件系统实例的可访问的存储空间(通常常驻在磁盘的单个分区上)\n使用多个并行磁盘来增加: 吞吐量(通过并行),可靠性和可用性(通过冗余)\nRAID - 冗余磁盘阵列: 各种磁盘管理技术;RAID levels: 不同 RAID 分类,如 RAID-0,RAID-1,RAID-5\n实现: 在操作系统内核: 存储,卷管理; RAID 硬件控制器(IO)\nRAID-0\n数据块分成多个子块, 存储在独立的磁盘中: 和内存交叉相似\n通过更大的有效块大小来提供更大的磁盘带宽\nRAID-1\n可靠性成倍增长\n读取性能线性增加(向两个磁盘写入,从任何一个读取)\nRAID-4\n数据块级磁带配有专用奇偶校验磁盘: 允许从任意一个故障磁盘中恢复\n条带化和奇偶校验按 byte-by-byte 或者 bit-by-bit: RAID-0,4,5: block-wise ;RAID-3: bit-wise\nRAID-5\n每个条带快有一个奇偶校验块,允许有一个磁盘错误\nRAID-6\n两个冗余块,有一种特殊的编码方式,允许两个磁盘错误\n 磁盘调度\n读取或写入时,磁头必须被定位在期望的磁道,并从所期望的扇区开始\n寻道时间: 定位到期望的磁道所花费的时间\n旋转延迟: 从扇区的开始处到到达目的处花费的时间\n平均旋转延迟时间 = 磁盘旋转一周时间的一半\n寻道时间是性能上区别的原因\n对单个磁盘,会有一个 IO 请求数目\n如果请求是随机的,那么会表现很差\nFIFO:\n按顺序处理请求\n公平对待所有进程\n在有很多进程的情况下,接近随机调度的性能\n最短服务优先:\n选择从磁臂当前位置需要移动最少的 IO 请求\n总是选择最短寻道时间\nskan:\n磁臂在一个方向上移动,满足所有为完成的请求,直到磁臂到达该方向上最后的磁道\n调换方向\nc-skan:\n限制了仅在一个方向上扫描\n当最后一个磁道也被访问过了后,磁臂返回到磁盘的另外一端再次进行扫描\nc-loop(c-skan 改进):\n磁臂先到达该方向上最后一个请求处,然后立即反转\n","categories":["学习"],"tags":["操作系统","计算机"]},{"title":"Hexo搭建个人网站","url":"/2024/09/30/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/","content":" 准备工作\nHexo 是一个快速、简洁且高效的静态博客框架，它基于Node.js运行，搭建过程中还需要使用npm（Node.js 自带）和Git，因此先需要搭建本地操作环境。\n 安装 Node.js\n在Node.js 官网选择 LTS 长期维护版本进行下载，安装完成后通过以下指令检测是否安装成功。\n# 查看Node.js版本node -v# 查看npm版本npm -v\n安装好Node.js后，会自带 npm。由于该npm的镜像源默认是在国外的，在安装插件时有时会很慢，这时可以通过如下指令更换镜像源。\n# 更换为淘宝的镜像源npm config set registry https://registry.npm.taobao.org# 查看当前npm的镜像源npm config get registry# 取消镜像npm config delete registry\n 安装 Git\nGit 详细安装 Node.js 安装教程（详解 Git 安装过程的每一个步骤）\n 安装 Hexo\n首先给出官方网址: Hexo 官网\n\n\n首先需要建立一个空文件夹，尽量非系统盘，比如~D:/Hexo/，以后都指代为根目录。\n\n\n使用npm安装Hexo,在根目录路径下右键-&gt;Git Bash Here，输入\n# 将npm源替换为阿里的镜像。之后的安装就会迅速很多了。npm config set registry https://registry.npmmirror.com# npm config set registry https://registry.npmjs.org/ 原镜像源# npm config set registry https://registry.npm.taobao.org 淘宝镜像源# hexo-cli 是 hexo的指令集。npm install hexo-cli -g# 有了指令集以后，使用它的初始化指令来初始化安装Hexo博客。hexo init# 清空缓存 hexo cleanhexo cl# 重新编译 hexo generatehexo g# 打开本地访问 hexo serverhexo s\n\n\n在浏览器打开localhost:4000，就能看到\n\n如果你安装了hexo-admin插件，就可以通过访问localhost:4000/admin来管理你的文章了，并且在可视化界面中操作文章内容。\n# 网页端hexo文档管理插件npm install hexo-admin --save\n 部署到 Github\n\n\n注册Github账号\n\n\n新建username.github.io仓库\n注册成功后，在 github 首页单击头像-&gt;Your repositories，在自己的 GitHub 账号下创建一个新的仓库，命名为 username.github.io（username 是你的账号名)。\n\n\n配置 Git 和 Github\n\n\n此处为全局配置，所以可以在任意位置打开 git bash，设置用户名称和邮件地址。\ngit config --global user.name \"xiansakana\"git config --global user.email \"xiansakana@gmail.com\"\n\n\n设置完成后为了能够在本地使用git管理github上的项目，需要绑定SSHkey。\n# -C后面加你在github的用户名邮箱，这样公钥才会被github认可ssh-keygen -t rsa -C xiansakana@gmail.com# 查看公钥内容稍后加入Github账户的sshkey中,less ~/.ssh/id_rsa.pub\n\n\n\n这一步骤推荐在git bash中运行指令。若使用powershell或cmd，less指令缺少必要的 C 语言环境，需要访问C:\\Users\\Username\\.ssh\\id_rsa.pub复制。\n\n\n\n在个人github网页单击头像-&gt;settings,在设置页面找到SSH and GPG keys，单击New SSH key将刚刚复制的 Key 粘贴过来新建SSH KEY。\n\n\n保存后，在 git bash 测试 sshkey 是否添加成功，输入\n# Attempts to ssh to GitHubssh -T git@github.com\n正常输出是\nThe authenticity of host 'github.com (207.97.227.239)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?# 此处请输入yesHi username! You've successfully authenticated, but GitHub does not provide shell access.\n\n配置过程中可能遇到的 bug\n如果报错为\nssh: connect to host gitee.com port 22: Connection timed out\n这是由于在当前网络环境中，端口 22 被占用了，可以改用其他端口再试试\n# -p 443表示使用443端口，要是443也被占用，也可以尝试其他端口ssh -T -p 443 git@ssh.github.com\n\n\n\n\n\n配置 hexo 部署插件内容\n确保安装了hexo-deployer-git，如果没有，在根目录下右键-&gt;Git Bash Here，输入\nnpm install hexo-deployer-git --save\n打开根目录的_config.yml,修改底部的deploy配置项。如果没有找到deploy配置项,则自己添加\n# Deployment# Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:username/username.github.io.git # 记得把username替换为自己的用户名  branch: main #2020年10月后github新建仓库默认分支改为main，注意修改\n\n这里deploy前面不要有空格，而所有:后面都要有空格。对齐缩进情况要严格按照示例来写。yml编译对缩进要求很严格，所以格式很重要。\n\n\n\n把本地 Hexo 博客内容提交到git仓库\n在根目录右键-&gt;Git Bash Here，输入\nhexo cl # hexo cleanhexo g # hexo generatehexo d # hexo deploy\n不出意外，就可以在浏览器上输入https://username.github.io访问你的博客了，记得替换username为自己的用户名。\n\n\n关于备份的问题，我一般都新建一个私人仓库来备份 hexo 源文件，而且可以用 bat 批处理来一键发布和备份文章\nstart cmd /k \"d: &amp;&amp; cd Hexo &amp;&amp; hexo cl &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add  --all &amp;&amp; git commit -m \"update posts\" &amp;&amp; git push\"\n 域名配置\n\n购买域名\n\n\n腾讯云域名注册\n阿里云域名注册\n\n\n\n绑定域名\n首先要获取博客当前默认域名的IP,打开cmd或者powershell，输入\nping username.github.io# username记得替换成你的用户名\n获取到的ip地址填入域名解析\n这里以腾讯云为例。进入控制台-&gt;域名注册-&gt;我的域名。在购买的域名的操作栏选择解析。\n\n\n\n进入解析页面后需要添加两条记录。\n\n\n关于为什么要添加两条记录。此处有必要说明一下，实质起作用的其实是第一条A记录，而第二条CNAME记录指向的其实是www的二级域名。例如此处指向www.akilar.top。然后当有人用www.akilar.top访问时，会重定向到akilar.top。emmm,虽然看起来有点多此一举啦，但是听说这样可以提升访问成功几率。毕竟很多人习惯在域名前面敲个www。\n\n\n\n在根目录\\source\\下新建CNAME文件（注意不要有后缀名，就叫CNAME即可，什么.txt、.js之类的后缀都不能有），在CNAME文件中添加上你购买的域名。\n\n\n配置username.github.io仓库。\n\n\n打开username.github.io，点击仓库页面右上角的 setting\n\n下拉找到 Github Pages 栏，在 Custom domain 中填入你购买的域名。\n\n\n\n最后，重新部署一下\nhexo cleanhexo generatehexo depoly\n\n\n即可通过你的域名来访问博客了。\n我们主要使用 butterfly 主题的魔改版本安知鱼主题来搭建。首先给出butterfly 的官方文档和其主题美化教程，以及安知鱼主题的官方文档和安知鱼主题指南。\n 主题安装\n 安装安知鱼主题\n在博客根目录里安装最新版【推荐】\ngit clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu\n如遇安装不上可以使用以下 url 代理安装\ngit clone -b main https://ghproxy.com/https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu\n 应用主题\n修改 hexo 配置文件_config.yml，把主题改为anzhiyu\ntheme: anzhiyu\n 安装 pug 和 stylus 渲染插件\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\n若无法安装则考虑 cnpm 进行安装\nnpm install hexo-renderer-pug hexo-renderer-stylus --save --registry=http://registry.npmmirror.com\n 覆盖配置\n覆盖配置可以使主题配置放置在 anzhiyu 目录之外，避免在更新主题时丢失自定义的配置。\n\n\nmacos/linux 在博客根目录运行\ncp -rf ./themes/anzhiyu/_config.yml ./_config.anzhiyu.yml\n\n\nwindows 复制/themes/anzhiyu/_config.yml此文件到 hexo 根目录，并重命名为_config.anzhiyu.yml\n\n\n以后如果修改任何主题配置，都只需修改 _config.anzhiyu.yml 的配置即可。\n\n注意：\n\n只要存在于 _config.anzhiyu.yml 的配置都是高优先级，修改原 _config.yml 是无效的。\n每次更新主题可能存在配置变更，请注意更新说明，可能需要手动对 _config.anzhiyu.yml 同步修改。\n想查看覆盖配置有没有生效，可以通过 hexo g --debug 查看命令行输出。\n如果想将某些配置覆盖为空，注意不要把主键删掉，不然是无法覆盖的\n\n\n 本地启动 hexo\nhexo clhexo ghexo s\n此时就能在http://localhost:4000看到效果了。\n 升级方法\n适用于通过 Github 或 Release 压缩包主题，且没有自行修改任何代码的情况。\n\n\n先将原文件夹重命名为别的名称，例如 anzhiyu-bkp，用于升级失败进行回退。\n\n\n选择自己的安装方式升级。\nGithub：重新重新执行安装命令即可\ngit clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu\nRelease：按照安装步骤，下载 release 并解压重命名为 anzhiyu\n\n\n比对升级后的配置文件_config.yml，如果某些配置发生了变化（改名或弃用），release 的说明里会特别提示或给出配置文件版本对比 diff，同步修改原配置文件即可。\n\n\n 页面配置\n主题配置文件中开启menu中标签页的注释，注意缩进！！！\nmenu:  文章:    隧道: /archives/ || anzhiyu-icon-box-archive    分类: /categories/ || anzhiyu-icon-shapes    标签: /tags/ || anzhiyu-icon-tags  友链:    友人帐: /link/ || anzhiyu-icon-link    朋友圈: /fcircle/ || anzhiyu-icon-artstation    留言板: /comments/ || anzhiyu-icon-envelope  我的:    音乐馆: /music/ || anzhiyu-icon-music    追番页: /bangumis/ || anzhiyu-icon-bilibili    相册集: /album/ || anzhiyu-icon-images    小空调: /air-conditioner/ || anzhiyu-icon-fan  关于:    关于本人: /about/ || anzhiyu-icon-paper-plane    闲言碎语: /essay/ || anzhiyu-icon-lightbulb    随便逛逛: javascript:toRandomPost() || anzhiyu-icon-shoe-prints1\n 标签页\n在 Hexo 博客根目录下打开终端，输入\nhexo new page tags\n找到 source/tags/index.md 这个文件并修改，添加type: &quot;tags&quot;\n---title: 标签date: 2023-09-20 16:02:53type: \"tags\"comments: falsetop_img: falseorderby: nameorder: 1---\n\n\n\n参数\n解释\n\n\n\n\ntype\n【必须】页面类型，必须为 tags\n\n\ncomments\n【可选】是否显示评论\n\n\ntop_img\n【可选】是否显示顶部图\n\n\norderby\n【可选】排序方式 ：random/name/length\n\n\norder\n【可选】排序次序： 1, asc for ascending; -1, desc for descending\n\n\n\n 分类页\n在 Hexo 博客根目录下打开终端，输入\nhexo new page categories\n找到 source/categories/index.md 这个文件并修改，添加type: &quot;categories&quot;\n---title: 分类date: 2023-09-20 16:13:51aside: falsetop_img: falsetype: \"categories\"---\n\n自定义分类页面\n\n首先去除source/categories/index.md文件中的type: &quot;categories&quot;\n修改source/categories/index.md文件，具体内容可自行修改链接与文字\n\n---title: 分类date: 2023-09-20 16:13:51aside: falsetop_img: false# type: categories---&lt;style&gt;  #libCategories .card-wrap:hover .card-info:after &#123;    width: 300%;  &#125;&lt;/style&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://npm.elemecdn.com/js-heo@1.0.11/3dCard/no3d.css\"&gt;&lt;div id='libCategories'&gt;&lt;div id=\"lib-cards\" class=\"container\"&gt;&lt;a href='javascript:void(0);' onClick='pjax.loadUrl(\"/categories/学习/\")'&gt;&lt;card data-image=\"https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309232121154.jpg\"&gt;&lt;h1 slot=\"header\"&gt;学习&lt;/h1&gt;&lt;p slot=\"content\"&gt;学习之路，永无止境。&lt;/p&gt;&lt;/card&gt;&lt;/a&gt;&lt;a href='javascript:void(0);' onClick='pjax.loadUrl(\"/categories/游戏/\")'&gt;  &lt;card data-image=\"https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309232100891.jpg\"&gt;    &lt;h1 slot=\"header\"&gt;游戏&lt;/h1&gt;    &lt;p slot=\"content\"&gt;各种游戏记录。&lt;/p&gt;  &lt;/card&gt;&lt;/a&gt;&lt;a href='javascript:void(0);' onClick='pjax.loadUrl(\"/categories/生活/\")'&gt;  &lt;card data-image=\"https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309232116463.jpg\"&gt;    &lt;h1 slot=\"header\"&gt;生活&lt;/h1&gt;    &lt;p slot=\"content\"&gt;和好朋友👬们一起经历的有趣事。&lt;/p&gt;  &lt;/card&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src='https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/2.6.14/vue.min.js' data-pjax&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://npm.elemecdn.com/anzhiyu-theme-static@1.0.7/no3d/no3d.js\" data-pjax&gt;&lt;/script&gt;\n\n 首页即刻说说页\n在 Hexo 博客根目录下打开终端，输入\nhexo new page essay\n找到 source/essay/index.md 这个文件并修改，添加type: &quot;essay&quot;\n---title: 说说date: 2023-09-20 16:38:41comments: trueaside: falsetop_img: falsetype: essay---\n添加数据，新建文件[blog]\\source\\_data\\essay.yml，没有_data文件夹的话也请自己新建。以下是默认格式示例，打开source\\_data\\essay.yml，输入\n- title: 说说  subTitle: 咸鱼的日常生活。  tips: 随时随地，分享生活  buttonText: 关于我  buttonLink: /about/  limit: 1000  home_essay: true  top_background: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309232138720.png  essay_list:    - content: 终于写完作业了，好困，明天有时间再想办法继续弄这个网站吧，毕竟还有很多细节需要慢慢配置。      date: 2023-09-22    - content: 今天把Hexo建站的笔记写了大半了，明天看看能不能写完，不过好像database明天有个作业要due了，好烦。      date: 2023-09-20    # - content: 音乐支持了参数设置自定义歌单    #   date: 2023/01/02    #   link: https://blog.anheyu.com/music/?id=7269231710&amp;server=tencent    # - content: 关于页的打赏仿了b站的充电功能，使用svg绘图➕一些动画参数移动，应该不会被b站警告吧😜，另外文章也支持了顶部随机b站同款春秋冬banner。    #   date: 2022/12/18    # - content: React中不能直接修改state的一个重要原因是在性能优化时的prueComponment会进行浅层比较会认为是用一个对象且不能进入队列中批量更新    #   date: 2022/12/10    # - content: 好耶，马上就可以放假回家了！好想家里的好吃的😋！才不是想捏妹妹的脸了    #   date: 2022/12/06    # - content: 全局音乐的动画也处理好了, nice!    #   date: 2022/11/13    # - content: 把页脚, 首页顶部全都魔改到本地了, 方便后续魔改, 音乐也改成胶囊的样式了, 其实还是想让胶囊可拖拽, 不可点击改变歌词位置的, 但是弄了半天都没弄好就放弃了    #   date: 2022/11/13    # - content: 朋友圈船新版本终于写完了, 耶✌️    #   date: 2022/11/05    #   link: https://blog.anheyu.com/album/    # - content: 终于把相册集搞定了, 耶✌️, 瀑布流在滑动滚动条一个视口范围上下100的情况执行一次, 到底部停止监听让性能高了好多，再也不会布局混乱🤪了    #   date: 2022/10/25    #   link: https://blog.anheyu.com/album/    # - content: 搜索🔍支持缩略图显示啦（默认获取文章内容的第一张图片）    #   date: 2022/10/23 08:00:00    #   from: 安知鱼    # - content: 遇见彩虹🌈吃定彩虹    #   date: 2022/10/23 10:00:00    #   image:    #     - https://bu.dusays.com/2023/04/09/64329399e285d.webp    #     - https://bu.dusays.com/2023/04/09/64329399aa3bc.webp    #     - https://bu.dusays.com/2023/04/09/6432939996dd7.webp    # - content: ThreeJs API真多丫    #   date: 2022/10/19    # - content: 妹妹强制要求我买走了她的两幅画 -¥30    #   date: 2022/10/02    #   image:    #     - https://bu.dusays.com/2023/04/09/643293997b92b.jpeg    # - content: 歌曲推荐    #   date: 2022/09/25    #   aplayer:    #     server: tencent    #     id: 001FGQba3i10mw    # - content: 做了一个噩梦, 梦到从楼顶坠下去了。😷    #   date: 2022/09/24    # - content: JOJO是真的好看！    #   date: 2022/09/21    #   link: https://www.bilibili.com/bangumi/play/ss39431?spm_id_from=333.337.0.0\n 友情链接\n在 Hexo 博客根目录下打开终端，输入\nhexo new page link\n找到 source/link/index.md 这个文件并修改，添加type: &quot;link&quot;\n---title: 友链date: 2023-09-20 17:00:15type: \"link\"---\n新建文件source\\_data\\link.yml,没有_data文件夹的话也请自己新建。以下是默认友链格式示例。打开[blog]\\source\\_data\\link.yml，输入\n- class_name: 框架  flink_style: flexcard  link_list:    - name: Hexo      hundredSuffix: \"\"      link: https://hexo.io/zh-tw/      avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg      descr: 快速、简单且强大的网站框架    - name: anzhiyu主题      link: https://blog.anheyu.com/      avatar: https://img02.anheyu.com/adminuploads/1/2022/09/15/63232b7d91d22.jpg      descr: 生活明朗，万物可爱      siteshot: https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/anzhiy.cn.jpg- class_name: 推荐博客  flink_style: flexcard  link_list:    - name: 安知鱼      hundredSuffix: \"\"      link: https://blog.anheyu.com/      avatar: https://img02.anheyu.com/adminuploads/1/2022/09/15/63232b7d91d22.jpg      descr: 生活明朗，万物可爱      siteshot: https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/anzhiy.cn.jpg- class_name: 小伙伴  class_desc: 那些人，那些事  flink_style: anzhiyu  link_list:    - name: 安知鱼      hundredSuffix: \"\"      link: https://blog.anheyu.com      avatar: https://img02.anheyu.com/adminuploads/1/2022/09/15/63232b7d91d22.jpg      descr: 生活明朗，万物可爱\n\n\n\n参数\n解释\n\n\n\n\nclass_name\n【必填】友链分类名\n\n\nclass_desc\n【可选】友链分类描述\n\n\nflink_style\n【必填】flexcard或者anzhiyu或者telescopic\n\n\nhundredSuffix\n【可选】解决共同进步板块头像质量问题，配置后共同进步板块的头像会添加该后缀（请确保你的图片加上 hundredSuffix 的配置后依然可以访问）。 例如:hundredSuffix: &quot;!w120&quot;\n\n\nlink_list\n【必须】友链列表\n\n\nlink_list.name\n【必须】友链名称\n\n\nlink_list.link\n【必须】友链链接\n\n\nlink_list.avatar\n【必须】友链头像\n\n\nlink_list.descr\n【必须】友链描述\n\n\nlink_list.siteshot\n【可选】flink_style 为 flexcard 或 telescopic 时友链的站点图片\n\n\nlink_list.recommend\n【可选】快捷选项，等于color:&quot;&quot; + tag: &quot;荐&quot;\n\n\nlink_list.tag\n【可选】左上角的 tag，为当前友链打上标签 例如:“推荐”\n\n\nlink_list.color\n【可选】tag 的十六进制背景颜色例如: “#646cff”，提供了两个快捷颜色选项分别是vip和speed\n\n\n\n当友链数目超过 50 以后会触发，与博主共同进步板块，可以自行配置 hundredSuffix: &quot;!w120&quot;,该参数可以解决共同进步板块头像质量问题，配置后共同进步板块的头像会添加该后缀。\n与数百博主共同进步：\n在主题配置文件中_config.anzhiyu.yml中配置\n# 友情链接顶部相关配置linkPageTop:  enable: true  title: 与数百名博主无限进步  # 添加博主友链的评论自定义格式  addFriendPlaceholder: \"昵称（请勿包含博客等字样）：\\n网站地址（要求博客地址，请勿提交个人主页）：\\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\\n描述：\\n站点截图（可选）：\\n\"\n 关于页面\n在 Hexo 博客根目录下打开终端，输入\nhexo new page about\n找到 source/about/index.md 这个文件并修改，添加type: &quot;about&quot;\n---title: 关于date: 2023-09-20 17:27:52aside: falsetop_img: falsebackground: \"#f8f9fe\"comments: falsetype: \"about\"---\n新建source/_data/about.yml，输入以下默认示例内容\n- class_name: 关于页  subtitle: 活在当下，及时摸鱼✨  avatarImg: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309191709924.jpg  name: saltedfish  description: 是一条咸鱼  aboutsiteTips:    tips: 追求    title1: 源于    title2: 热爱而去 感受    word:      - 学习      - 生活      - 二次元      - 游戏  helloAbout: Hello there!  skillsTips:    tips: 技能    title: 开启创造力  careers:    tips: 生涯    title: 无限进步    item:      - EDU,计算机工程专业    img: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309210156942.gif  statistic:    link: /archives    text: 文章隧道    cover: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309201812230.png  map:    title: 我现在住在    StrengthenTitle: 美国，纽约    background: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309192319650.png    backgroundDark: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309192319650.png  selfInfo:    selfInfoTips1: 生于    selfInfoContentYear: 2001    selfInfoTips2: 纽约大学    selfInfoContent2: 计算机工程    selfInfoTips3: 现在职业    selfInfoContent3: 苦逼学生👨‍🎓  personalities:    author_name: 物流师    personality_type: ISTJ-T    photo_url: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309192305203.png    personality_img: https://www.16personalities.com/static/images/personality-types/avatars/istj-logistician.svg    name_url: https://www.16personalities.com/istj-personality  maxim:    maxim_tips: 座右铭    maxim_top: 活在当下，    maxim_bottom: 及时摸鱼。  buff:    buff_tips: 特长    buff_top: 喜欢且擅长摸鱼的 咸鱼    buff_bottom: 二次元指数 MAX  game:    game_tips: 爱好游戏    game_title: 原神    game_uid: \"UID: 185137348\"    game_bg: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309192310493.jpg  comic:    comic_tips: 爱好番剧    comic_title: 追番    comic_list:      - name: 约定的梦幻岛        href: https://www.bilibili.com/bangumi/media/md5267750/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1        cover: https://bu.dusays.com/2023/05/27/647166c44b414.webp      - name: 咒术回战        href: https://www.bilibili.com/bangumi/media/md28229899/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1        cover: https://bu.dusays.com/2023/05/24/646db4398832e.webp      - name: 紫罗兰永恒花园        href: https://www.bilibili.com/bangumi/media/md8892/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1        cover: https://bu.dusays.com/2023/05/24/646db43983d99.webp      - name: 鬼灭之刃        href: https://www.bilibili.com/bangumi/media/md22718131/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1        cover: https://bu.dusays.com/2023/05/24/646db439856a0.webp      - name: JOJO的奇妙冒险 黄金之风        href: https://www.bilibili.com/bangumi/media/md135652/?spm_id_from=666.25.b_6d656469615f6d6f64756c65.1        cover: https://bu.dusays.com/2023/05/30/64760e38d651a.webp  like:    like_tips: 关注偏好    like_title: 二次元    like_bg: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309232100891.jpg    like_bottom: Galgame、动漫  music:    music_tips: 音乐偏好    music_title: 华语、纯音乐、动漫音乐    music_bg: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309192327740.png    music_link: /music/?id=444551276&amp;server=netease  reward_list:    # - name: muyui    #   amount: 6.0    #   datatime: 2023-09-21    # - name: LK66    #   amount: 66.6    #   datatime: 2023-03-24    # - name: 张时貳    #   amount: 6.6    #   datatime: 2023-01-22    # - name: ZeroAf    #   amount: 9.9    #   datatime: 2022-12-14    # - name: LuckyWangXi    #   amount: 6.6    #   datatime: 2022-12-14    # - name: 刀中日月长    #   amount: 10    #   datatime: 2022-11-16    # - name: 鹿啵包    #   amount: 10    #   datatime: 2022-11-08    # - name: 疾速k    #   amount: 50    #   datatime: 2022-09-20    # - name: 伴舟先生大霖子    #   amount: 4.03    #   datatime: 2022-10-27    #   suffix: 贝壳    # - name: Magica_0x0    #   amount: 3.36    #   datatime: 2022-10-07    #   suffix: 贝壳    # - name: 名字就是要短像这样    #   amount: 3.36    #   datatime: 2022-08-25    #   suffix: 贝壳    # - name: Leviathan520    #   amount: 1.34    #   datatime: 2022-08-23    #   suffix: 贝壳    # - name: 托马斯    #   amount: 10    #   datatime: 2022-08-19    # - name: 哇是猫猫欸    #   amount: 1.34    #   datatime: 2022-08-19    #   suffix: 贝壳  extra: false\n\n\n\n参数\n备选值/类型\n解释\n\n\n\n\nclass_name\n关于页\n【必须】页面类\n\n\nsubtitle\nstring\n【必须】副标题\n\n\navatarImg\nurl\n【必须】头像链接\n\n\nname\nstring\n【必须 作者名称\n\n\ndescription\nstring\n【必须】描述\n\n\naboutsiteTips\nobject\n【必须】站点关于提示相关配置\n\n\naboutsiteTips.tips\nstring\n【必须】站点关于提示性文字\n\n\naboutsiteTips.title1\nstring\n【必须】站点关于标题文字 1\n\n\naboutsiteTips.title2\nstring\n【必须】站点关于标题文字 2\n\n\naboutsiteTips.word\nlist\n【必须】站点关于标题滚动文字\n\n\nhelloAbout\nstring\n【必须】hello 文字\n\n\nskillsTips\nobject\n【必须】技能相关配置\n\n\nskillsTips.tips\nstring\n【必须】技能提示文字\n\n\nskillsTips.title\nstring\n【必须】技能标题\n\n\ncareers\nobject\n【必须】生涯相关配置\n\n\ncareers.tips\nstring\n【必须】生涯提示性文字\n\n\ncareers.title\nstring\n【必须】生涯标题\n\n\ncareers.list\nlist\n【可选】生涯 item\n\n\ncareers.list.desc\nstring\n【可选】生涯 item 描述\n\n\ncareers.list.color\nstring\n【可选】生涯 item 圆圈颜色\n\n\ncareers.img\nstring\n【必须】生涯底部图片\n\n\nstatistic\nobject\n【必须】统计数据相关配置\n\n\nstatistic.link\nurl\n【必须】统计数据按钮前往链接\n\n\nstatistic.text\nstring\n【必须】统计数据按钮文字\n\n\nmap\nobject\n【必须】地图相关配置\n\n\nmap.title\nstring\n【必须】地图标题\n\n\nmap.StrengthenTitle\nstring\n【必须】地图大标题\n\n\nmap.background\nurl\n【必须】地图亮色模式背景\n\n\nmap.backgroundDark\nurl\n【必须】地图暗色模式背景\n\n\nselfInfo\nobject\n【必须】作者相关信息配置\n\n\nselfInfo.selfInfoTips1\nstring\n【必须】作者相关提示文字 1\n\n\nselfInfo.selfInfoContentYear\nnumber\n【必须】作者生日年份\n\n\nselfInfo.selfInfoTips2\nstring\n【必须】作者相关提示文字 2\n\n\nselfInfo.selfInfoContent2\nstring\n【必须】作者相关内容 2\n\n\nselfInfo.selfInfoTips3\nstring\n【必须】作者相关提示文字 3\n\n\nselfInfo.selfInfoContent3\nstring\n【必须】作者相关内容 3\n\n\npersonalities\nobject\n【必须】作者性格相关配置\n\n\npersonalities.author_name\nstring\n【必须】作者性格名称\n\n\npersonalities.personality_type\nstring\n【必须】作者性格类型\n\n\npersonalities.photo_url\nurl\n【必须】作者自拍图片\n\n\npersonalities.personality_img\nurl\n【必须】作者性格表述图片\n\n\npersonalities.name_url\nurl\n【必须】点击性格跳转到链接\n\n\nmaxim\nobject\n【必须】座右铭相关配置\n\n\nmaxim.maxim_tips\nstring\n【必须】座右铭相关提示文字\n\n\nmaxim.maxim_top\nstring\n【必须】座右铭相关顶部文字\n\n\nmaxim.maxim_bottom\nstring\n【必须】座右铭相关底部文字\n\n\nbuff\nobject\n【必须】特长相关配置\n\n\nbuff.buff_tips\nstring\n【必须】特长相关提示文字\n\n\nbuff.buff_top\nstring\n【必须】特长相关顶部文字\n\n\nbuff.buff_bottom\nstring\n【必须】特长相关底部文字\n\n\ngame\nobject\n【必须】爱好游戏相关配置\n\n\ngame.game_tips\nstring\n【必须】爱好游戏提示文字\n\n\ngame.game_title\nstring\n【必须】爱好游戏标题\n\n\ngame.game_uid\nstring\n【必须】爱好游戏 uid\n\n\ngame.game_bg\nurl\n【必须】爱好游戏背景\n\n\ncomic\nobject\n【必须】追番相关配置，需要 5 条数据\n\n\ncomic.comic_tips\nstring\n【必须】追番相关提示文字\n\n\ncomic.comic_title\nstring\n【必须】追番相关标题\n\n\ncomic.comic_list\nlist\n【必须】追番相关列表\n\n\ncomic.comic_list.name\nstring\n【必须】追番 item 名称\n\n\ncomic.comic_list.href\nurl\n【必须】追番 item 链接\n\n\ncomic.comic_list.cover\nurl\n【必须】追番 item 的 cover\n\n\nlike\nobject\n【必须】关注偏好相关配置\n\n\nlike.like_tips\nstring\n【必须】关注偏好配置提示文字\n\n\nlike.like_title\nstring\n【必须】关注偏好配置标题\n\n\nlike.like_bg\nurl\n【必须】关注偏好配置背景\n\n\nlike.like_bottom\nstring\n【必须】关注偏好配置底部文字\n\n\nmusic\nobject\n【必须】音乐偏好相关配置\n\n\nmusic.music_tips\nstring\n【必须】音乐偏好提示性文字\n\n\nmusic.music_title\nstring\n【必须】音乐偏好标题\n\n\nmusic.music_bg\nurl\n【必须】音乐偏好背景\n\n\nmusic.music_link\nurl\n【必须】音乐偏好按钮链接\n\n\nreward_list\nobject\n【可选】打赏相关配置，如果不配置将没有打赏模块\n\n\nreward_list.name\nstring\n【必须】打赏 item 名称\n\n\nreward_list.amount\nnumber\n【必须】打赏 item 金额\n\n\nreward_list.datatime\nDate\n【必须】打赏 item 时间\n\n\nreward_list.suffix\nstring/元\n【可选】打赏 item 后缀（默认元）\n\n\n\n在主题配置页面修改51a统计配置。\n# 51a统计配置LA:  enable: true  ck:  LingQueMonitorID:\n 相册页面\n在 Hexo 博客根目录下打开终端，输入\nhexo new page album\n找到 source/album/index.md 这个文件并修改，添加type: &quot;album&quot;\n---title: 相册date: 2023-09-20 18:22:20aside: falsetop_img: falsetype: \"album\"top_background: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309201832810.jpg---\n新建文件[blog]\\source\\_data\\album.yml,没有_data文件夹的话也请自己新建。打开[blog]\\source\\_data\\album.yml，输入\n- class_name: 记录日常  path_name: /dailyphoto  type: 1  description: 生活小美好  cover: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309201908167.jpg  top_background: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309201909596.png  rowHeight: 220  # limit: 10  lazyload: true  btnLazyload: true  url: false  album_list:    - date: 2023-09-17      content: 纽约的时报广场。      address: 美国纽约      from:      image:        - https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309201859503.JPG- class_name: 精选壁纸  path_name: /wallpaper  type: 1  description: 不一定精，但我选了  cover: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309201849058.png  top_background: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309201948620.png  rowHeight: 220  # limit: 10  lazyload: true  btnLazyload: true  url: false  album_list:    - date: 2023-09-20      content: 点兔1      image:        - https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309201852668.png    - date: 2023-09-20      content: 点兔2      image:        - https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309200150263.png- class_name: 文章封面  path_name: /postscover  type: 1  description: 文章的封面，康康你的  cover: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309201954794.jpg  top_background: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309201954794.jpg  rowHeight: 220  # limit: 10  lazyload: true  btnLazyload: true  url: false  album_list:    - date: 2023-09-20      content: Hexo搭建个人网站      image:        - https://xiansakana.oss-cn-beijing.aliyuncs.com/img/202309210911702.png\n\n\n\n参数\n备选值/类型\n解释\n\n\n\n\nclass_name\nstring\n【必须】页面类\n\n\npath_name\nurl\n【必须】当前相册路径\n\n\ntype\nnumber\n【必须】当前相册页面样式类型\n\n\ndescription\nstring\n【必须】当前相册描述\n\n\ncover\nurl\n【必须】当前相册 cover 图片\n\n\ntop_background\nurl\n【可选】当前相册顶部 banner 图片，可以不填，主题版本需要 1.4.1 或以上\n\n\nrowHeight\nnumber\n【可选】仅当 type 为 2 时有效，当前相册 rowHeight\n\n\nlimit\nnumber\n【可选】仅当 type 为 2 时有效，当前相册 一次懒加载的数量\n\n\nlazyload\nboolean\n【可选】仅当 type 为 2 时有效，当前相册 lazyload 是否开启懒加载，默认懒加载为滚动懒加载，type 为 1 时懒加载不可关闭。\n\n\nbtnLazyload\nboolean\n【可选】仅当 type 为 2 且 lazyload 开启 时有效，当前相册 lazyload 懒加载的方式，默认为滚动懒加载，开启本选项后为按钮点击懒加载。\n\n\nalbum_list\nlist\n【必须】当前相册内图片列表\n\n\nurl\nurl\n【可选】仅当 type 为 2 时有效，可以加载远程的 json 数据。\n\n\nalbum_list.date\ndate\n【必须】当前图片创建时间\n\n\nalbum_list.content\nstring\n【必须】当前图片描述内容\n\n\nalbum_list.image\nlist\n【必须】当前图片集，可以多张\n\n\nalbum_list.from\nstring\n【可选】当前图片的创建人，未填写则不显示\n\n\nalbum_list.address\nstring\n【必须】当前图片地址\n\n\n\n由于相册页面需要很多的 page，所以在写数据的时候自行写入路径path_name，示例数据中有三个path_name，所以需要再创建两个页面，注意新建的页面必须与path_name一致。\nhexo new page dailyphotohexo new page wallpaperhexo new page postscover\n找到 source/dailyphoto/index.md 和source/wallpaper/index.md以及source/postscover/index.md三个文件，为相册集详情页，需要加上type: &quot;album_detail&quot;。\n---title: dailyphotodate: 2023-09-20 19:12:48aside: falsetop_img: falsetype: \"album_detail\"---\n---title: wallpaperdate: 2023-09-20 19:12:58aside: falsetop_img: falsetype: \"album_detail\"---\n---title: postscoverdate: 2023-09-20 19:13:07aside: falsetop_img: falsetype: \"album_detail\"---\n 朋友圈页面\n\n友链朋友圈后端部署文档 项目地址: https://github.com/Rock-Candy-Tea/hexo-circle-of-friends\n\n请注意朋友圈部署有一定难度，博主使用的为 server 部署，拉取后端代码后可将代码内的默认值改为自己的站点，theme 改为 common2，注意一定要使用common2，否则将无法拉取到自己的友链。\n在 Hexo 博客根目录下打开终端，输入\nhexo new page fcircle\n找到 source/fcircle/index.md 这个文件并修改，添加type: &quot;fcircle&quot;\n---title: 朋友圈date: 2023-09-20 20:19:40comments: falseaside: falsetop_img: falsetype: \"fcircle\"---\n主题配置文件中开启friends_vue.enable，自行设置朋友圈后端地址和顶部模块背景，注意缩进！！！\n# 朋友圈配置friends_vue:  enable: false  vue_js: https://npm.elemecdn.com/anzhiyu-theme-static@1.1.2/friends/index.f9a2b8d2.js  apiurl: # 朋友圈后端地址  top_background:\n\n\n\n参数\n备选值/类型\n解释\n\n\n\n\nenable\nboolean\n【必须】是否启用\n\n\nvue_js\nurl\n【必须】朋友圈前端构建后的 url\n\n\napiurl\nstring\n【必须】朋友圈后端 url\n\n\ntop_background\nurl\n【可选】朋友圈顶部背景图\n\n\n\n其中vue_js参数，可以将https://npm.elemecdn.com/anzhiyu-theme-static@1.1.2/friends/index.f9a2b8d2.js下载下来后将其中的 friends.anheyu.com替换为您的后端 url 然后上传至您的存储端以 url 的形式使用。\n原前端项目地址：hexo-circle-of-friends-front，也可以自行下载项目后，修改代码中的 url 变量路径friends.anheyu.com为你自己的，然后执行npm run build构建使用，\n\n注意\n朋友圈后端爬取需使用common2，否则无法爬取到友链数据。\n\n 音乐馆页面\n在 Hexo 博客根目录下打开终端，输入\nhexo new page music\n找到 source/music/index.md 这个文件并修改，添加type: &quot;music&quot;\n---title: 音乐date: 2023-09-20 20:43:19type: \"music\"aplayer: truetop_img: falsecomments: falseaside: false---\nhexo 配置文件_config.yml中添加以下配置，注意不是主题配置文件\n# APlayer# https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.mdaplayer:  meting: true  asset_inject: false\n将menu中音乐馆的路径修改为以下格式即可/music/?id=444551276&amp;server=netease，支持id和server参数。id 与 server 的填写请参考MetingJS。\nmenu:  文章:    隧道: /archives/ || anzhiyu-icon-box-archive    分类: /categories/ || anzhiyu-icon-shapes    标签: /tags/ || anzhiyu-icon-tags  友链:    友人帐: /link/ || anzhiyu-icon-link    朋友圈: /fcircle/ || anzhiyu-icon-artstation    留言板: /comments/ || anzhiyu-icon-envelope  我的:    音乐馆: /music/?id=444551276&amp;server=netease || anzhiyu-icon-music    追番页: /bangumis/ || anzhiyu-icon-bilibili    相册集: /album/ || anzhiyu-icon-images    小空调: /air-conditioner/ || anzhiyu-icon-fan  关于:    关于本人: /about/ || anzhiyu-icon-paper-plane    闲言碎语: /essay/ || anzhiyu-icon-lightbulb    随便逛逛: javascript:toRandomPost() || anzhiyu-icon-shoe-prints1\n 404 页面\n主题内置了一个简单的 404 页面，可在主题配置文件中开启，background 可自行设置。\n\n本地预览时，访问出错的网站是不会跳到 404 页面的。 如需本地预览，请访问 http://localhost:4000/404.html\n\n# A simple 404 pageerror_404:  enable: true  subtitle: \"Page Not Found\"  background: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309202100487.jpg\n 追番页面\n参考链接：https://github.com/HCLonely/hexo-bilibili-bangumi\n在博客根目录执行\nnpm install hexo-bilibili-bangumi --save\n在 hexo 配置文件_config.yml中加入以下配置，注意不是主题配置文件，更多配置请参考hexo-bilibili-bangumi。\n# 追番插件# https://github.com/HCLonely/hexo-bilibili-bangumibangumi: # 追番设置  enable: true  source: bili  path:  vmid: 378412924  title: \"追番列表\"  quote: \"生命不息，追番不止！\"  show: 1  lazyload: false  loading:  showMyComment: false  pagination: false  metaColor:  color:  webp:  progress:  extraOrder:  proxy:    host: \"代理host\"    port: \"代理端口\"  extra_options:    top_img: false    lazyload:      enable: false\n\n注意\n\n在hexo generate或hexo deploy之前使用hexo bangumi -u命令更新追番数据，使用hexo cinema -u命令更新追剧数据！\n删除数据命令:hexo bangumi -d/hexo cinema -d\n\n\n 留言板页面\n在博客根目录执行\nnpm install hexo-butterfly-envelope --save\n在站点配置文件_config.yml 中添加以下内容配置，更多配置请查看信笺样式留言板。\n#envelope_comment#seehttps://akilar.top/posts/e2d3c450/envelope_comment:  enable: true #控制开关  custom_pic:    cover: https://npm.elemecdn.com/hexo-butterfly-envelope/lib/violet.jpg #信笺头部图片    line: https://npm.elemecdn.com/hexo-butterfly-envelope/lib/line.png #信笺底部图片    beforeimg: https://npm.elemecdn.com/hexo-butterfly-envelope/lib/before.png # 信封前半部分    afterimg: https://npm.elemecdn.com/hexo-butterfly-envelope/lib/after.png # 信封后半部分  message: #信笺正文，多行文本，写法如下    - 有什么想问的？    - 有什么想说的？    - 有什么想吐槽的？    - 哪怕是有什么想吃的，都可以告诉我哦~  bottom: 自动书记人偶竭诚为您服务！ #仅支持单行文本  height: #1024px，信封划出的高度  path: #【可选】comments 的路径名称。默认为 comments，生成的页面为 comments/index.html  front_matter: #【可选】comments页面的 front_matter 配置    title: 留言板    comments: true    top_img: false    type: envelope\n Front-matter 的基本认识\nFront-matter 是 markdown 文件最上方以 --- 分隔的区域，用于指定个别档案的变数。其中又分为两种 markdown 里\n\nPage Front-matter 用于页面配置\nPost Front-matter 用于文章页配置\n\n\n如果标注可选的参数，可根据自己需要添加，不用全部都写在 markdown 里\n\nPage Front-matter\ntitle:date:updated:type:comments:description:keywords:top_img:mathjax:katex:aside:aplayer:highlight_shrink:\n\n\n\n写法\n解释\n\n\n\n\ntitle\n【必需】页面标题\n\n\ndate\n【必需】页面创建日期\n\n\ntype\n【必需】标签、分类、关于、音乐馆、友情链接、相册、相册详情、朋友圈、即刻页面需要配置\n\n\nupdated\n【可选】页面更新日期\n\n\ndescription\n【可选】页面描述\n\n\nkeywords\n【可选】页面关键字\n\n\ncomments\n【可选】显示页面评论模块(默认 true)\n\n\ntop_img\n【可选】页面顶部图片\n\n\nmathjax\n【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)\n\n\nkatex\n【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)\n\n\naside\n【可选】显示侧边栏 (默认 true)\n\n\naplayer\n【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置\n\n\nhighlight_shrink\n【可选】配置代码框是否展开(true/false)(默认为设置中 highlight_shrink 的配置)\n\n\n\nPost Front-matter\ntitle:date:updated:tags:categories:keywords:description:top_img:comments:cover:toc:toc_number:toc_style_simple:copyright:copyright_author:copyright_author_href:copyright_url:copyright_info:mathjax:katex:aplayer:highlight_shrink:aside:swiper_index: 1top_group_index: 1background: \"#fff\"\n\n\n\n写法\n解释\n\n\n\n\ntitle\n【必需】文章标题\n\n\ndate\n【必需】文章创建日期\n\n\nupdated\n【可选】文章更新日期\n\n\ntags\n【可选】文章标签\n\n\ncategories\n【可选】文章分类\n\n\nkeywords\n【可选】文章关键字\n\n\ndescription\n【可选】文章描述\n\n\ntop_img\n【可选】文章顶部图片\n\n\ncover\n【可选】文章缩略图(如果没有设置 top_img,文章页顶部将显示缩略图，可设为 false/图片地址/留空)\n\n\ncomments\n【可选】显示文章评论模块(默认 true)\n\n\ntoc\n【可选】显示文章 TOC(默认为设置中 toc 的 enable 配置)\n\n\ntoc_number\n【可选】显示 toc_number(默认为设置中 toc 的 number 配置)\n\n\ntoc_style_simple\n【可选】显示 toc 简洁模式\n\n\ncopyright\n【可选】显示文章版权模块(默认为设置中 post_copyright 的 enable 配置)\n\n\ncopyright_author\n【可选】文章版权模块的文章作者\n\n\ncopyright_author_href\n【可选】文章版权模块的文章作者链接\n\n\ncopyright_url\n【可选】文章版权模块的文章链接链接\n\n\ncopyright_info\n【可选】文章版权模块的版权声明文字\n\n\nmathjax\n【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)\n\n\nkatex\n【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)\n\n\naplayer\n【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置\n\n\nhighlight_shrink\n【可选】配置代码框是否展开(true/false)(默认为设置中 highlight_shrink 的配置)\n\n\naside\n【可选】显示侧边栏 (默认 true)\n\n\nswiper_index\n【可选】首页轮播图配置 index 索引，数字越小越靠前\n\n\ntop_group_index\n【可选】首页右侧卡片组配置, 数字越小越靠前\n\n\nbackground\n【可选】文章背景可配置为 16 进制颜色值\n\n\nai\n【可选】文章 ai 摘要\n\n\nmain_color\n【可选】文章主色，必须是 16 进制颜色且有 6 位，不可缩减，例如#ffffff 不可写成#fff\n\n\n\n\n首页轮播图配置: swiper_index, 数字越小越靠前\n首页卡片配置: top_group_index, 数字越小越靠前\npage 中background, 可配置为 16 进制颜色值\n\n\n只需要在你的文章顶部的Front-matter配置这swiper_index和top_group_index两个字段即可显示轮播图和推荐卡片。\n\n 站点配置\n 网站资料\n修改网站各种资料，例如标题、副标题和邮箱等个人资料，修改博客根目录的_config.yml，注意如果需要适配 pjax 必须填写description字段，以保证需要重载的 dom 数量一致。语言支持zh-CN (简体中文)，zh-TW (繁体中文)和en(English)。\ntitle: saltedfishsubtitle: \"fishpond\"description: \"这有关于学习、生活、游戏等的各种阿巴阿巴，还有蹩脚的知识和技术。希望这里有能带给你帮助的知识和内容。\"keywords:author: saltedfishlanguage: zh-CNtimezone: \"America/New_York\"\n 导航配置\n修改 主题配置文件\nmenu:  文章:    隧道: /archives/ || anzhiyu-icon-box-archive    分类: /categories/ || anzhiyu-icon-shapes    标签: /tags/ || anzhiyu-icon-tags  友链:    友人帐: /link/ || anzhiyu-icon-link    朋友圈: /fcircle/ || anzhiyu-icon-artstation    留言板: /comments/ || anzhiyu-icon-envelope  我的:    音乐馆: /music/?id=444551276&amp;server=netease || anzhiyu-icon-music    追番页: /bangumis/ || anzhiyu-icon-bilibili    相册集: /album/ || anzhiyu-icon-images    小空调: /air-conditioner/ || anzhiyu-icon-fan  关于:    关于本人: /about/ || anzhiyu-icon-paper-plane    闲言碎语: /essay/ || anzhiyu-icon-lightbulb    随便逛逛: javascript:toRandomPost() || anzhiyu-icon-shoe-prints1\n必须是 /xxx/，后面||分开，然后写图标名。如果不希望显示图标，图标名可不写。\n 导航栏设置\n在 主题配置文件\n# nav相关配置nav:  enable: true  travelling: true  clock: true  menu:    - title: 网页      item:        - name: 博客          link: https://xiansakana.xyz          icon: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309191743806.gif    - title: 项目      # item:      #   - name: 安知鱼图床      #     link: https://image.anheyu.com/      #     icon: https://image.anheyu.com/favicon.ico\n\n\n\n参数\n解释\n\n\n\n\nenable\n是否启用 nav 左侧项目按钮，仅控制左侧项目按钮\n\n\ntravelling\n是否启用 nav 开往按钮\n\n\nclock\n是否启用 nav 左侧和风天气\n\n\nmenu\nnav 左侧项目按钮内的菜单\n\n\nmenu.title\nnav 左侧项目按钮内的菜单标题\n\n\nmenu.item\nnav 左侧项目按钮内的菜单项\n\n\nmenu.item.name\nnav 左侧项目按钮内的菜单项标题\n\n\nmenu.item.link\nnav 左侧项目按钮内的菜单项链接\n\n\nmenu.item.icon\nnav 左侧项目按钮内的菜单项图标\n\n\n\n 代码块配置\n\n代码块中的所有功能只适用于 Hexo 自带的代码渲染 如果使用第三方的渲染器，不一定会有效\n\n代码高亮主题\nAnZhiYu 支持 6 种代码高亮样式：\n\ndarker\npale night\nlight\nocean\nmac\nmac light\n\n修改 主题配置文件\nhighlight_theme: mac\n代码复制\n主题支持代码复制功能，修改 主题配置文件\nhighlight_copy: true\n代码框展开/关闭\n在默认情况下，代码框自动展开，可设置是否所有代码框都关闭状态，点击&gt;可展开代码\n\ntrue 全部代码框不展开，需点击&gt;打开\nfalse 代码框展开，有&gt;点击按钮\nnone 不显示&gt;按钮\n\n修改 主题配置文件\nhighlight_shrink: false\n\n你也可以在 post/page 页对应的 markdown 文件 front-matter 添加 highlight_shrink 来独立配置。\n当主题配置文件中的 highlight_shrink 设为 true 时，可在 front-matter 添加 highlight_shrink: false 来单独配置文章展开代码框。\n当主题配置文件中的 highlight_shrink 设为 false 时，可在 front-matter 添加 highlight_shrink: true 来单独配置文章收缩代码框。\n\n代码换行\n在默认情况下，Hexo 在编译的时候不会实现代码自动换行。如果你不希望在代码块的区域里有横向滚动条的话，那么你可以考虑开启这个功能。\n修改 主题配置文件\ncode_word_wrap: true\n如果你是使用 highlight 渲染，需要找到你站点的 Hexo 配置文件_config.yml，将 line_number 改成 false:\nhighlight:  enable: true  line_number: false # &lt;- 改这里  auto_detect: false  tab_replace: \"\"\n如果你是使用 prismjs 渲染，需要找到你站点的 Hexo 配置文件_config.yml，将 line_number 改成 false:\nprismjs:  enable: false  preprocess: true  line_number: false # &lt;- 改这里  tab_replace: \"\"\n代码高度限制\n可配置代码高度限制，超出的部分会隐藏，并显示展开按钮，默认 330，可配置为 false。\nhighlight_height_limit: false # unit: px\n注意：\n\n单位是 px，直接添加数字，如 200\n实际限制高度为 highlight_height_limit + 30 px ，多增加 30px 限制，目的是避免代码高度只超出 highlight_height_limit 一点时，出现展开按钮，展开没内容\n不适用于隐藏后的代码块（ css 设置 display: none）\n\n 图标配置\nAnZhiYu 支持 阿里图标 (需配置自己的图标)，与 font-awesome v6 图标(需开启fontawesome)，使用阿里图标需配置主题配置文件中icon.ali_iconfont_js字段，默认内置部分图标，修改主题配置文件，视频教程: 安知鱼主题社交图标配置。\nicons:  ali_iconfont_js: # 阿里图标symbol 引用链接，主题会进行加载 symbol 引用  fontawesome: true #是否启用fontawesome6图标  fontawesome_animation_css: #fontawesome_animation 如果有就会加载，示例值：https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/https://assets.saoyu.fun/font-awesome-animation.min.css\n使用方法，将图标库中的图标名复制，然后加上前缀anzhiyu-即可，比如icon-github图标，则为anzhiyu-icon-github。\n社交图标，书写格式 名称：url || 描述性文字 || icon名称\n# social settings (社交图标设置)# formal:#   name: link || iconsocial:  Github: https://github.com/xiansakana || anzhiyu-icon-github  BiliBili: https://space.bilibili.com/378412924 || anzhiyu-icon-bilibili  Email: https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2461298052@qq.com || anzhiyu-icon-envelope  RSS: atom.xml || anzhiyu-icon-rss  QQ: tencent://Message/?Uin=2461298052&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes || anzhiyu-icon-qq  Netease: https://music.163.com/#/user/home?id=319573953 || anzhiyu-icon-music\n 顶部图\n如果不要显示顶部图，可直接配置 disable_top_img: true\n顶部图的获取顺序，如果都没有配置，则不显示顶部图。\n\n\n页面顶部图的获取顺序：\n各自配置的 top_img &gt; 配置文件的 default_top_img\n\n\n文章页顶部图的获取顺序：\n各自配置的 top_img &gt; cover &gt; 配置文件的 default_top_img\n\n\n配置中的值：\n\n\n\n配置\n解释\n\n\n\n\nindex_img\n主页的 top_img，示例值: index_img: “background: url() top / cover no-repeat”\n\n\ndefault_top_img\n默认的 top_img，当页面的 top_img 没有配置时，会显示 default_top_img\n\n\narchive_img\n归档页面的 top_img\n\n\ntag_img\ntag 子页面 的 默认 top_img\n\n\ntag_per_img\ntag 子页面的 top_img，可配置每个 tag 的 top_img\n\n\ncategory_img\ncategory 子页面 的 默认 top_img\n\n\ncategory_per_img\ncategory 子页面的 top_img，可配置每个 category 的 top_img\n\n\n\n其它页面 （tags/categories/自建页面）和 文章页 的 top_img ，请到对应的 md 页面设置 front-matter 中的 top_img\n以上所有的 top_img 可配置以下值\n\n\n\n配置的值\n效果\n\n\n\n\n留空\n显示默认的 top_img（如有），否则显示默认的顔色 （文章页 top_img 留空的话，会显示 cover 的值）\n\n\nimg 链接\n图片的链接，显示所配置的图片\n\n\n顔色( HEX 值 - #0000FF# RGB 值 - rgb(0,0,255) 顔色单词 - orange 渐变色 - linear-gradient( 135deg, #E2B0FF# 10%, #9F44D3# 100%)\n对应的顔色\n\n\ntransparent\n透明\n\n\nfalse\n不显示 top_img\n\n\n\n 文章封面\n文章的 markdown 文档上,在 Front-matter 添加 cover ,并填上要显示的图片地址。\n如果不配置 cover,可以设置显示默认的 cover。\n如果不想在首页显示 cover, 可以设置为 false。\n\n文章封面的获取顺序 Front-matter 的 cover &gt; 配置文件的 default_cover &gt; false\n\n修改 主题配置文件\ncover:  # 是否显示文章封面  index_enable: true  aside_enable: true  archives_enable: true  # 封面显示的位置  # 三个值可配置 left , right , both  position: both  # 当没有设置cover时，默认的封面显示  default_cover:\n\n\n\n参数\n解释\n\n\n\n\nindex_enable\n主页是否显示文章封面图\n\n\naside_enable\n侧栏是否显示文章封面图\n\n\narchives_enable\n归档页面是否显示文章封面图\n\n\nposition\n主页卡片文章封面的显示位置 - left：全部显示在左边 - right：全部显示在右边 - both：封面位置以左右左右轮流显示\n\n\ndefault_cover\n默认的 cover, 可配置图片链接/顔色/渐变色等\n\n\n\n当配置多张图片时,会随机选择一张作为 cover.此时写法应为\ndefault_cover:  - https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg.png  - https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg2.png  - https://file.crazywong.com/gh/jerryc127/CDN@latest/cover/default_bg3.png\n 文章 meta 配置\n这个选项是用来显示文章的相关信息的。\n修改 主题配置文件\npost_meta:  page: # Home Page    date_type: both # created or updated or both 主页文章日期是创建日或者更新日或都显示    date_format: date # date/relative/simple 显示日期还是相对日期 或者 简单日期    categories: true # true or false 主页是否显示分类    tags: true # true or false 主页是否显示标籤    label: true # true or false 显示描述性文字  post:    date_type: both # created or updated or both 文章页日期是创建日或者更新日或都显示    date_format: date # date/relative 显示日期还是相对日期    categories: true # true or false 文章页是否显示分类    tags: true # true or false 文章页是否显示标籤    label: true # true or false 显示描述性文字    unread: true # true or false 文章未读功能\n 文章版权\n为你的博客文章展示文章版权和许可协议。\n修改 主题配置文件\npost_copyright:  enable: true  decode: true  author_href:  license: CC BY-NC-SA 4.0  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/\n由于 Hexo 4.1 开始，默认对网址进行解码，以至于如果是中文网址，会被解码，可设置 decode: true 来显示中文网址。\n如果有文章（例如：转载文章）不需要显示版权，可以在文章 Front-matter 单独设置\ncopyright: false\n支持对单独文章设置版权信息，可以在文章 Front-matter 单独设置\ncopyright_author: xxxxcopyright_author_href: https://xxxxxx.comcopyright_url: https://xxxxxx.comcopyright_info: 此文章版权归xxxxx所有，如有转载，请注明来自原作者\n 文章打赏\n在你每篇文章的结尾，可以添加打赏按钮。相关二维码可以自行配置。\n对于没有提供二维码的，可配置一张软件的 icon 图片，然后在 link 上添加相应的打赏链接。用户点击图片就会跳转到链接去。\nlink 可以不写，会默认为图片的链接。coinAudio 为投币的音频。\n修改 主题配置文件\n# Sponsor/rewardreward:  enable: true  coinAudio: https://npm.elemecdn.com/akilar-candyhttps://assets.saoyu.fun@1.0.36/audio/aowu.m4a  QR_code:    - img: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309192233175.png      link:      text: 微信    - img: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309192233251.png      link:      text: 支付宝\n TOC\n在文章页，会有一个目录，用于显示 TOC。修改 主题配置文件。\ntoc:  post: true  page: true  number: true  expand: false  style_simple: false # for post\n\n\n\n属性\n解释\n\n\n\n\npost\n文章页是否显示 TOC\n\n\npage\n普通页面是否显示 TOC\n\n\nnumber\n是否显示章节数\n\n\nexpand\n是否展开 TOC\n\n\nstyle_simple\n简洁模式（侧边栏只显示 TOC, 只对文章页有效 ）\n\n\n\n为特定的文章配置\n在你的文章 md 文件的头部，加入 toc_number 和 toc，并配置 true 或者 false 即可。\n主题会优先判断文章 Markdown 的 Front-matter 是否有配置，如有，则以 Front-matter 的配置为准。否则，以主题配置文件中的配置为准。\n 相关文章\n\n当文章封面设置为 false 时，或者没有获取到封面配置，相关文章背景将会显示主题色。\n\n相关文章推荐的原理是根据文章 tags 的比重来推荐。\n修改 主题配置文件\nrelated_post:  enable: true  limit: 6 # 显示推荐文章数目  date_type: created # or created or updated 文章日期显示创建日或者更新日\n 文章过期提醒\n可设置是否显示文章过期提醒，以更新时间为基准。\n# Displays outdated notice for a post (文章过期提醒)noticeOutdate:  enable: true  style: flat # style: simple/flat  limit_day: 365 # When will it be shown  position: top # position: top/bottom  message_prev: It has been  message_next: days since the last update, the content of the article may be outdated.\nlimit_day： 距离更新时间多少天才显示文章过期提醒\nmessage_prev： 天数之前的文字\nmessage_next：天数之后的文字\n 文章编辑按钮\n在文章标题旁边显示一个编辑按钮，点击会跳转到对应的链接去。\n# Post edit# Easily browse and edit blog source code online.post_edit:  enable: false  # url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name/  # For example: https://github.com/jerryc127/butterfly.js.org/edit/main/source/  url:\n 文章分页按钮\n\n当文章封面设置为 false 时，或者没有获取到封面配置，分页背景将会显示主题色。\n\n可设置分页的逻辑，也可以关闭分页显示\n# post_pagination (分页)# value: 1 || 2 || false# 1: The 'next post' will link to old post# 2: The 'next post' will link to new post# false: disable paginationpost_pagination: 2\n\n\n\n参数\n解释\n\n\n\n\npost_pagination: false\n关闭分页按钮\n\n\npost_pagination: 1\n下一篇显示的是旧文章\n\n\npost_pagination: 2\n下一篇显示的是新文章\n\n\n\n 欢迎语配置\n在主题配置文件中开启功能\n# 欢迎语配置greetingBox:  enable: true #开启后必须配置下面的list对应的时间段，不然会出现小白条  default: 晚上好👋  list:    - greeting: 晚安😴      startTime: 0      endTime: 5    - greeting: 早上好鸭👋, 祝你一天好心情！      startTime: 5      endTime: 9    - greeting: 上午好👋, 状态很好，鼓励一下～      startTime: 9      endTime: 11    - greeting: 11点多啦, 在坚持一下就吃饭啦～      startTime: 11      endTime: 12    - greeting: 午安👋, 宝贝      startTime: 12      endTime: 14    - greeting: 🌈充实的一天辛苦啦！      startTime: 14      endTime: 19    - greeting: 19点喽, 奖励一顿丰盛的大餐吧🍔。      startTime: 19      endTime: 20    - greeting: 晚上好👋, 在属于自己的时间好好放松😌~      startTime: 20      endTime: 24\n 中控台\n主题配置文件中，默认为true\n# 中控台centerConsole: true\n当屏幕足够大的时候，就能够显示兴趣点、最近评论、时间归档、功能按键、音乐等内容。\n Footer 设置\nsince 是一个来展示你站点起始时间的选项。它位于页面的最底部。\n# Footer Settings# --------------------------------------footer:  owner:    enable: true    since: 2023  custom_text:  runtime:    enable: true    launch_time: 09/20/2023 00:00:00 # 网站上线时间    # work_img: https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg    # work_description: 距离月入25k也就还差一个大佬带我~    # offduty_img: https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg    # offduty_description: 下班了就该开开心心的玩耍，嘿嘿~  # 徽标部分配置项 https://shields.io/  # https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr  bdageitem:    enable: true    list:      - link: https://hexo.io/ #徽标指向网站链接        shields: https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg #徽标API        message: 博客框架为Hexo_v5.4.0 #徽标提示语      - link: https://blog.anheyu.com/        shields: https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg        message: 本站使用AnZhiYu主题      - link: https://www.dogecloud.com/        shields: https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg        message: 本站使用多吉云为静态资源提供CDN加速      - link: https://github.com/        shields: https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg        message: 本站项目由Github托管      - link: http://creativecommons.org/licenses/by-nc-sa/4.0/        shields: https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg        message: 本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可\n\n\n\n参数\n解释\n\n\n\n\nowner\n页脚网站所有者@2020-当前年份\n\n\nowner.enable\n页脚网站所有者是否启用\n\n\nowner.since\n页脚年份，控制台中打印的运行时间也来自这里\n\n\nruntime\n运行时间\n\n\nruntime.enable\n运行时间是否启用\n\n\nruntime.launch_time\n网站上线时间\n\n\nruntime.work_img\n页脚上班时间的徽标\n\n\nruntime.work_description\n页脚上班时间的 title 描述\n\n\nruntime.offduty_img\n页脚下班时间的徽标\n\n\nruntime.offduty_description\n页脚下班时间的 title 描述\n\n\nbdageitem\n徽标配置项\n\n\nbdageitem.link\n徽标配置链接\n\n\nbdageitem.shields\n徽标配置徽标\n\n\nbdageitem.message\n徽标配置徽标 title\n\n\n\nsocialBar和list用于展示你的社交按钮及站内部分导航，它位于页面的底部。\nsocialBar:  enable: true  centerImg:  left:    - title: email      link: mailto:2461298052@qq.com      icon: anzhiyu-icon-envelope    - title: 微博      link: https://weibo.com/u/5824741493      icon: anzhiyu-icon-weibo    - title: facebook      link: https://www.facebook.com/profile.php?id=61551327342211&amp;sk=about      icon: anzhiyu-icon-facebook1    - title: RSS      link: atom.xml      icon: anzhiyu-icon-rss  right:    - title: Github      link: https://github.com/xiansakana      icon: anzhiyu-icon-github    - title: Bilibili      link: https://space.bilibili.com/378412924      icon: anzhiyu-icon-bilibili    - title: Netease      link: https://music.163.com/#/user/home?id=319573953      icon: anzhiyu-icon-music    # - title: 抖音    #   link: https://v.douyin.com/DwCpMEy/    #   icon: anzhiyu-icon-tiktok    - title: CC      link: /copyright      icon: anzhiyu-icon-copyright-linelist:  enable: false  randomFriends: 3  project:    - title: 服务      links:        - title: 51la统计          link: https://v6.51.la/        - title: 十年之约          link: https://www.foreverblog.cn/        - title: 开往          link: https://github.com/travellings-link/travellings    - title: 主题      links:        - title: 文档          link: /docs/        - title: 源码          link: https://github.com/anzhiyu-c/hexo-theme-anzhiyu        - title: 更新日志          link: /update/    - title: 导航      links:        - title: 即刻短文          link: /essay/        - title: 友链文章          link: /fcircle/        - title: 留言板          link: /comments/    - title: 协议      links:        - title: 隐私协议          link: /privacy/        - title: Cookies          link: /cookies/        - title: 版权协议          link: /copyright/\n\n\n\n参数\n解释\n\n\n\n\ncenterImg\n页脚社交头像\n\n\nrandomFriends\n随机友链数量\n\n\n\nfooterbar指的是页脚最下面那一栏\nfooterBar:  enable: true  authorLink: /  cc:    enable: true    link: /copyright  linkList:    - link: https://github.com/anzhiyu-c/hexo-theme-anzhiyu      text: 主题    # - link: https://image.anheyu.com    #   text: 图床    # - link: https://beian.miit.gov.cn/    #   text: 湘ICP备-xxxxxxx号  subTitle:    enable: false    # Typewriter Effect (打字效果)    effect: true    # Effect Speed Options (打字效果速度参数)    startDelay: 300 # time before typing starts in milliseconds    typeSpeed: 150 # type speed in milliseconds    backSpeed: 50 # backspacing speed in milliseconds    # loop (循环打字)    loop: true    # source 调用第三方服务    # source: false 关闭调用    # source: 1  调用一言网的一句话（简体） https://hitokoto.cn/    # source: 2  调用一句网（简体） http://yijuzhan.com/    # source: 3  调用今日诗词（简体） https://www.jinrishici.com/    # subtitle 会先显示 source , 再显示 sub 的内容    source: 1    # 如果关闭打字效果，subtitle 只会显示 sub 的第一行文字    sub:      # - 生活明朗&amp;#44; 万物可爱&amp;#44; 人间值得&amp;#44; 未来可期.\n 侧边栏设置\n可自行决定哪个项目需要显示，可决定位置，也可以设置不显示侧边栏。\n修改 主题配置文件\naside:  enable: true  hide: false  button: true  mobile: true # display on mobile  position: right # left or right  display: # 控制对应详情页面是否显示侧边栏    archive: true    tag: true    category: true  card_author:    enable: true    description: # &lt;div style=\"line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);\"&gt;这有关于&lt;b style=\"color:#fff\"&gt;产品、设计、开发&lt;/b&gt;相关的问题和看法，还有&lt;b style=\"color:#fff\"&gt;文章翻译&lt;/b&gt;和&lt;b style=\"color:#fff\"&gt;分享&lt;/b&gt;。&lt;/div&gt;&lt;div style=\"line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);\"&gt;相信你可以在这里找到对你有用的&lt;b style=\"color:#fff\"&gt;知识&lt;/b&gt;和&lt;b style=\"color:#fff\"&gt;教程&lt;/b&gt;。&lt;/div&gt; # 默认为站点描述    name_link: /  card_announcement:    enable: true    content: 欢迎来看我的博客鸭~  card_weixin:    enable: false    face: https://bu.dusays.com/2023/01/13/63c02edf44033.png    backFace: https://bu.dusays.com/2023/05/13/645fa415e8694.png  card_recent_post:    enable: true    limit: 0 # if set 0 will show all    sort: date # date or updated    sort_order: # Don't modify the setting unless you know how it works  card_categories:    enable: true    limit: 0 # if set 0 will show all    expand: none # none/true/false    sort_order: # Don't modify the setting unless you know how it works  card_tags:    enable: true    limit: 0 # if set 0 will show all    color: true    sort_order: # Don't modify the setting unless you know how it works    highlightTags:      # - Hexo      # - 前端  card_archives:    enable: true    type: monthly # yearly or monthly    format: YYYY MMMM # eg: YYYY年MM月    order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending    limit: 0 # if set 0 will show all    sort_order: # Don't modify the setting unless you know how it works  card_webinfo:    enable: true    post_count: true    last_push_date: true    sort_order: # Don't modify the setting unless you know how it works\n 访问人数 busuanzi (UV 和 PV)\n访问 busuanzi 的官方网站查看更多的介绍。\n修改 主题配置文件\nbusuanzi:  site_uv: true  site_pv: true  page_pv: true\n如果需要修改 busuanzi 的 CDN 链接，可通过 主题配置文件 的 CDN 中的 option 进行修改\nCDN:  option:  \tbusuanzi: xxxxxxxxx\n 运行时间\n网页已运行时间\n修改 主题配置文件\n# Time difference between publish date and now (网页运行时间)# Formal: Month/Day/Year Time or Year/Month/Day Timeruntimeshow:  enable: true  publish_date: 2023/9/20 00:00:00\n 最新评论\n最新评论只会在刷新时才会去读取，并不会实时变化。\n由于 API 有 访问次数限制，为了避免调用太多，主题默认存取期限为 10 分钟。也就是説，调用后资料会存在 localStorage 里，10 分钟内刷新网站只会去 localStorage 读取资料。 10 分钟期限一过，刷新页面时才会去调取 API 读取新的数据。（ 配置 storage，可自行配置缓存时间）。\n在侧边栏显示最新评论板块\n修改 主题配置文件\n# Aside widget - Newest Commentsnewest_comments:  enable: true  sort_order: # Don't modify the setting unless you know how it works  limit: 6  storage: 10 # unit: mins, save data to localStorage  avatar: true\n\n\n\n配置\n解释\n\n\n\n\nlimit\n显示的数量\n\n\nstorage\n设置缓存时间，单位 分钟\n\n\navatar\n是否显示头像\n\n\n\n 右下角按钮\n简体繁体互换\n修改 主题配置文件\n# Conversion between Traditional and Simplified Chinese (简繁转换)translate:  enable: true  # The text of a button  default: 繁  # Right-click menu default text  rightMenuMsgDefault: \"轉為繁體\"  # the language of website (1 - Traditional Chinese/ 2 - Simplified Chinese）  defaultEncoding: 2  # Time delay  translateDelay: 0  # The text of the button when the language is Simplified Chinese  msgToTraditionalChinese: \"繁\"  # The text of the button when the language is Traditional Chinese  msgToSimplifiedChinese: \"简\"  # Right-click the menu to traditional Chinese  rightMenuMsgToTraditionalChinese: \"转为繁体\"  # Right-click menu to simplified Chinese  rightMenuMsgToSimplifiedChinese: \"转为简体\"\n阅读模式\n阅读模式下会去掉除文章外的内容，避免干扰阅读。\n只会出现在文章页面，右下角会有阅读模式按钮。\n修改 主题配置文件\nreadmode: true\n夜间模式\n右下角会有夜间模式按钮\n修改 主题配置文件\n# dark modedarkmode:  enable: true  # Toggle Button to switch dark/light mode  button: true  # Switch dark/light mode automatically (自动切换 dark mode和 light mode)  # autoChangeMode: 1  Following System Settings, if the system doesn't support dark mode, it will switch dark mode between 6 pm to 6 am  # autoChangeMode: 2  Switch dark mode between 6 pm to 6 am  # autoChangeMode: false  autoChangeMode: 1  # Set the light mode time. The value is between 0 and 24. If not set, the default value is 6 and 18  start: # 8  end: # 22\n\n\n\n参数\n解释\n\n\n\n\nbutton\n是否在右下角显示日夜模式切换按钮\n\n\nautoChangeMode\n自动切换的模式\n\n\nautoChangeMode\nautoChangeMode: 1 跟随系统而变化，不支持的浏览器/系统将按照时间 start 到 end 之间切换为 light mode autoChangeMode: 2 只按照时间 start 到 end 之间切换为 light mode ,其余时间为 dark mode autoChangeMode: false 取消自动切换\n\n\nstart\nlight mode 的开始时间\n\n\nend\nlight mode 的结束时间\n\n\n\n按钮排序\n# Don't modify the following settings unless you know how they work (非必要请不要修改 )# Choose: readmode,translate,darkmode,hideAside,toc,chat,comment# Don't repeat 不要重复rightside_item_order:  enable: false  hide: # readmode,translate,darkmode,hideAside  show: # toc,chat,comment\n 标签外挂\n标签外挂是 Hexo 独有的功能，并不是标准的 Markdown 格式。 以下的写法，只适用于 AnZhiYu 主题，用在其它主题上不会有效果，甚至可能会报错，使用前请留意。\n标签外挂虽然能为主题带来一些额外的功能和 UI 方面的强化，但是，标签外挂也有明显的限制，使用时请留意。\n只需要将标签写在 md 文件内即可使用，详细写法请阅读 安知鱼主题标签 Tag Plugins 查看。\n 分析统计\n百度统计的官方网站\n谷歌分析的官方网站\nCloudflare 分析的官方网站\nMicrosoft Clarity 的官方网站\n 广告\n谷歌广告\n主题已集成谷歌广告（自动广告）\n修改 主题配置文件\ngoogle_adsense:  enable: true  auto_ads: true  js: https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js  client: # 填入个人识别码  enable_page_level_ads: true\n手动广告配置\n主题预留了三个位置可供插入广告，分别为主页文章(每三篇文章出现广告)/aside 公告之后/文章页打赏之后。 把 html 代码填写到对应的位置。\n修改 主题配置文件\nad:  index:  aside:  post:\n例如：\nindex: &lt;ins class=\"adsbygoogle\" style=\"display:block\" data-ad-format=\"fluid\" data-ad-layout-key=\"xxxxxxxxxxxx\" data-ad-client=\"ca-pub-xxxxxxxxxx\" data-ad-slot=\"xxxxxxxxxx\"&gt;&lt;/ins&gt;&lt;script&gt;(adsbygoogle=window.adsbygoogle||[]).push(&#123;&#125;)&lt;/script&gt;\n 页面加载动画 preloader\n当进入网页时，因为加载速度的问题，可能会导致 top_img 图片出现断层显示，或者网页加载不全而出现等待时间，开启 preloader 后，会显示加载动画，等页面加载完，加载动画会消失。\n主题支持 pace.js 的加载动画，具体可查看 pace.js\n修改 主题配置文件，其中avatar可以自定义加载时的头像\n# Loading Animation (加载动画)preloader:  enable: true  # source  # 1. fullpage-loading  # 2. pace (progress bar)  # else all  source: 3  # pace theme (see https://codebyzach.github.io/pace/)  pace_css_url:  avatar: https://xiansakana.oss-cn-beijing.aliyuncs.com/img/202309191709924.jpg # 自定义头像\n 图片大图查看模式\n\n如果你并不想为某张图片添加大图查看模式，你可以使用 html 格式引用图片，併为图片添加 no-lightbox class 名。\n\n修改 主题配置文件\n# fancybox http://fancyapps.com/fancybox/3/fancybox: truemedium_zoom: false\n Pjax\n当用户点击链接，通过 ajax 更新页面需要变化的部分，然后使用 HTML5 的 pushState 修改浏览器的 URL 地址。\n这样可以不用重复加载相同的资源（css/js）， 从而提升网页的加载速度。\n# Pjax [Beta]# It may contain bugs and unstable, give feedback when you find the bugs.# https://github.com/MoOx/pjaxpjax:  enable: true  exclude:    - /music/    - /no-pjax/\n\n对于一些第三方插件，有些并不支持 pjax 。 你可以把网页加入到 exclude 里，这个网页会被 pjax 排除在外。 点击该网页会重新加载网站\n使用 pjax 后，一些自己 DIY 的 js 可能会无效，跳转页面时需要重新调用，请参考Pjax 文档 使用 pjax 后，一些个别页面加载的 js/css，将会改为所有页面都加载\n\n\n主题默认开启 Pjax，大量服务依赖于 pjax，关闭可能会造成破坏性问题。\n安知鱼主题的的 Pjax 目前仍有一些问题，请留意\n使用谷歌广告可能会报错（例如自动广告） 如果你在使用中发现问题，欢迎反馈 Bugs\n\n Snackbar 弹窗\nSnackbar 弹窗,根据自己爱好开启\n修改 主题配置文件\n# Snackbar 弹窗# https://github.com/polonel/SnackBar# position 弹窗位置# 可选 top-left / top-center / top-right / bottom-left / bottom-center / bottom-rightsnackbar:  enable: true  position: bottom-left  bg_light: \"#49b1f5\" #light mode时弹窗背景  bg_dark: \"#2d3035\" #dark mode时弹窗背景\n Pangu\n如果你跟我一样，每次看到网页上的中文字和英文、数字、符号挤在一块，就会坐立难安，忍不住想在它们之间加个空格。这个外挂正是你在网路世界走跳所需要的东西，它会自动替你在网页中所有的中文字和半形的英文、数字、符号之间插入空白。\n修改 主题配置文件\n# https://github.com/vinta/pangu.js# Insert a space between Chinese character and English character (中英文之间添加空格)pangu:  enable: true  field: post # site/post\nfield只支持两个参数，post(只在文章页生效)和site(全站生效)\n PWA\nPWA 是 web 优化的一种手段，主题做了一定的适配，但是依然需要进行配置。要为 AnZhiYu 配上 PWA 特性, 你可以进行选择以下两种方式来进行适配，要为 AnZhiYu 配上 PWA 特性, 你需要如下几个步骤:\n\n打开 hexo 工作目录\nnpm install hexo-offline --save 或者 yarn add hexo-offline\n在根目录创建 hexo-offline.config.cjs 文件，并增加以下内容。\n\n// offline config passed to workbox-build.module.exports = &#123;  globPatterns: [\"css/*.css\", \"404.html\", \"js/**\", \"anzhiyu/random.js\", \"img/**\", \"manifest.json\"],  // 静态文件合集，如果你的站点使用了例如 webp 格式的文件，请将文件类型添加进去。  globDirectory: \"public\",  swDest: \"public/service-worker.js\",  maximumFileSizeToCacheInBytes: 10485760, // 缓存的最大文件大小，以字节为单位。  skipWaiting: true,  clientsClaim: true,  runtimeCaching: [    // 如果你需要加载 CDN 资源，请配置该选项，如果没有，可以不配置。    // CDNs - should be CacheFirst, since they should be used specific versions so should not change    &#123;      urlPattern: /^https:\\/\\/npm\\.elemecdn\\.com\\/anzhiyu-blog/, // 缓存elmentcdn      handler: \"CacheFirst\",    &#125;,  ],  manifestTransforms: [    async (manifestEntries, compilation) =&gt; &#123;      const timestamp = new Date().toISOString().replace(/[-:.TZ]/g, \"\"); // 获取当前时间戳      manifestEntries.push(        &#123;          url: \"/\",          revision: `index-$&#123;timestamp&#125;`,        &#125;,        &#123;          url: \"music/\",          revision: `music-$&#123;timestamp&#125;`,        &#125;,        &#123;          url: \"about/\",          revision: `about-$&#123;timestamp&#125;`,        &#125;      );      return &#123; manifest: manifestEntries &#125;;    &#125;,  ],&#125;;\n更多内容请查看 hexo-offline 的官方文档\n\n在主题配置文件中开启 pwa 选项。\n\n# PWA# See https://github.com/JLHwung/hexo-offline# ---------------pwa:  enable: true  startup_image_enable: true  manifest: /manifest.json  theme_color: var(--anzhiyu-main)  mask_icon: /img/siteicon/apple-icon-180.png  apple_touch_icon: /img/siteicon/apple-icon-180.png  bookmark_icon: /img/siteicon/apple-icon-180.png  favicon_32_32: /img/siteicon/32.png  favicon_16_16: /img/siteicon/16.png\n\n在创建source/目录中创建manifest.json文件。\n\n&#123;  \"name\": \"安知鱼`Blog\",  \"short_name\": \"安知鱼\",  \"theme_color\": \"#3b70fc\",  \"background_color\": \"#3b70fc\",  \"display\": \"fullscreen\",  \"scope\": \"/\",  \"start_url\": \"/\",  \"id\": \"/\",  \"icons\": [    &#123;      \"src\": \"img/siteicon/manifest-icon-192.maskable.png\",      \"sizes\": \"192x192\",      \"type\": \"image/png\",      \"purpose\": \"any\"    &#125;,    &#123;      \"src\": \"img/siteicon/manifest-icon-192.maskable.png\",      \"sizes\": \"192x192\",      \"type\": \"image/png\",      \"purpose\": \"maskable\"    &#125;,    &#123;      \"src\": \"img/siteicon/manifest-icon-512.maskable.png\",      \"sizes\": \"512x512\",      \"type\": \"image/png\",      \"purpose\": \"any\"    &#125;,    &#123;      \"src\": \"img/siteicon/manifest-icon-512.maskable.png\",      \"sizes\": \"512x512\",      \"type\": \"image/png\",      \"purpose\": \"maskable\"    &#125;  ],  \"splash_pages\": null&#125;\n你也可以通过 Web App Manifestopen 快速创建manifest.json。（Web App Manifest 要求至少包含一个 512*512 像素的图标）\n\n可以通过Chrome插件Lighthouse检查 PWA 配置是否生效以及配置是否正确。\n\n\n打开博客页面\n启动Lighthouse插件 (Lighthouse 插件要求至少包含一个 512*512 像素的图标)。\n\n关于 PWA（渐进式增强 Web 应用）的更多内容请参考 Google Tools for Web Developersopen\n\n生成 pwa 启动图\n\n\n安装 pwa-asset-generator，执行以下命令\n\nnpm install pwa-asset-generator\n\nhexo 根目录执行hexo g后执行以下命令\n\nnpx pwa-asset-generator ./public/img/512.png ./public/img/siteicon --padding \"calc(50vh - 20%) calc(50vw - 40%)\" -s false -h true\n\n这条命令会使用themes/source/img/512.png这张图片来生成 siteicon 到目录/public/img/siteicon中，由于hexo cl会清除/public目录中的文件，所以每次hexo d之前都需要执行，如果不想每次hexo d之前都执行的话，可以将主题中的themes/source/img/512.png图片复制移动到根目录``/source/img中，然后将生成后的/public/img/siteicon文件夹复制到根目录``/source/img中，这样根目录``/source/img中就会一直有siteicon，以后执行hexo g时，也会将siteicon生成到public目录中。\n\n Open Graph\n在 head 里增加一些 meta 资料，例如缩略图、标题、时间等等。当你分享网页到一些平台时，平台会读取 Open Graph 的内容，展示缩略图，标题等等信息。\n修改 主题配置文件\n# Open graph meta tags# https://developers.facebook.com/docs/sharing/webmasters/Open_Graph_meta:  enable: true  option:    # twitter_card:    # twitter_image:    # twitter_id:    # twitter_site:    # google_plus:    # fb_admins:    # fb_app_id:\n CSS 前缀\n有些 CSS 并不是所有浏览器都支持，需要增加对应的前缀才会生效。\n开启 css_prefix 后，会自动为一些 CSS 增加前缀。（会增加 20%的体积）\n修改 主题配置文件\n# Add the vendor prefixes to ensure compatibilitycss_prefix: true\n Inject\n如想添加额外的 js/css/meta 等等东西，可以在 Inject 里添加，支持添加到 head(&lt;/body&gt;标签之前)和 bottom(&lt;/html&gt;标签之前)。\n请注意：以标准的 html 格式添加内容\ninject:  head:  \t- &lt;link rel=\"stylesheet\" href=\"/self.css\"&gt;  bottom:  \t- &lt;script src=\"xxxx\"&gt;&lt;/script&gt;\n留意：如果你的网站根目录不是’/',使用本地图片时，需加上你的根目录。\n例如：网站是 https://yoursite.com/blog,引用css/xx.css，则设置为&lt;link rel=&quot;stylesheet&quot; href=&quot;/blog/css/xx.css&quot;&gt;\n CDN\nCDN，里面是主题所引用到的文件，可自行配置 CDN。（非必要请勿修改，配置后请确认链接是否能访问）\n# CDN# Don't modify the following settings unless you know how they work# 非必要请不要修改CDN:  # The CDN provider of internal scripts (主题内部 js 的 cdn 配置)  # option: local/elemecdn/jsdelivr/unpkg/cdnjs/onmicrosoft/cbd/anheyu/custom  # Dev version can only choose. ( dev版的主题只能设置为 local )  internal_provider: local  # The CDN provider of third party scripts (第三方 js 的 cdn 配置)  # option: elemecdn/jsdelivr/unpkg/cdnjs/onmicrosoft/cbd/anheyu/custom  third_party_provider: cbd  # Add version number to CDN, true or false  version: true  # Custom format  # For example: https://cdn.staticfile.org/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;min_cdnjs_file&#125;  custom_format: # https://npm.elemecdn.com/$&#123;name&#125;@latest/$&#123;file&#125;  option:    # main_css:    # main:    # utils:    # translate:    # random_friends_post_js:    # right_click_menu_js:    # comment_barrage_js:    # ai_abstract_js:    # people_js:    # local_search:    # algolia_js:    # algolia_search:    # instantsearch:    # docsearch_js:    # docsearch_css:    # pjax:    # blueimp_md5:    # valine:    # twikoo:    # waline_js:    # waline_css:    # sharejs:    # sharejs_css:    # mathjax:    # katex:    # katex_copytex:    # mermaid:    # canvas_ribbon:    # canvas_fluttering_ribbon:    # canvas_nest:    # lazyload:    # instantpage:    # typed:    # pangu:    # fancybox_css:    # fancybox:    # medium_zoom:    # snackbar_css:    # snackbar:    # activate_power_mode:    # fireworks:    # click_heart:    # ClickShowText:    # fontawesome:    # flickr_justified_gallery_js:    # flickr_justified_gallery_css:    # aplayer_css:    # aplayer_js:    # meting_js:    # meting_api:    # prismjs_js:    # prismjs_lineNumber_js:    # prismjs_autoloader:    # artalk_js:    # artalk_css:    # pace_js:    # pace_default_css:    # countup_js:    # gsap_js:    # busuanzi:    # rightmenu:    # waterfall:    # ali_iconfont_css:    # accesskey_js:\n\n\n\n参数\n解释\n\n\n\n\ninternal_provider\n主题内部文件 可选 local/jsdelivr/unpkg/cdnjs/custom lcoal 为本地加载，custom 为自定义格式，需配置 custom_format 注意: 如果使用的是 Dev 版，只能设置为 local\n\n\nthird_party_provider\n第三方文件 可选 local/jsdelivr/unpkg/cdnjs/custom lcoal 为本地加载，custom 为自定义格式，需配置 custom_format 注意: 如果你选择 local 则需要自行将文件都下载至本地，并修改对应的选项，否则会报错。\n\n\nversion\ntrue/false 为 cdn 加上指定版本号\n\n\ncustom_format\n自定义格式\n\n\noption\n你可以在这里更换部分文件,会覆盖原有的配置\n\n\n\nversion\n如需修改版本号，可修改主题目录的 ‘plugins.yml’ 中对应插件的 version\n请确保你修改的版本号，你所使用的 cdn 有收录\ncustom_format\n提供以下参数\n\n\n\n参数\n解释\n\n\n\n\nname\nnpm 上的包名\n\n\nfile\nnpm 上的文件路径\n\n\nmin_file\ncdnjs 上的包名\n\n\ncdnjs_file\ncdnjs 上的文件路径\n\n\nmin_cdnjs_file\ncdnjs 上的文件路径（压缩过的文件）\n\n\nversion\n插件版本号\n\n\n\n部分可用的第三方 CDN 列表\n\n请确保你选择的 CDN 有收录主题使用的第三方插件\n\n\n\n\n提供商\n格式\n备注\n\n\n\n\nStaticfile（七牛云）open in new window\nhttps://cdn.staticfile.org/${cdnjs_name}/${version}/$\n同步 cdnjs\n\n\nBootCDNopen in new window\nhttps://cdn.bootcdn.net/ajax/libs/${cdnjs_name}/${version}/$\n同步 cdnjs\n\n\nBaomitu（360）open in new window\n最新版本： https://lib.baomitu.com/${cdnjs_name}/latest/${min_cdnjs_file} 指定版本： https://lib.baomitu.com/${cdnjs_name}/${version}/$\n同步 cdnjs\n\n\nElemecdn\n最新版本： https://npm.elemecdn.com/${name}@latest/${file} 指定版本： https://npm.elemecdn.com/${name}@${version}/$\n同步 npm\n\n\n\n 标签卖萌\n主题配置文件中\n# 标签卖萌diytitle:  enable: true  leaveTitle: w(ﾟДﾟ)w 不要走！再看看嘛！  backTitle: ♪(^∇^*)欢迎肥来！\n 双栏\n如果你需要像我一样首页双栏，修改主题配置文件_config.anzhiyu.yml（主题版本需要 1.1.1 以及以上）\n# 双栏文章article_double_row: true\n 首页顶部三大分类配置\n首页技能点轮播下的分类，可通过配置主题配置文件\n# 首页顶部相关配置home_top:  enable: true # 开关  timemode: date #date/updated  title: 活在当下  subTitle: 及时摸鱼。  siteText: xiansakana.xyz  category:    - name: 学习      path: /categories/学习/      shadow: var(--anzhiyu-shadow-blue)      class: blue      icon: anzhiyu-icon-dove    - name: 游戏      path: /categories/游戏/      shadow: var(--anzhiyu-shadow-red)      class: red      icon: anzhiyu-icon-fire    - name: 生活      path: /categories/生活/      shadow: var(--anzhiyu-shadow-green)      class: green      icon: anzhiyu-icon-book  default_descr: 再怎么看我也不知道怎么描述它的啦！  swiper:    enable: false    swiper_css: https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css #swiper css依赖    swiper_js: https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.js #swiper js依赖  banner:    tips: 夜深了    title: 早点睡觉吧    image: https://cdn.jsdelivr.net/npm/xiansakana-blog-img/202309210219999.gif # https://t.mwm.moe/pc    link: http://xiansakana.xyz\n\n首先你需要有categories，需配置过分类页面\n当前分类下有文章，此处以学习分类为例子\n当这个分类下存在文章了以后，这个分类就会产生对应的路径，比如此处产生的是https://你的域名/categories/学习/，所以配置中应该是/categories/学习/。\n\n只需要在创建分类以后在对应的文章中添加上对应的分类，配置 path 即可，注意一定要对应。\n\n\n\n参数\n解释\n\n\n\n\nname\n用于显示的分类名称\n\n\npath\n跳转的路径\n\n\nshadow\n阴影的颜色\n\n\nclass\n类名\n\n\nicon\n图标名，默认使用内置阿里图标参考: 图标配置\n\n\n\n 首页技能点配置\n在根目录创建source/_data/creativity.yml，输入以下内容\n- class_name: 开启创造力  creativity_list:    - name: Java      color: \"#fff\"      icon: https://bu.dusays.com/2023/04/09/643293b1184e9.jpg    - name: Docker      color: \"#57b6e6\"      icon: https://bu.dusays.com/2023/04/09/643293b0f0abe.png    - name: Photoshop      color: \"#4082c3\"      icon: https://bu.dusays.com/2022/12/15/639aa3a5c240e.png    - name: Node      color: \"#333\"      icon: https://npm.elemecdn.com/anzhiyu-blog@2.1.1/img/svg/node-logo.svg    - name: Webpack      color: \"#2e3a41\"      icon: https://bu.dusays.com/2023/04/09/643293b68026c.png    - name: Pinia      color: \"#fff\"      icon: https://npm.elemecdn.com/anzhiyu-blog@2.0.8/img/svg/pinia-logo.svg    - name: Python      color: \"#fff\"      icon: https://bu.dusays.com/2023/04/09/643293b1230f7.png    - name: Vite      color: \"#937df7\"      icon: https://npm.elemecdn.com/anzhiyu-blog@2.0.8/img/svg/vite-logo.svg    - name: Flutter      color: \"#4499e4\"      icon: https://bu.dusays.com/2023/04/09/643293b1055c2.png    - name: Vue      color: \"#b8f0ae\"      icon: https://bu.dusays.com/2023/04/09/643293b6788bd.png    - name: React      color: \"#222\"      icon: data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9Ii0xMS41IC0xMC4yMzE3NCAyMyAyMC40NjM0OCI+CiAgPHRpdGxlPlJlYWN0IExvZ288L3RpdGxlPgogIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSIyLjA1IiBmaWxsPSIjNjFkYWZiIi8+CiAgPGcgc3Ryb2tlPSIjNjFkYWZiIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIi8+CiAgICA8ZWxsaXBzZSByeD0iMTEiIHJ5PSI0LjIiIHRyYW5zZm9ybT0icm90YXRlKDYwKSIvPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIiB0cmFuc2Zvcm09InJvdGF0ZSgxMjApIi8+CiAgPC9nPgo8L3N2Zz4K    - name: CSS3      color: \"#2c51db\"      icon: https://bu.dusays.com/2022/12/15/639aa3a5c251e.png    - name: JS      color: \"#f7cb4f\"      icon: https://bu.dusays.com/2023/04/09/643293b121f02.png    - name: HTML      color: \"#e9572b\"      icon: https://bu.dusays.com/2022/12/15/639aa3a5c241c.png    - name: Git      color: \"#df5b40\"      icon: https://bu.dusays.com/2023/04/09/643293b10ccdd.webp    - name: Apifox      color: \"#e65164\"      icon: https://bu.dusays.com/2022/11/19/6378d6458c6b6.png\n关闭peoplecanvas\n# 首页随便逛逛people模式 而非技能点模式，关闭后为技能点模式需要配置creativity.ymlpeoplecanvas:  enable: false  img: https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png\n此时可以看到首页顶部已经有技能点的轮播了。\n 字数统计\n要为 AnZhiYu 配上字数统计特性, 你需要如下几个步骤:\n打开 hexo 工作目录\nnpm install hexo-wordcount --save\n修改 主题配置文件:\nwordcount:  enable: true  post_wordcount: true  min2read: true  total_wordcount: true\n 网站验证\n如果需要搜索引擎收录网站，可能需要登录对应搜索引擎的管理平台进行提交。 各自的验证码可从各自管理平台拿到\n修改 主题配置文件\nsite_verification:  # - name: google_site_verification  #   content: xxxxxx  # - name: baidu_site_verification  #   content: xxxxxxx\n 数学公式\nMathjax\n不要在标题里使用 mathjax 语法，toc 目录不一定能正确显示 mathjax，可能显示 mathjax 代码\n建议使用 KaTex 获得更好的效果，下文有介绍！\n修改 主题配置文件:\nmathjax:  enable: true  # true 表示每一页都加载mathjax.js  # false 需要时加载，须在使用的Markdown Front-matter 加上 mathjax: true  per_page: true\n如果 per_page 设为 true,则每一页都会加载 Mathjax 服务。设为 false，则需要在文章 Front-matter 添加 mathjax: true，对应的文章才会加载 Mathjax 服务。\n然后你需要修改一下默认的 markdown 渲染引擎来实现 MathJax 的效果。\n查看: hexo-renderer-kramed\n以下操作在你 hexo 博客的目录下 (不是 Anzhiyu 的目录):\n\n安装插件\n\nnpm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save\n\n配置 hexo 根目录的配置文件\n\nkramed:  gfm: true  pedantic: false  sanitize: false  tables: true  breaks: true  smartLists: true  smartypants: true\nKaTex\n不要在标题里使用 KaTeX 语法，toc 目录不能正确显示 KaTeX。\n首先禁用 MathJax（如果你配置过 MathJax 的话），然后修改你的主题配置文件以便加载 katex.min.css:\nkatex:  enable: true  # true 表示每一页都加载katex.js  # false 需要时加载，须在使用的Markdown Front-matter 加上 katex: true  per_page: false  hide_scrollbar: true\n你不需要添加 katex.min.js 来渲染数学方程。相应的你需要卸载你之前的 hexo 的 markdown 渲染器，然后安装其它插件。\n因为 KaTeX 更快更轻量，因此没有 MathJax 的功能多（比如右键菜单）。为那些使用 MathJax 的用户，主题也内置了 katex 的 复制 功能。\nhexo-renderer-markdown-it\n卸载掉 marked 插件，安装 hexo-renderer-markdown-it\nnpm un hexo-renderer-marked --save # 如果有安装这个的话，卸载npm un hexo-renderer-kramed --save # 如果有安装这个的话，卸载npm i hexo-renderer-markdown-it --save # 需要安装这个渲染插件npm install katex @renbaoshuo/markdown-it-katex #需要安装这个katex插件\n在 hexo 的根目录的_config.yml 中配置\nmarkdown:  plugins:    - \"@renbaoshuo/markdown-it-katex\"\n如需配置其它参数，请参考 katex 官网\nhexo-renderer-markdown-it-plus\n\n注意，此方法生成的 katex 没有斜体\n\n卸载掉 marked 插件，然后安装新的hexo-renderer-markdown-it-plus:\n# 替换 `hexo-renderer-kramed` 或者 `hexo-renderer-marked` 等hexo的markdown渲染器# 你可以在你的package.json里找到hexo的markdwon渲染器，并将其卸载npm un hexo-renderer-marked --save# ornpm un hexo-renderer-kramed --save# 然后安装 `hexo-renderer-markdown-it-plus`npm i @upupming/hexo-renderer-markdown-it-plus --save\n注意到 hexo-renderer-markdown-it-plus 已经无人持续维护, 所以我们使用 @upupming/hexo-renderer-markdown-it-plus。 这份 fork 的代码使用了 @neilsustc/markdown-it-katex 同时它也是 VSCode 的插件 Markdown All in One 所使用的, 所以我们可以获得最新的 KaTex 功能例如 \\tag{}。\n你还可以通过 @neilsustc/markdown-it-katex 控制 KaTeX 的设置，所有可配置的选项参见 https://katex.org/docs/options.html。 比如你想要禁用掉 KaTeX 在命令行上输出的宂长的警告信息，你可以在根目录的 _config.yml 中使用下面的配置将 strict 设置为 false\nmarkdown_it_plus:  plugins:    - plugin:      name: '@neilsustc/markdown-it-katex'      enable: true      options:        strict: false\n当然，你还可以利用这个特性来定义一些自己常用的 macros。\n 流程图\n根目录执行 git bash\nnpm install --save hexo-filter-flowchart\n 搜索系统\nalgolia\n记得运行 hexo clean\n使用 hexo-algoliasearch，请记得配置 fields 参数的 title, permalink 和 content\n你需要安装 hexo-algoliasearch并且根据它的说明文档去做相应的配置。\n修改 主题配置文件\nalgolia_search:  enable: true  hits:    per_page: 6\n在 hexo 目录配置文件\n# algolia搜索: https://github.com/LouisBarranqueiro/hexo-algoliasearchalgolia:  appId: \"xxxx\"  apiKey: \"xxxx\"  adminApiKey: \"xxxx\"  chunkSize: 5000  indexName: \"hexo\"  fields:    - content:strip:truncate,0,200    - excerpt:strip    - gallery    - permalink    - photos    - slug    - tags    - title\n本地搜索\n记得运行 hexo clean\n你需要安装 hexo-generator-search，根据它的文档去做相应配置\nnpm install hexo-generator-search --save\n修改主题配置文件\nlocal_search:  enable: true  preload: ture  CDN:\n\n\n\n参数\n解释\n\n\n\n\nenable\n是否开启本地搜索\n\n\npreload\n预加载，开启后，进入网页后会自动加载搜索文件。关闭时，只有点击搜索按钮后，才会加载搜索文件\n\n\nCDN\n搜索文件的 CDN 地址（默认使用的本地链接）\n\n\n\n在 Hexo 配置文件_config.yml中添加\nsearch:  path: search.xml  field: all  content: true\nDocSearch\nDocSearch 是另一款由 algolia 提供的搜索服务，具体申请和使用请查看 DocSearch 文档\ndocsearch:  enable: false  appId:  apiKey:  indexName:  option:\n\n\n\n参数\n解释\n\n\n\n\nenable\n【必须】是否开启 docsearch\n\n\nappId\n【必须】你的 Algolia 应用 ID\n\n\napiKey\n【必须】你的 Algolia 搜索 API key\n\n\nindexName\n【必须】你的 Algolia index name\n\n\noption\n【可选】其余的 docsearch 配置 具体配置可查这里\n\n\n\n 分享\nsharejs\n如果你不知道 sharejs，看看它的説明。\n修改 主题配置文件\nsharejs:  enable: true  sites: facebook,twitter,wechat,weibo,qq #想要显示的内容\naddtoany\n可以到 addtoany 查看使用説明\naddtoany:  enable: true  item: facebook,twitter,wechat,sina_weibo,facebook_messenger,email,copy_link\n 评论\n通用配置\n开启评论需要在 comments-use 中填写你需要的评论。\n支持双评论显示，只需要配置两个评论（第一个为默认显示）\ncomments:  # Up to two comments system, the first will be shown as default  # Choose: Valine/Waline/Twikoo/  use: Twikoo,Waline # Twikoo/Waline  text: true # Display the comment name next to the button  # lazyload: The comment system will be load when comment element enters the browser's viewport.  # If you set it to true, the comment count will be invalid  lazyload: false  count: true # Display comment count in post's top_img  card_post_count: false # Display comment count in Home Page\n\n\n\n参数\n解释\n\n\n\n\nuse\n使用的评论（请注意，最多支持两个，如果不需要请留空）\n\n\ntext\n是否显示评论服务商的名字\n\n\nlazyload\n是否为评论开启 lazyload，开启后，只有滚动到评论位置时才会加载评论所需要的资源（开启 lazyload 后，评论数将不显示）\n\n\ncount\n是否在文章顶部显示评论数\n\n\ncard_post_count\n是否在首页文章卡片显示评论数\n\n\n\nTwikoo\nTwikoo 是一个简洁、安全、无后端的静态网站评论系统，基于腾讯云开发。\n具体如何配置评论，请查看 Twikoo\n你只需要把获取到的 环境 ID (envId) 填写到配置上去就行\n修改 主题配置文件\n# Twikoo# https://github.com/imaegoo/twikootwikoo:  envId:  region:  visitor: false  option:\n\n\n\n参数\n解释\n\n\n\n\nenvId\n环境 ID\n\n\nregion\n环境地域，默认为 ap-shanghai，如果您的环境地域不是上海，需传此参数\n\n\nvisitor\n是否显示文章阅读数\n\n\noption\n可选配置\n\n\ncard_post_count\n是否在首页文章卡片显示评论数\n\n\n\n开启 visitor 后，文章页的访问人数将改为 Twikoo 提供，而不是 不蒜子\nValine\n遵循 Valine 的指示去配置你的 LeanCloud 应用。以及查看相应的配置说明。\n然后修改 主题配置文件:\nvaline:  appId: # leancloud application app id  appKey: # leancloud application app key  avatar: monsterid # gravatar style https://valine.js.org/#/avatar  serverURLs: # This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)  bg: # valine background  visitor: false  option:\n开启 visitor 后，文章页的访问人数将改为 Valine 提供，而不是 不蒜子\nValine 于 v1.4.5 开始支持自定义表情，如果你需要自行配置，请在 emojiCDN 配置表情 CDN。\n同时在 Hexo 工作目录下的 source/_data/创建一个 json 文件 valine.json,等同于 Valine 需要配置的 emojiMaps，valine.json 配置方式可参考如下\nvaline.json\n&#123;  \"tv_doge\": \"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png\",  \"tv_亲亲\": \"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png\",  \"tv_偷笑\": \"bb690d4107620f1c15cff29509db529a73aee261.png\",  \"tv_再见\": \"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png\",  \"tv_冷漠\": \"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png\",  \"tv_发怒\": \"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png\",  \"tv_发财\": \"34db290afd2963723c6eb3c4560667db7253a21a.png\",  \"tv_可爱\": \"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png\",  \"tv_吐血\": \"09dd16a7aa59b77baa1155d47484409624470c77.png\",  \"tv_呆\": \"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png\",  \"tv_呕吐\": \"9f996894a39e282ccf5e66856af49483f81870f3.png\",  \"tv_困\": \"241ee304e44c0af029adceb294399391e4737ef2.png\",  \"tv_坏笑\": \"1f0b87f731a671079842116e0991c91c2c88645a.png\",  \"tv_大佬\": \"093c1e2c490161aca397afc45573c877cdead616.png\",  \"tv_大哭\": \"23269aeb35f99daee28dda129676f6e9ea87934f.png\",  \"tv_委屈\": \"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png\",  \"tv_害羞\": \"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png\",  \"tv_尴尬\": \"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png\",  \"tv_微笑\": \"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png\",  \"tv_思考\": \"90cf159733e558137ed20aa04d09964436f618a1.png\",  \"tv_惊吓\": \"0d15c7e2ee58e935adc6a7193ee042388adc22af.png\"&#125;\nWaline\nWaline - 一款从 Valine 衍生的带后端评论系统。可以将 Waline 等价成 With backend Valine。\n具体配置可参考 waline 文档\n然后修改 主题配置文件:\nwaline:  serverURL: # Waline server address url  bg: # waline background  pageview: false  option:\n开启 pageview 后，文章页的访问人数将改为 Waline 提供，而不是 不蒜子\n 在线聊天\n通用配置\n这些工具都提供了一个按钮可以打开/关闭聊天窗口。 主题也提供了一个集合主题特色的按钮来替换这些工具本身的按钮，这个聊天按钮将会出现在右下角里。 你只需要把 chat_btn 打开就行。\n修改 主题配置文件\n# Chat Button [recommend]# It will create a button in the bottom right corner of website, and hide the origin buttonchat_btn: true\n为了不影响访客的体验，主题提供一个 chat_hide_show 配置 设为 true 后，使用工具提供的按钮时，只有向上滚动才会显示聊天按钮，向下滚动时会隐藏按钮。\n修改 主题配置文件\n# The origin chat button is displayed when scrolling up, and the button is hidden when scrolling downchat_hide_show: true\n如果使用工具自带的聊天按钮，按钮位置可能会遮挡右下角图标，请配置 rightside-bottom 调正右下角图标位置\nchatra\n配置 chatra,需要知道 Public key\n打开 chatra 并注册账号。 你可以在 Preferences 中找到 Public key\n修改 主题配置文件\n# chatra# https://chatra.io/chatra:  enable: true  id: xxxxxxxx\nchatra 的样式你可以 Chat Widget 自行配置\ntidio\n配置 tidio,需要知道 Public key\n打开 tidio 并注册账号。 你可以在 Preferences &gt; Developer 中找到 Public key\n修改 主题配置文件\n# tidio# https://www.tidio.com/tidio:  enable: true  public_key: XXXX\ntidio的样式你可以Channels自行配置\ndaovoice\n打开 daovoiceopen in new window 和注册帐号\n找到你的 app id\n修改 主题配置文件\n# daovoice# http://daovoice.io/daovoice:  enable: true  app_id: xxxxx\n可在聊天设置里配置聊天按钮等样式\ncrisp\n打开 crisp 并注册帐号\n找到需要的网站 ID\n# crisp# https://crisp.chat/en/crisp:  enable: false  website_id: xxxxxxxx\n\nmessenger\nmessenger 为 Facebook 旗下的聊天服务\n具体操作请查看 Facebook 洽谈附加程式 - Messenger 平台\nmessenger:  enable: false  pageID: xxxxx  lang: zh_TW # Language en_US/zh_CN/zh_TW and so on\n 其他功能\n 配置文章链接转数字或字母\n参考: https://github.com/rozbo/hexo-abbrlink\n在 Hexo 博客根目录下打开终端，输入\nnpm install hexo-abbrlink --save\n在 Hexo 配置文件_config.yml里面修改\npermalink: posts/:abbrlink.html # 此处可以自己设置\n并添加\n# 文章链接转数字或字母：https://github.com/rozbo/hexo-abbrlink# abbrlink configabbrlink:  alg: crc32 #support crc16(default) and crc32  rep: hex #support dec(default) and hex  drafts: false #(true)Process draft,(false)Do not process draft. false(default)  # Generate categories from directory-tree  # depth: the max_depth of directory-tree you want to generate, should &gt; 0  auto_category:    enable: true #true(default)    depth: #3(default)    over_write: false  auto_title: false #enable auto title, it can auto fill the title by path  auto_date: false #enable auto date, it can auto fill the date by time today  force: false #enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink. This only updates abbrlink rather than other front variables.\n live2d\n在 Hexo 博客根目录下打开终端，输入\n# 安装live2dnpm install --save hexo-helper-live2d# 安装模型npm install --save live2d-widget-model-z16\n在 Hexo 配置文件_config.yml里面添加\n# Live2D# https://github.com/EYHN/hexo-helper-live2dlive2d:  enable: true #开关插件版看板娘  scriptFrom: local # 默认  # scriptFrom: https://cdn.cbd.int/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中  debug: false # 调试, 是否在控制台输出日志  model:    use: live2d-widget-model-z16 # npm-module package name    # use: https://unpkg.com/live2d-widget-model-koharu@1.0.5/https://assets.saoyu.fun/koharu.model.json # 你的自定义 url  display:    position: right #控制看板娘位置    width: 150 #控制看板娘大小    height: 300 #控制看板娘大小  mobile:    show: false # 手机中是否展示\n sitemap\n参考链接：https://github.com/hexojs/hexo-generator-sitemap\n在 Hexo 博客根目录下打开终端，输入\nnpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save-dev\n在 Hexo 配置文件_config.yml里面添加\n# https://github.com/hexojs/hexo-generator-sitemapsitemap:  path: sitemap.xml  rel: false  tags: true  categories: true\n RSS\n在 Hexo 博客根目录下打开终端，输入\nnpm install hexo-generator-feed --save\n在 Hexo 配置文件_config.yml里面添加\n# https://github.com/hexojs/hexo-generator-feed#Feed Atomfeed:  type: atom  path: atom.xml  limit: 20rss: /atom.xml\n aplayer 音频播放\n参考链接：https://github.com/MoePlayer/hexo-tag-aplayer\n在 Hexo 博客根目录下打开终端，输入\nnpm install hexo-tag-aplayer --save\n在主题配置文件里面修改\naplayerInject:  enable: true  per_page: true\n在主题配置文件中inject 的bottom里面添加下面自定义 js 代码\ninject:  head:    # 自定义css    # - &lt;link rel=\"stylesheet\" href=\"/css/custom.css\" media=\"defer\" onload=\"this.media='all'\"&gt;  bottom:    # 自定义js    # - &lt;script src=\"/js/xxx\"&gt;&lt;/script&gt;    # aplayer音乐    - &lt;div cla=\"true\" data-preload=\"auto\" data-ss=\"aplayer no-destroy\" data-id=\"444551276\" data-server=\"netease\" data-type=\"playlist\"   data-order=\"list\" data-fixedautoplay=\"false\" data-mutex=\"true\" &gt;&lt;/div&gt;\n\n文章中引用音频\n\n&#123;% aplayer \"name\" \"author\" \"url\" \"pic\" \"lrc\" %&#125;\n\n文章中引用音乐可以直接用 iframe 格式，而 iframe 外链一般可以通过音乐网站生成\n\n&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=725692&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt;\n\n 左下角歌单\n歌单配置很简单，只需要修改主题配置文件中nav_music即可\n# 左下角音乐配置项# https://github.com/metowolf/MetingJSnav_music:  enable: true  console_widescreen_music: true # 宽屏状态控制台显示音乐而不是标签 enable为true 控制台依然会显示  id: 444551276  server: netease  # all_playlist: https://y.qq.com/n/ryqq/playlist/8802438608\n dplayer 视频播放\n参考链接：https://github.com/MoePlayer/hexo-tag-dplayer\n在 Hexo 博客根目录下打开终端，输入\nnpm install hexo-tag-dplayer --save\n在主题配置文件里面添加\ndplayer:  enable: true  useCDN: true\n\n文章中引用视频\n\n&#123;% dplayer \"url=https://xiansakana.oss-cn-beijing.aliyuncs.com/video/mad/FRIEND.mp4\" %&#125;\n\n文章中引用视频可以直接用 iframe 格式，而 iframe 外链一般可以通过视频网站生成，例如 b 站\n\n\n&lt;iframe src=\"//player.bilibili.com/player.html?aid=461536590&amp;bvid=BV1uL411W7HT&amp;cid=368370249&amp;p=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"&gt; &lt;/iframe&gt;\n 添加微博热搜\n打开_data 文件夹，创建一个 widget.yml 文件，在里面粘贴如下代码:\nbottom:  - class_name: weibo    id_name: weibo    name: 微博热搜    icon: fa-brands fa-weibo    order: -2    html: |    \t&lt;link rel=\"stylesheet\" href=\"/css/weibo.css\"&gt;    \t&lt;div id=\"weiboContent\"&gt;&lt;/div&gt;    \t&lt;script src=\"/js/weibo.js\"&gt;&lt;/script&gt;\n在_config.anzhiyu.yml主题配置文件下inject配置项中head处引入weibo.css文件，bottom 处引入weibo.js文件\ninject:  head:    - &lt;link rel=\"stylesheet\" href=\"/css/weibo.css\"&gt;  bottom:    - &lt;script src=\"/js/weibo.js\"&gt;&lt;/script&gt;\n在/source/css 目录下新建weibo.css\n.weibo-new &#123;  background: #ff3852;&#125;.weibo-hot &#123;  background: #ff9406;&#125;.weibo-jyzy &#123;  background: #ffc000;&#125;.weibo-recommend &#123;  background: #00b7ee;&#125;.weibo-adrecommend &#123;  background: #febd22;&#125;.weibo-friend &#123;  background: #8fc21e;&#125;.weibo-boom &#123;  background: #bd0000;&#125;.weibo-topic &#123;  background: #ff6f49;&#125;.weibo-topic-ad &#123;  background: #4dadff;&#125;.weibo-boil &#123;  background: #f86400;&#125;#weibo .item-content &#123;  text-align: center;&#125;#weibo-container &#123;  width: 100%;  height: 140px;  font-size: 95%;  overflow-y: auto;  -ms-overflow-style: none;  scrollbar-width: none;&#125;.weibo-list-item &#123;  display: flex;  flex-direction: row;  justify-content: space-between;  flex-wrap: nowrap;&#125;.weibo-title &#123;  white-space: nowrap;  overflow: hidden;  text-overflow: ellipsis;  margin-right: auto;&#125;.weibo-num &#123;  float: right;&#125;.weibo-hotness &#123;  display: inline-block;  padding: 0 6px;  transform: scale(0.8) translateX(-3px);  color: #fff;  border-radius: 8px;&#125;#weibo-container a &#123;  color: #555;&#125;[data-theme=\"dark\"] #weibo-container a &#123;  color: rgba(255, 255, 255, 0.7);&#125;/* 隐藏滚动条 */#weibo-container::-webkit-scrollbar &#123;  display: none;&#125;\n在/source/js目录下新建weibo.js\ntry &#123;  if (document.getElementById(\"weibo\").clientWidth) weibo();&#125; catch (error) &#123;&#125;function weibo() &#123;  let hotness = &#123;    爆: \"weibo-boom\",    热: \"weibo-hot\",    沸: \"weibo-boil\",    新: \"weibo-new\",    荐: \"weibo-recommend\",    音: \"weibo-jyzy\",    影: \"weibo-jyzy\",    剧: \"weibo-jyzy\",    综: \"weibo-jyzy\",  &#125;;  let html = '&lt;div id=\"weibo-container\"&gt;';  let data = JSON.parse(localStorage.getItem(\"weibo\"));  let nowTime = Date.now();  let ls;  if (data == null || nowTime - data.time &gt; 600000) &#123;    // 600000为缓存时间，即10分钟，防止频繁请求，加快本地访问速度。    getData();    return;  &#125; else &#123;    ls = JSON.parse(data.ls);  &#125;  for (let item of ls) &#123;    html +=      '&lt;div class=\"weibo-list-item\"&gt;&lt;div class=\"weibo-hotness ' +      hotness[item.hot || \"荐\"] +      '\"&gt;' +      (item.hot || \"荐\") +      \"&lt;/div&gt;\" +      '&lt;span class=\"weibo-title\"&gt;&lt;a title=\"' +      item.title +      '\"href=\"' +      item.url +      '\" target=\"_blank\" rel=\"external nofollow noreferrer\"&gt;' +      item.title +      \"&lt;/a&gt;&lt;/span&gt;\" +      '&lt;div class=\"weibo-num\"&gt;&lt;span&gt;' +      item.num +      \"&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;\";  &#125;  html += \"&lt;/div&gt;\";  document.getElementById(\"weiboContent\").innerHTML = html;&#125;function getData() &#123;  fetch(\"https://wb.bore.vip/api\")    .then((data) =&gt; data.json())    .then((data) =&gt; &#123;      data = &#123; time: Date.now(), ls: JSON.stringify(data) &#125;;      localStorage.setItem(\"weibo\", JSON.stringify(data));    &#125;)    .then(weibo);&#125;\n 美化配置\n参考链接：为主页文章卡片添加擦亮动画效果\n 首页文章卡片擦亮效果\n\n新建文件source/css/home.css或在已引入的 css 中新增以下内容\n\n#recent-posts &gt; .recent-post-item:not(a)::before &#123;  content: \"\";  position: absolute;  top: 0;  left: 0;  width: 100%;  height: 200%;  background: linear-gradient(to right, transparent, white, transparent);  transform: translateX(-200%);  transition: transform 0.5s linear;  z-index: 1;&#125;#recent-posts &gt; .recent-post-item:not(a):hover::before &#123;  transform: translateX(100%) skewX(-60deg);&#125;\n\n在_config.anzhiyu.yml主题配置文件下inject配置项中head处引入home.css文件\n\ninject:  head:    - &lt;link rel=\"stylesheet\" href=\"/css/home.css\"&gt; # 首页文章卡片擦亮效果\n 首页背景图渐进式加载\n参考链接：首页背景图渐进式加载，解决卡顿难题\n\n新建文件 source/js/imgloaded.js 新增以下内容，并按照注释调整图片路径，在 第 70 行至 76 行 处，配置自己的图片，这里我用的是随机二次元图片。\n\n/** * @description 实现medium的渐进加载背景的效果 */class ProgressiveLoad &#123;  constructor(smallSrc, largeSrc) &#123;    this.smallSrc = smallSrc;    this.largeSrc = largeSrc;    this.initTpl();  &#125;  /**   * @description 生成ui模板   */  initTpl() &#123;    this.container = document.createElement(\"div\");    this.smallStage = document.createElement(\"div\");    this.largeStage = document.createElement(\"div\");    this.video = document.createElement(\"div\");    this.smallImg = new Image();    this.largeImg = new Image();    this.container.className = \"pl-container\";    this.smallStage.className = \"pl-img pl-blur\";    this.largeStage.className = \"pl-img\";    this.video.className = \"pl-video\";    this.container.appendChild(this.smallStage);    this.container.appendChild(this.largeStage);    this.container.appendChild(this.video);    this.smallImg.onload = this._onSmallLoaded.bind(this);    this.largeImg.onload = this._onLargeLoaded.bind(this);  &#125;  /**   * @description 加载背景   */  progressiveLoad() &#123;    this.smallImg.src = this.smallSrc;    this.largeImg.src = this.largeSrc;  &#125;  /**   * @description 大图加载完成   */  _onLargeLoaded() &#123;    this.largeStage.classList.add(\"pl-visible\");    this.largeStage.style.backgroundImage = `url('$&#123;this.largeSrc&#125;')`;  &#125;  /**   * @description 小图加载完成   */  _onSmallLoaded() &#123;    this.smallStage.classList.add(\"pl-visible\");    this.smallStage.style.backgroundImage = `url('$&#123;this.smallSrc&#125;')`;  &#125;&#125;const executeLoad = (config, target) =&gt; &#123;  const isMobile = window.matchMedia(\"(max-width: 767px)\").matches;  const loader = new ProgressiveLoad(    isMobile ? config.mobileSmallSrc : config.smallSrc,    isMobile ? config.mobileLargeSrc : config.largeSrc  );  // 和背景图颜色保持一致，防止高斯模糊后差异较大  if (target.children[0]) &#123;    target.insertBefore(loader.container, target.children[0]);  &#125;  loader.progressiveLoad();&#125;;const config = &#123;  smallSrc: \"https://t.mwm.moe/pc\", // 小图链接 尽可能配置小于100k的图片  largeSrc: \"https://t.mwm.moe/pc\", // 大图链接 最终显示的图片  mobileSmallSrc: \"https://t.mwm.moe/mp\", // 手机端小图链接 尽可能配置小于100k的图片  mobileLargeSrc: \"https://t.mwm.moe/mp\", // 手机端大图链接 最终显示的图片  enableRoutes: [\"/\"],&#125;;function initProgressiveLoad(config) &#123;  const target = document.getElementById(\"page-header\");  if (target &amp;&amp; target.classList.contains(\"full_page\")) &#123;    executeLoad(config, target);  &#125;&#125;function onPJAXComplete(config) &#123;  const target = document.getElementById(\"page-header\");  if (target &amp;&amp; target.classList.contains(\"full_page\")) &#123;    initProgressiveLoad(config);  &#125;&#125;document.addEventListener(\"DOMContentLoaded\", function () &#123;  initProgressiveLoad(config);&#125;);document.addEventListener(\"pjax:complete\", function () &#123;  onPJAXComplete(config);&#125;);\n\n新建文件source/css/imgloaded.css新增以下内容，并按照注释自行决定调整内容\n\n/* 首页头图加载 */.pl-container &#123;  width: 100%;  height: 100%;  position: relative;  overflow: hidden;  will-change: transform; /* 添加性能优化 */  animation: blur-to-clear 2s cubic-bezier(0.62, 0.21, 0.25, 1) 0s 1 normal backwards      running, scale 1.5s cubic-bezier(0.62, 0.21, 0.25, 1) 0s 1 both;&#125;.pl-img &#123;  width: 100%;  height: 100%;  position: absolute;  background-position: center;  background-size: cover;  background-repeat: no-repeat;  opacity: 0;  transition: opacity 1s;&#125;@keyframes blur-to-clear &#123;  0% &#123;    filter: blur(50px);    opacity: 1;  &#125;  100% &#123;    filter: blur(0);    opacity: 1;  &#125;&#125;@keyframes scale &#123;  0% &#123;    transform: scale(1.5) translateZ(0);    opacity: 0;  &#125;  to &#123;    transform: scale(1) translateZ(0);    opacity: 1;  &#125;&#125;.pl-visible &#123;  opacity: 1;&#125;.pl-blur &#123;  /* 小图锯齿多，增加高斯模糊 */  filter: blur(50px);&#125;\n\n在_config.anzhiyu.yml主题配置文件下inject配置项中head和bottom处，分别引入imgloaded.css和imgloaded.js文件\n\ninject:  head:    - &lt;link rel=\"stylesheet\" href=\"/css/imgloaded.css?1\"&gt; # 首页图片渐进式加载  bottom:    - &lt;script async data-pjax src=\"/js/imgloaded.js?1\"&gt;&lt;/script&gt; # 首页图片渐进式加载\n\n务必记得在主题配置文件中开启顶部图的功能。因为 js 文件已经接替了图片加载功能，此处不需要配置图片（当然你也可以配置上）。\n\n# The banner image of home pageindex_img: \"background: url() top / cover no-repeat\"\n 个性定位欢迎信息卡片\n参考链接：侧边栏添加个性定位欢迎信息卡片, 在侧边栏添加个性定位欢迎信息\n定位接口来自青桔\n\n在 hexo 目录下新建source/js/welcome.js文件，新增以下内容(若没有 js 文件夹直接新建即可)，第29行需要自行修改所在经纬度\n\n//get请求fetch(\"https://api.qjqq.cn/api/Local\")  .then((response) =&gt; response.json())  .then((data) =&gt; &#123;    ipLocation = data;    showWelcome();  &#125;)  .catch((error) =&gt; console.error(\"Error:\", error));function getDistance(e1, n1, e2, n2) &#123;  const R = 6371;  const &#123; sin, cos, asin, PI, hypot &#125; = Math;  let getPoint = (e, n) =&gt; &#123;    e *= PI / 180;    n *= PI / 180;    return &#123; x: cos(n) * cos(e), y: cos(n) * sin(e), z: sin(n) &#125;;  &#125;;  let a = getPoint(e1, n1);  let b = getPoint(e2, n2);  let c = hypot(a.x - b.x, a.y - b.y, a.z - b.z);  let r = asin(c / 2) * 2 * R;  return Math.round(r);&#125;function showWelcome() &#123;  let dist = getDistance(    -74.007141,    40.71455,    ipLocation.data.lng,    ipLocation.data.lat  ); //修改自己的经度（-74.007141）纬度（40.714550）  let pos = ipLocation.data.country;  let ip = ipLocation.ip;  let posdesc;  // 以下的代码需要根据新API返回的结果进行相应的调整  switch (ipLocation.data.country) &#123;    case \"日本\":      posdesc = \"よろしく，一起去看樱花吗\";      break;    case \"美国\":      posdesc = \"Let us live in peace!\";      break;    case \"英国\":      posdesc = \"想同你一起夜乘伦敦眼\";      break;    case \"俄罗斯\":      posdesc = \"干了这瓶伏特加！\";      break;    case \"法国\":      posdesc = \"C'est La Vie\";      break;    case \"德国\":      posdesc = \"Die Zeit verging im Fluge.\";      break;    case \"澳大利亚\":      posdesc = \"一起去大堡礁吧！\";      break;    case \"加拿大\":      posdesc = \"拾起一片枫叶赠予你\";      break;    case \"中国\":      pos =        ipLocation.data.prov +        \" \" +        ipLocation.data.city +        \" \" +        ipLocation.data.district;      switch (ipLocation.data.prov) &#123;        case \"北京市\":          posdesc = \"北——京——欢迎你~~~\";          break;        case \"天津市\":          posdesc = \"讲段相声吧\";          break;        case \"河北省\":          posdesc = \"山势巍巍成壁垒，天下雄关铁马金戈由此向，无限江山\";          break;        case \"山西省\":          posdesc = \"展开坐具长三尺，已占山河五百余\";          break;        case \"内蒙古自治区\":          posdesc = \"天苍苍，野茫茫，风吹草低见牛羊\";          break;        case \"辽宁省\":          posdesc = \"我想吃烤鸡架！\";          break;        case \"吉林省\":          posdesc = \"状元阁就是东北烧烤之王\";          break;        case \"黑龙江省\":          posdesc = \"很喜欢哈尔滨大剧院\";          break;        case \"上海市\":          posdesc = \"众所周知，中国只有两个城市\";          break;        case \"江苏省\":          switch (ipLocation.data.city) &#123;            case \"南京市\":              posdesc = \"这是我挺想去的城市啦\";              break;            case \"苏州市\":              posdesc = \"上有天堂，下有苏杭\";              break;            default:              posdesc = \"散装是必须要散装的\";              break;          &#125;          break;        case \"浙江省\":          posdesc = \"东风渐绿西湖柳，雁已还人未南归\";          break;        case \"河南省\":          switch (ipLocation.data.city) &#123;            case \"郑州市\":              posdesc = \"豫州之域，天地之中\";              break;            case \"南阳市\":              posdesc = \"臣本布衣，躬耕于南阳此南阳非彼南阳！\";              break;            case \"驻马店市\":              posdesc = \"峰峰有奇石，石石挟仙气嵖岈山的花很美哦！\";              break;            case \"开封市\":              posdesc = \"刚正不阿包青天\";              break;            case \"洛阳市\":              posdesc = \"洛阳牡丹甲天下\";              break;            default:              posdesc = \"可否带我品尝河南烩面啦？\";              break;          &#125;          break;        case \"安徽省\":          posdesc = \"蚌埠住了，芜湖起飞\";          break;        case \"福建省\":          posdesc = \"井邑白云间，岩城远带山\";          break;        case \"江西省\":          posdesc = \"落霞与孤鹜齐飞，秋水共长天一色\";          break;        case \"山东省\":          posdesc = \"遥望齐州九点烟，一泓海水杯中泻\";          break;        case \"湖北省\":          switch (ipLocation.data.city) &#123;            case \"黄冈市\":              posdesc = \"红安将军县！辈出将才！\";              break;            default:              posdesc = \"来碗热干面~\";              break;          &#125;          break;        case \"湖南省\":          posdesc = \"74751，长沙斯塔克\";          break;        case \"广东省\":          switch (ipLocation.data.city) &#123;            case \"广州市\":              posdesc = \"看小蛮腰，喝早茶了嘛~\";              break;            case \"深圳市\":              posdesc = \"今天你逛商场了嘛~\";              break;            case \"阳江市\":              posdesc = \"阳春合水！博主家乡~ 欢迎来玩~\";              break;            default:              posdesc = \"来两斤福建人~\";              break;          &#125;          break;        case \"广西壮族自治区\":          posdesc = \"桂林山水甲天下\";          break;        case \"海南省\":          posdesc = \"朝观日出逐白浪，夕看云起收霞光\";          break;        case \"四川省\":          posdesc = \"康康川妹子\";          break;        case \"贵州省\":          posdesc = \"茅台，学生，再塞200\";          break;        case \"云南省\":          posdesc = \"玉龙飞舞云缠绕，万仞冰川直耸天\";          break;        case \"西藏自治区\":          posdesc = \"躺在茫茫草原上，仰望蓝天\";          break;        case \"陕西省\":          posdesc = \"来份臊子面加馍\";          break;        case \"甘肃省\":          posdesc = \"羌笛何须怨杨柳，春风不度玉门关\";          break;        case \"青海省\":          posdesc = \"牛肉干和老酸奶都好好吃\";          break;        case \"宁夏回族自治区\":          posdesc = \"大漠孤烟直，长河落日圆\";          break;        case \"新疆维吾尔自治区\":          posdesc = \"驼铃古道丝绸路，胡马犹闻唐汉风\";          break;        case \"台湾省\":          posdesc = \"我在这头，大陆在那头\";          break;        case \"香港特别行政区\":          posdesc = \"永定贼有残留地鬼嚎，迎击光非岁玉\";          break;        case \"澳门特别行政区\":          posdesc = \"性感荷官，在线发牌\";          break;        default:          posdesc = \"带我去你的城市逛逛吧！\";          break;      &#125;      break;    default:      posdesc = \"带我去你的国家逛逛吧\";      break;  &#125;  //根据本地时间切换欢迎语  let timeChange;  let date = new Date();  if (date.getHours() &gt;= 5 &amp;&amp; date.getHours() &lt; 11)    timeChange = \"&lt;span&gt;🌤️ 早上好，一日之计在于晨&lt;/span&gt;\";  else if (date.getHours() &gt;= 11 &amp;&amp; date.getHours() &lt; 13)    timeChange = \"&lt;span&gt;☀️ 中午好，记得午休喔~&lt;/span&gt;\";  else if (date.getHours() &gt;= 13 &amp;&amp; date.getHours() &lt; 17)    timeChange = \"&lt;span&gt;🕞 下午好，饮茶先啦！&lt;/span&gt;\";  else if (date.getHours() &gt;= 17 &amp;&amp; date.getHours() &lt; 19)    timeChange = \"&lt;span&gt;🚶‍♂️ 即将下班，记得按时吃饭~&lt;/span&gt;\";  else if (date.getHours() &gt;= 19 &amp;&amp; date.getHours() &lt; 24)    timeChange = \"&lt;span&gt;🌙 晚上好，夜生活嗨起来！&lt;/span&gt;\";  else timeChange = \"夜深了，早点休息，少熬夜\";  try &#123;    //自定义文本和需要放的位置    document.getElementById(      \"welcome-info\"    ).innerHTML = `欢迎来自 &lt;b&gt;&lt;span style=\"color: var(--kouseki-ip-color);font-size: var(--kouseki-gl-size)\"&gt;$&#123;pos&#125;&lt;/span&gt;&lt;/b&gt; 的小友💖&lt;br&gt;$&#123;posdesc&#125;🍂&lt;br&gt;当前位置距博主约 &lt;b&gt;&lt;span style=\"color: var(--kouseki-ip-color)\"&gt;$&#123;dist&#125;&lt;/span&gt;&lt;/b&gt; 公里！&lt;br&gt;您的IP地址为：&lt;b&gt;&lt;span style=\"font-size: 12px;\"&gt;$&#123;ip&#125;&lt;/span&gt;&lt;/b&gt;&lt;br&gt;$&#123;timeChange&#125; &lt;br&gt;`;  &#125; catch (err) &#123;    console.log(\"Pjax无法获取元素\");  &#125;&#125;// Pjax完成页面切换的事件回调处理function handlePjaxComplete() &#123;  showWelcome();&#125;window.onload = function () &#123;  showWelcome();  // 添加pjax:complete事件监听  document.addEventListener(\"pjax:complete\", handlePjaxComplete);&#125;;\n\n在 hexo 目录下新建source/css/welcome.css文件，新增以下内容(若没有 css 文件夹直接新建即可)\n\n#welcome-info &#123;  overflow: hidden;  border-radius: 14px;  --kouseki-welcome-color: #49b1f5;  --kouseki-ip-color: #49b1f5;  --kouseki-gl-size: 16px !important;&#125;\n\n在_config.anzhiyu.yml主题配置文件下inject配置项中的head引入welcome.css，bottom引入jquery.min.js和welcome.js\n\ninject:  head:    - &lt;link rel=\"stylesheet\" href=\"/css/welcome.css?1\"&gt; # 个性定位欢迎信息  bottom:    - &lt;script type=\"text/javascript\" src=\"https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js\"&gt;&lt;/script&gt; # jquery.min.js    - &lt;script async data-pjax src=\"/js/welcome.js\"&gt;&lt;/script&gt; # 个性定位欢迎信息\n\n在_config.anzhiyu.yml主题配置文件下aside配置项的card_announcement中添加以下内容\n\ncard_announcement:  enable: true  content: &lt;div id=\"welcome-info\"&gt;&lt;/div&gt;\n 首页和标题字体黑夜霓虹灯效果\n参考来源：hexo 主题 butterfly 首页字体黑夜霓虹灯效果\n\n首先在 hexo 目录下新建source/css/light.css文件\n\n/* 夜间模式菜单栏发光字 */[data-theme=\"dark\"] #nav .site-page,[data-theme=\"dark\"] #nav .menus_items .menus_item .menus_item_child li a &#123;  text-shadow: 0 0 2px var(--theme-color) !important;&#125;/* 手机端适配 */[data-theme=\"dark\"] #sidebar #sidebar-menus .menus_items .site-page &#123;  text-shadow: 0 0 2px var(--theme-color) !important;&#125;\n\n然后在 hexo 目录下新建source/js/light.js文件\n\n// 霓虹灯效果// 颜色数组var arr = [  \"#39c5bb\",  \"#f14747\",  \"#f1a247\",  \"#f1ee47\",  \"#b347f1\",  \"#1edbff\",  \"#ed709b\",  \"#5636ed\",];// 颜色索引var idx = 0;// 切换颜色function changeColor() &#123;  // 仅夜间模式才启用  if (    document.getElementsByTagName(\"html\")[0].getAttribute(\"data-theme\") ==    \"dark\"  ) &#123;    if (document.getElementById(\"site-name\"))      document.getElementById(\"site-name\").style.textShadow =        arr[idx] + \" 0 0 15px\";    if (document.getElementById(\"site-title\"))      document.getElementById(\"site-title\").style.textShadow =        arr[idx] + \" 0 0 15px\";    if (document.getElementById(\"site-subtitle\"))      document.getElementById(\"site-subtitle\").style.textShadow =        arr[idx] + \" 0 0 10px\";    if (document.getElementById(\"post-info\"))      document.getElementById(\"post-info\").style.textShadow =        arr[idx] + \" 0 0 5px\";    try &#123;      document.getElementsByClassName(\"author-info__name\")[0].style.textShadow =        arr[idx] + \" 0 0 12px\";      document.getElementsByClassName(        \"author-info__description\"      )[0].style.textShadow = arr[idx] + \" 0 0 12px\";    &#125; catch &#123;&#125;    idx++;    if (idx == 8) &#123;      idx = 0;    &#125;  &#125; else &#123;    // 白天模式恢复默认    if (document.getElementById(\"site-name\"))      document.getElementById(\"site-name\").style.textShadow =        \"#1e1e1ee0 1px 1px 1px\";    if (document.getElementById(\"site-title\"))      document.getElementById(\"site-title\").style.textShadow =        \"#1e1e1ee0 1px 1px 1px\";    if (document.getElementById(\"site-subtitle\"))      document.getElementById(\"site-subtitle\").style.textShadow =        \"#1e1e1ee0 1px 1px 1px\";    if (document.getElementById(\"post-info\"))      document.getElementById(\"post-info\").style.textShadow =        \"#1e1e1ee0 1px 1px 1px\";    try &#123;      document.getElementsByClassName(\"author-info__name\")[0].style.textShadow =        \"\";      document.getElementsByClassName(        \"author-info__description\"      )[0].style.textShadow = \"\";    &#125; catch &#123;&#125;  &#125;&#125;// 开启计时器window.onload = setInterval(changeColor, 1200);\n\n最后在_config.anzhiyu.yml主题配置文件下inject配置项中的head引入light.css，bottom引入light.js\n\ninject:  head:    - &lt;link rel=\"stylesheet\" href=\"/css/light.css\" media=\"defer\" onload=\"this.media='all'\"&gt;  bottom:    - &lt;script defer src=\"/js/light.js\"&gt;&lt;/script&gt; # 霓虹灯(必须defer否则有时候会不生效)\n 增加书单集\n前几天突然想给博客添加书单的功能，但是搜了很多教程，大多是那种豆瓣的书单，我想要的是自定义而且能够在线预览的那种。偶然间翻到一位大佬的书单，刚好符合我的想法，就拿过来参考了一下（hexo 博客增加书单）。\n创建书单页面\n首先创建新页面\nhexo new page book\n插入源代码\n直接在生成的 index.md 文件中插入页面的 html 代码\n&lt;link rel=\"stylesheet\" href=\"/css/book.css\" /&gt;&lt;div class=\"page\"&gt;  &lt;!-- 每个li标签内容代表一本书籍的所有信息 --&gt;  &lt;div class=\"info\"&gt;    &lt;div class=\"image\" title=\"无职转生\"&gt;      &lt;img        src=\"https://cdn.jsdelivr.net/npm/xiansakana-blog-https://assets.saoyu.fun/blog-https://assets.saoyu.fun/%E6%97%A0%E8%81%8C%E8%BD%AC%E7%94%9F/images/cover.jpg\"      /&gt;    &lt;/div&gt;    &lt;div class=\"info-card\"&gt;      &lt;!-- &lt;a href=\"https://cdn.jsdelivr.net/npm/xiansakana-blog-https://assets.saoyu.fun@1.0.1/blog-https://assets.saoyu.fun/%E6%97%A0%E8%81%8C%E8%BD%AC%E7%94%9FWEB_compressed.pdf\" target=\"_Blank\"&gt;                           --&gt;      &lt;h2&gt;        &lt;a href=\"无职转生/无职转生.html\" target=\"_Blank\"&gt; 《无职转生》 &lt;/a&gt;      &lt;/h2&gt;      &lt;h4&gt;作者：理不尽な孫の手&lt;/h4&gt;      &lt;h4&gt;出版时间：&lt;/h4&gt;      &lt;p&gt;2014-01-24——2022-11-25&lt;/p&gt;      &lt;h4&gt;        &lt;span&gt;推荐指数：&lt;/span&gt;        &lt;span&gt;          &lt;!-- 推荐指数，多少个星星就有以下多少个i标签 --&gt;          &lt;i class=\"fas fa-star\"&gt;&lt;/i&gt;&lt;i class=\"fas fa-star\"&gt;&lt;/i          &gt;&lt;i class=\"fas fa-star\"&gt;&lt;/i&gt;&lt;i class=\"fas fa-star\"&gt;&lt;/i          &gt;&lt;i class=\"fas fa-star\"&gt;&lt;/i&gt;        &lt;/span&gt;      &lt;/h4&gt;      &lt;p class=\"text\"&gt;        34岁无职童贞尼特身无分文地被赶出家门，发现自己的人生已经完全走投无路。刚刚产生后悔的想法，他就被卡车撞死了。然后醒来的地方居然是——剑与魔法的异世界！！重生为名叫卢迪乌斯的婴儿的他下定决心，“这次一定要认真地活下去……！”，一定要度过一段不会后悔的人生。他利用前世的智力很快使得自己的魔法的才能开花结果，结果一位年轻的女孩子成了自己的家庭教师。并且又与一位有着绿宝石般美丽秀发的四分一血统的精灵相遇。他崭新的人生开始前进。——让人憧憬的转生型奇幻小说，在这里开始。      &lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;\n插入 css 来改变页面的样式\n新建文件 source/css/book.css，插入以下代码\ndiv.info &#123;  display: flex;  flex-wrap: wrap;  padding: 1rem;&#125;div.info div.image &#123;  flex: 1 1 200px;  display: flex;  align-items: center;&#125;div.info div.image img &#123;  width: 60%;&#125;div.info div.info-card &#123;  flex: 3 1 500px;&#125;\n创建预览页面\n这里我在根目录的 source 中创建了一个文件夹命名为 book，并将刚刚生成的 index.md 书单页面放进去，然后在源代码的第 8 和 14 行可以自行修改跳转链接。我这里是在 book 文件夹中又新建了一个文件夹然后又创建了该书的目录页面，所以可以直接跳转。\n&lt;a href=\"无职转生/无职转生.html\" target=\"_Blank\" class=\"book-container\"&gt;&lt;/a&gt;\n为了使得每个章节都能打开和收起功能而且第一章默认打开，又自行添加了一个 script，而且目录中也可以直接跳转到每一小节的内容，只要在该 book 文件夹中加入相应的 html 文件就行。下面是该页面的部分代码，仅供参考。\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"UTF-8\" /&gt;    &lt;title&gt;小说目录&lt;/title&gt;    &lt;style&gt;      .section &#123;        display: none; /* 默认隐藏部分 */      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;无职转生&lt;/h1&gt;    &lt;h2&gt;目录&lt;/h2&gt;    &lt;ul id=\"chapter-list\"&gt;      &lt;li&gt;        &lt;span class=\"toggle\" onclick=\"toggleSection('chapter1')\"&gt;[-]&lt;/span&gt;        &lt;a href=\"chapter2.html\"&gt;第一章 幼年期&lt;/a&gt;        &lt;ul id=\"chapter1\" class=\"section\"&gt;          &lt;li&gt;&lt;a href=\"chapter3.html\"&gt;序章&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter4.html\"&gt;第一话 难道是：异世界&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter5.html\"&gt;第二话 感到退缩的女仆&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter6.html\"&gt;第三话 魔法课本&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter7.html\"&gt;第四话 师傅&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter8.html\"&gt;第五话 剑术与魔法&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter9.html\"&gt;第六话 尊敬的理由&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter10.html\"&gt;第七话 朋友&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter11.html\"&gt;第八话 迟钝&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter12.html\"&gt;第九话 紧急家族会议&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter13.html\"&gt;第十话 瓶颈&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter14.html\"&gt;第十一话 离别&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter15.html\"&gt;番外 格瑞拉特家的母亲&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"chapter16.html\"&gt;文库特典 人生的绿洲&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;      &lt;/li&gt;      &lt;!-- 添加更多章节链接 --&gt;    &lt;/ul&gt;    &lt;script&gt;      function toggleSection(sectionId) &#123;        var section = document.getElementById(sectionId);        if (section.style.display === \"none\" || section.style.display === \"\") &#123;          section.style.display = \"block\";          document.querySelector(\"#chapter-list li span.toggle\").textContent =            \"[-]\";        &#125; else &#123;          section.style.display = \"none\";          document.querySelector(\"#chapter-list li span.toggle\").textContent =            \"[+]\";        &#125;      &#125;      // 如果章节或部分数量超过5个，则触发默认展开功能      var chapters = document.querySelectorAll(\"#chapter-list li ul.section\");      for (var i = 0; i &lt; chapters.length; i++) &#123;        if (chapters[i].children.length &gt; 5) &#123;          chapters[i].style.display = \"block\";          chapters[i].previousElementSibling.querySelector(            \".toggle\"          ).textContent = \"[-]\";        &#125;      &#125;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n预览效果\n最后 hexo 三连之后就可以预览效果啦\n\n下面是目录的预览\n\n 更新\n考虑到 html 的页面需要每次都上传到服务器，而且久而久之会拖慢预览和上传的速度，已经将具体的书页托管到 netlify 然后链接到对应页面即可进行阅读。\n","categories":["笔记"],"tags":["Hexo"]},{"title":"Redis实战篇","url":"/2024/11/21/Redis%E5%AE%9E%E6%88%98%E7%AF%87/","content":" 开篇导读\n亲爱的小伙伴们大家好，马上咱们就开始实战篇的内容了，相信通过本章的学习，小伙伴们就能理解各种 redis 的使用啦，接下来咱们来一起看看实战篇我们要学习一些什么样的内容\n\n短信登录\n\n这一块我们会使用 redis 共享 session 来实现\n\n商户查询缓存\n\n通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容\n\n优惠卷秒杀\n\n通过本章节，我们可以学会 Redis 的计数器功能， 结合 Lua 完成高性能的 redis 操作，同时学会 Redis 分布式锁的原理，包括 Redis 的三种消息队列\n\n附近的商户\n\n我们利用 Redis 的 GEOHash 来完成对于地理坐标的操作\n\nUV 统计\n\n主要是使用 Redis 来完成统计功能\n\n用户签到\n\n使用 Redis 的 BitMap 数据统计功能\n\n好友关注\n\n基于 Set 集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下\n\n打人探店\n\n基于 List 来完成点赞列表的操作，同时基于 SortedSet 来完成点赞的排行榜功能\n以上这些内容咱们统统都会给小伙伴们讲解清楚，让大家充分理解如何使用 Redis\n\n 短信登录\n 导入黑马点评项目\n 导入 SQL\n\n 有关当前模型\n手机或者 app 端发起请求，请求我们的 nginx 服务器，nginx 基于七层模型走的事 HTTP 协议，可以实现基于 Lua 直接绕开 tomcat 访问 redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游 tomcat 服务器，打散流量，我们都知道一台 4 核 8G 的 tomcat，在优化和处理简单业务的加持下，大不了就处理 1000 左右的并发， 经过 nginx 的负载均衡分流后，利用集群支撑起整个项目，同时 nginx 在部署了前端项目后，更是可以做到动静分离，进一步降低 tomcat 服务的压力，这些功能都得靠 nginx 起作用，所以 nginx 是整个项目中重要的一环。\n在 tomcat 支撑起并发流量后，我们如果让 tomcat 直接去访问 Mysql，根据经验 Mysql 企业级服务器只要上点并发，一般是 16 或 32 核心 cpu，32 或 64G 内存，像企业级 mysql 加上固态硬盘能够支撑的并发，大概就是 4000 起~7000 左右，上万并发， 瞬间就会让 Mysql 服务器的 cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用 mysql 集群，同时为了进一步降低 Mysql 的压力，同时增加访问的性能，我们也会加入 Redis，同时使用 Redis 集群使得 Redis 对外提供更好的服务。\n\n 导入后端项目\n在资料中提供了一个项目源码：\n\n 导入前端工程\n\n 运行前端项目\n\n 基于 Session 实现登录流程\n发送验证码：\n用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号\n如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户\n短信验证码登录、注册：\n用户将验证码和手机号进行输入，后台从 session 中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到 session 中，方便后续获得当前登录信息\n校验登录状态:\n用户在请求时候，会从 cookie 中携带者 JsessionId 到后台，后台通过 JsessionId 从 session 中拿到用户信息，如果没有 session 信息，则进行拦截，如果有 session 信息，则将用户信息保存到 threadLocal 中，并且放行\n\n 实现发送短信验证码功能\n页面流程\n\n具体代码如下\n贴心小提示：\n具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。\n\n发送验证码\n\n@Overridepublic Result sendCode(String phone, HttpSession session) &#123;    // 1.校验手机号    if (RegexUtils.isPhoneInvalid(phone)) &#123;        // 2.如果不符合，返回错误信息        return Result.fail(\"手机号格式错误！\");    &#125;    // 3.符合，生成验证码    String code = RandomUtil.randomNumbers(6);    // 4.保存验证码到 session    session.setAttribute(\"code\",code);    // 5.发送验证码    log.debug(\"发送短信验证码成功，验证码：&#123;&#125;\", code);    // 返回ok    return Result.ok();&#125;\n\n登录\n\n@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123;    // 1.校验手机号    String phone = loginForm.getPhone();    if (RegexUtils.isPhoneInvalid(phone)) &#123;        // 2.如果不符合，返回错误信息        return Result.fail(\"手机号格式错误！\");    &#125;    // 3.校验验证码    Object cacheCode = session.getAttribute(\"code\");    String code = loginForm.getCode();    if(cacheCode == null || !cacheCode.toString().equals(code))&#123;         //3.不一致，报错        return Result.fail(\"验证码错误\");    &#125;    //一致，根据手机号查询用户    User user = query().eq(\"phone\", phone).one();    //5.判断用户是否存在    if(user == null)&#123;        //不存在，则创建        user =  createUserWithPhone(phone);    &#125;    //7.保存用户信息到session中    session.setAttribute(\"user\",user);    return Result.ok();&#125;\n 实现登录拦截功能\n温馨小贴士：tomcat 的运行原理\n\n当用户发起请求时，会访问我们像 tomcat 注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat 也不例外，当监听线程知道用户想要和 tomcat 连接连接时，那会由监听线程创建 socket 连接，socket 都是成对出现的，用户通过 socket 像互相传递数据，当 tomcat 端的 socket 接受到数据后，此时监听线程会从 tomcat 的线程池中取出一个线程执行用户请求，在我们的服务部署到 tomcat 后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的 controller，service，dao 中，并且访问对应的 DB，在用户执行完请求后，再统一返回，再找到 tomcat 端的 socket，再将数据写回到用户端的 socket，完成请求和响应\n通过以上讲解，我们可以得知 每个用户其实对应都是去找 tomcat 线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用 threadlocal 来做到线程隔离，每个线程操作自己的一份数据\n温馨小贴士：关于 threadlocal\n如果小伙伴们看过 threadLocal 的源码，你会发现在 threadLocal 中，无论是他的 put 方法和他的 get 方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量 map，只要线程不一样，map 就不一样，所以可以通过这种方式来做到线程隔离\n\n拦截器代码\npublic class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;       //1.获取session        HttpSession session = request.getSession();        //2.获取session中的用户        Object user = session.getAttribute(\"user\");        //3.判断用户是否存在        if(user == null)&#123;              //4.不存在，拦截，返回401状态码              response.setStatus(401);              return false;        &#125;        //5.存在，保存用户信息到Threadlocal        UserHolder.saveUser((User)user);        //6.放行        return true;    &#125;&#125;\n让拦截器生效\n@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        \"/shop/**\",                        \"/voucher/**\",                        \"/shop-type/**\",                        \"/upload/**\",                        \"/blog/hot\",                        \"/user/code\",                        \"/user/login\"                ).order(1);        // token刷新的拦截器        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(\"/**\").order(0);    &#125;&#125;\n 隐藏用户敏感信息\n我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个 UserDto 对象，这个 UserDto 对象就没有敏感信息了，我们在返回前，将有用户敏感信息的 User 对象转化成没有敏感信息的 UserDto 对象，那么就能够避免这个尴尬的问题了\n在登录方法处修改\n//7.保存用户信息到session中session.setAttribute(\"user\", BeanUtils.copyProperties(user,UserDTO.class));\n在拦截器处：\n//5.存在，保存用户信息到ThreadlocalUserHolder.saveUser((UserDTO) user);\n在 UserHolder 处：将 user 对象换成 UserDTO\npublic class UserHolder &#123;    private static final ThreadLocal&lt;UserDTO&gt; tl = new ThreadLocal&lt;&gt;();    public static void saveUser(UserDTO user)&#123;        tl.set(user);    &#125;    public static UserDTO getUser()&#123;        return tl.get();    &#125;    public static void removeUser()&#123;        tl.remove();    &#125;&#125;\n session 共享问题\n核心思路分析：\n每个 tomcat 中都有一份属于自己的 session,假设用户第一次访问第一台 tomcat，并且把自己的信息存放到第一台服务器的 session 中，但是第二次这个用户访问到了第二台 tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的 session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是 session 拷贝，就是说虽然每个 tomcat 上都有不同的 session，但是每当任意一台服务器的 session 修改时，都会同步给其他的 Tomcat 服务器的 session，这样的话，就可以实现 session 的共享了\n但是这种方案具有两个大问题\n1、每台服务器中都有完整的一份 session 数据，服务器压力过大。\n2、session 拷贝数据时，可能会出现延迟\n所以咱们后来采用的方案都是基于 redis 来完成，我们把 session 换成 redis，redis 数据本身就是共享的，就可以避免 session 共享的问题了\n\n Redis 代替 session 的业务流程\n 设计 key 的结构\n首先我们要思考一下利用 redis 来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用 String，或者是使用哈希，如下图，如果使用 String，同学们注意他的 value，用多占用一点空间，如果使用哈希，则他的 value 中只会存储他数据本身，如果不是特别在意内存，其实使用 String 就可以啦。\n\n 设计 key 的具体细节\n所以我们可以使用 String 结构，就是一个简单的 key，value 键值对的方式，但是关于 key 的处理，session 他是每个用户都有自己的 session，但是 redis 的 key 是共享的，咱们就不能使用 code 了\n在设计这个 key 的时候，我们之前讲过需要满足两点\n1、key 要具有唯一性\n2、key 要方便携带\n如果我们采用 phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到 redis 中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串 token，然后让前端带来这个 token 就能完成我们的整体逻辑了\n 整体访问流程\n当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到 redis，并且生成 token 作为 redis 的 key，当我们校验用户是否登录时，会去携带着 token 进行访问，从 redis 中取出 token 对应的 value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到 threadLocal 中，并且放行。\n\n 基于 Redis 实现短信登录\n这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。\nUserServiceImpl 代码\n@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123;    // 1.校验手机号    String phone = loginForm.getPhone();    if (RegexUtils.isPhoneInvalid(phone)) &#123;        // 2.如果不符合，返回错误信息        return Result.fail(\"手机号格式错误！\");    &#125;    // 3.从redis获取验证码并校验    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);    String code = loginForm.getCode();    if (cacheCode == null || !cacheCode.equals(code)) &#123;        // 不一致，报错        return Result.fail(\"验证码错误\");    &#125;    // 4.一致，根据手机号查询用户 select * from tb_user where phone = ?    User user = query().eq(\"phone\", phone).one();    // 5.判断用户是否存在    if (user == null) &#123;        // 6.不存在，创建新用户并保存        user = createUserWithPhone(phone);    &#125;    // 7.保存用户信息到 redis中    // 7.1.随机生成token，作为登录令牌    String token = UUID.randomUUID().toString(true);    // 7.2.将User对象转为HashMap存储    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, new HashMap&lt;&gt;(),            CopyOptions.create()                    .setIgnoreNullValue(true)                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));    // 7.3.存储    String tokenKey = LOGIN_USER_KEY + token;    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);    // 7.4.设置token有效期    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);    // 8.返回token    return Result.ok(token);&#125;\n 解决状态登录刷新问题\n 初始方案思路总结：\n在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录 token 令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的\n\n 优化方案\n既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了 threadLocal 的数据，所以此时第二个拦截器只需要判断拦截器中的 user 对象是否存在即可，完成整体刷新功能。\n\n 代码\nRefreshTokenInterceptor\npublic class RefreshTokenInterceptor implements HandlerInterceptor &#123;    private StringRedisTemplate stringRedisTemplate;    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1.获取请求头中的token        String token = request.getHeader(\"authorization\");        if (StrUtil.isBlank(token)) &#123;            return true;        &#125;        // 2.基于TOKEN获取redis中的用户        String key  = LOGIN_USER_KEY + token;        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);        // 3.判断用户是否存在        if (userMap.isEmpty()) &#123;            return true;        &#125;        // 5.将查询到的hash数据转为UserDTO        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);        // 6.存在，保存用户信息到 ThreadLocal        UserHolder.saveUser(userDTO);        // 7.刷新token有效期        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);        // 8.放行        return true;    &#125;    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        // 移除用户        UserHolder.removeUser();    &#125;&#125;\nLoginInterceptor\npublic class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1.判断是否需要拦截（ThreadLocal中是否有用户）        if (UserHolder.getUser() == null) &#123;            // 没有，需要拦截，设置状态码            response.setStatus(401);            // 拦截            return false;        &#125;        // 有用户，则放行        return true;    &#125;&#125;\n 商户查询缓存\n 什么是缓存?\n前言：什么是缓存?\n就像自行车,越野车的避震器\n举个例子:越野车,山地自行车,都拥有&quot;避震器&quot;,防止车体加速后因惯性,在酷似&quot;U&quot;字母的地形上飞跃,硬着陆导致的损害,像个弹簧一样;\n同样,实际开发中,系统也需要&quot;避震器&quot;,防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;\n这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;\n缓存(Cache)，就是数据交换的缓冲区,俗称的缓存就是缓冲区内的数据,一般从数据库中获取,存储于本地代码，例如:\n例1:Static final ConcurrentHashMap&lt;K,V&gt; map = new ConcurrentHashMap&lt;&gt;(); 本地用于高并发例2:static final Cache&lt;K,V&gt; USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存例3:Static final Map&lt;K,V&gt; map =  new HashMap(); 本地缓存\n由于其被Static修饰,所以随着类的加载而被加载到内存之中,作为本地缓存,由于其又被final修饰,所以其引用(例 3:map)和对象(例 3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;\n 为什么要使用缓存\n一句话:因为速度快,好用\n缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低用户访问并发量带来的服务器读写压力\n实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为&quot;避震器&quot;,系统是几乎撑不住的,所以企业会大量运用到缓存技术;\n但是缓存也会增加代码复杂度和运营的成本:\n\n 如何使用缓存\n实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与 redis 中的缓存并发使用\n浏览器缓存：主要是存在于浏览器端的缓存\n应用层缓存： 可以分为 tomcat 本地缓存，比如之前提到的 map，或者是使用 redis 作为缓存\n数据库缓存： 在数据库中有一片空间是 buffer pool，增改查数据都会先加载到 mysql 的缓存中\nCPU 缓存： 当代计算机最大的问题是 cpu 性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了 cpu 的 L1，L2，L3 级的缓存\n\n 添加商户缓存\n在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存\n@GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;    &#x2F;&#x2F;这里是直接查询数据库    return shopService.queryById(id);&#125;\n 缓存模型和思路\n标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入 redis。\n\n 代码如下\n代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入 redis。\n\n 缓存更新策略\n缓存更新是 redis 为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向 redis 插入太多数据，此时就可能会导致缓存中的数据过多，所以 redis 会对部分数据进行更新，或者把他叫为淘汰更合适。\n内存淘汰： redis 自动进行，当 redis 内存达到咱们设定的 max-memery 的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)\n超时剔除： 当我们给 redis 设置了过期时间 ttl 之后，redis 会将超时的数据进行删除，方便咱们继续使用缓存\n主动更新： 我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题\n\n 数据库缓存不一致解决方案：\n由于我们的缓存的数据源来自于数据库,而数据库的数据是会发生变化的,因此,如果当数据库中数据发生变化,而缓存却没有同步,此时就会有一致性问题存在,其后果是:\n用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案\nCache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案\nRead/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理\nWrite Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致\n\n 数据库和缓存不一致采用什么方案\n综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题\n操作缓存和数据库时有三个问题需要考虑：\n如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来\n\n\n删除缓存还是更新缓存？\n\n更新缓存：每次更新数据库都更新缓存，无效写操作较多\n删除缓存：更新数据库时让缓存失效，查询时再更新缓存\n\n\n\n如何保证缓存与数据库的操作的同时成功或失败？\n\n单体系统，将缓存与数据库操作放在一个事务\n分布式系统，利用 TCC 等分布式事务方案\n\n\n\n应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程 1 先来，他先把缓存删了，此时线程 2 过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程 1 再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。\n\n先操作缓存还是先操作数据库？\n\n先删除缓存，再操作数据库\n先操作数据库，再删除缓存\n\n\n\n\n 实现商铺和缓存与数据库双写一致\n核心思路如下：\n修改 ShopController 中的业务逻辑，满足下面的需求：\n根据 id 查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间\n根据 id 修改店铺时，先修改数据库，再删除缓存\n修改重点代码 1：修改ShopServiceImpl的 queryById 方法\n设置 redis 缓存时添加过期时间\n\n修改重点代码 2\n代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从 mysql 中加载最新的数据，从而避免数据库和缓存不一致的问题\n\n 缓存穿透问题的解决思路\n缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\n常见的解决方案有两种：\n\n缓存空对象\n\n优点：实现简单，维护方便\n缺点：\n\n额外的内存消耗\n可能造成短期的不一致\n\n\n\n\n布隆过滤\n\n优点：内存占用较少，没有多余 key\n缺点：\n\n实现复杂\n存在误判可能\n\n\n\n\n\n缓存空对象思路分析： 当我们客户端访问不存在的数据时，先请求 redis，但是此时 redis 中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如 redis 这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到 redis 中去，这样，下次用户过来访问这个不存在的数据，那么在 redis 中也能找到这个数据就不会进入到缓存了\n布隆过滤： 布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问 redis，哪怕此时 redis 中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到 redis 中，\n假设布隆过滤器判断这个数据不存在，则直接返回\n这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突\n\n 编码解决商品查询的缓存穿透问题：\n核心思路如下：\n在原来的逻辑中，我们如果发现这个数据在 mysql 中不存在，直接就返回 404 了，这样是会存在缓存穿透问题的\n现在的逻辑中：如果这个数据不存在，我们不会返回 404 ，还是会把这个数据写入到 Redis 中，并且将 value 设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个 value 是否是 null，如果是 null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。\n\n小总结：\n缓存穿透产生的原因是什么？\n\n用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力\n\n缓存穿透的解决方案有哪些？\n\n缓存 null 值\n布隆过滤\n增强 id 的复杂度，避免被猜测 id 规律\n做好数据的基础格式校验\n加强用户权限校验\n做好热点参数的限流\n\n 缓存雪崩问题及解决思路\n缓存雪崩是指在同一时段大量的缓存 key 同时失效或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力。\n解决方案：\n\n给不同的 Key 的 TTL 添加随机值\n利用 Redis 集群提高服务的可用性\n给缓存业务添加降级限流策略\n给业务添加多级缓存\n\n\n 缓存击穿问题及解决思路\n缓存击穿问题也叫热点 Key 问题，就是一个被高并发访问并且缓存重建业务较复杂的 key 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\n常见的解决方案有两种：\n\n互斥锁\n逻辑过期\n\n逻辑分析：假设线程 1 在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程 1 走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程 1 没有走完的时候，后续的线程 2，线程 3，线程 4 同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大\n\n解决方案一、使用锁来解决：\n因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用 tryLock 方法 + double check 来解决这样的问题。\n假设现在线程 1 过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程 1 就会一个人去执行逻辑，假设现在线程 2 过来，线程 2 在执行过程中，并没有获得到锁，那么线程 2 就可以进行到休眠，直到线程 1 把锁释放后，线程 2 获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。\n\n解决方案二、逻辑过期方案\n方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对 key 设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。\n我们把过期时间设置在 redis 的 value 中，注意：这个过期时间并不会直接作用于 redis，而是我们后续通过逻辑去处理。假设线程 1 去查询缓存，然后从 value 中判断出来当前的数据已经过期了，此时线程 1 去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程 1 直接进行返回，假设现在线程 3 过来访问，由于线程线程 2 持有着锁，所以线程 3 无法获得锁，线程 3 也直接返回数据，只有等到新开的线程 2 把重建数据构建完后，其他线程才能走返回正确的数据。\n这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。\n\n进行对比\n互斥锁方案： 由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响\n逻辑过期方案： 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦\n\n 利用互斥锁解决缓存击穿问题\n核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询\n如果获取到了锁的线程，再去进行查询，查询后将数据写入 redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿\n\n操作锁的代码：\n核心思路就是利用 redis 的 setnx 方法来表示获取锁，该方法含义是 redis 中如果没有这个 key，则插入成功，返回 1，在 stringRedisTemplate 中返回 true， 如果有这个 key 则插入失败，则返回 0，在 stringRedisTemplate 返回 false，我们可以通过 true，或者是 false，来表示是否有线程成功插入 key，成功插入的 key 的线程我们认为他就是获得到锁的线程。\nprivate boolean tryLock(String key) &#123;    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \"1\", 10, TimeUnit.SECONDS);    return BooleanUtil.isTrue(flag);&#125;private void unlock(String key) &#123;    stringRedisTemplate.delete(key);&#125;\n操作代码：\npublic Shop queryWithMutex(Long id)  &#123;       String key = CACHE_SHOP_KEY + id;       // 1、从redis中查询商铺缓存       String shopJson = stringRedisTemplate.opsForValue().get(\"key\");       // 2、判断是否存在       if (StrUtil.isNotBlank(shopJson)) &#123;           // 存在,直接返回           return JSONUtil.toBean(shopJson, Shop.class);       &#125;       //判断命中的值是否是空值       if (shopJson != null) &#123;           //返回一个错误信息           return null;       &#125;       // 4.实现缓存重构       //4.1 获取互斥锁       String lockKey = \"lock:shop:\" + id;       Shop shop = null;       try &#123;           boolean isLock = tryLock(lockKey);           // 4.2 判断否获取成功           if(!isLock)&#123;               //4.3 失败，则休眠重试               Thread.sleep(50);               return queryWithMutex(id);           &#125;           //4.4 成功，根据id查询数据库            shop = getById(id);           // 5.不存在，返回错误           if(shop == null)&#123;                //将空值写入redis               stringRedisTemplate.opsForValue().set(key,\"\",CACHE_NULL_TTL,TimeUnit.MINUTES);               //返回错误信息               return null;           &#125;           //6.写入redis           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);       &#125;catch (Exception e)&#123;           throw new RuntimeException(e);       &#125;       finally &#123;           //7.释放互斥锁           unlock(lockKey);       &#125;       return shop;   &#125;\n 利用逻辑过期解决缓存击穿问题\n需求：修改根据 id 查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题\n思路分析：当用户开始查询 redis 时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将 value 取出，判断 value 中的过期时间是否满足，如果没有过期，则直接返回 redis 中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。\n\n如果封装数据：因为现在 redis 中存储的数据的 value 需要带上过期时间，此时要么你去修改原来的实体类，要么你\n步骤一、\n新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。\n@Datapublic class RedisData &#123;    private LocalDateTime expireTime;    private Object data;&#125;\n步骤二、\n在ShopServiceImpl 新增此方法，利用单元测试进行缓存预热\n\n在测试类中\n\n步骤三：正式代码\nShopServiceImpl\nprivate static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);public Shop queryWithLogicalExpire( Long id ) &#123;    String key = CACHE_SHOP_KEY + id;    // 1.从redis查询商铺缓存    String json = stringRedisTemplate.opsForValue().get(key);    // 2.判断是否存在    if (StrUtil.isBlank(json)) &#123;        // 3.存在，直接返回        return null;    &#125;    // 4.命中，需要先把json反序列化为对象    RedisData redisData = JSONUtil.toBean(json, RedisData.class);    Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);    LocalDateTime expireTime = redisData.getExpireTime();    // 5.判断是否过期    if(expireTime.isAfter(LocalDateTime.now())) &#123;        // 5.1.未过期，直接返回店铺信息        return shop;    &#125;    // 5.2.已过期，需要缓存重建    // 6.缓存重建    // 6.1.获取互斥锁    String lockKey = LOCK_SHOP_KEY + id;    boolean isLock = tryLock(lockKey);    // 6.2.判断是否获取锁成功    if (isLock)&#123;        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;            try&#123;                //重建缓存                this.saveShop2Redis(id,20L);            &#125;catch (Exception e)&#123;                throw new RuntimeException(e);            &#125;finally &#123;                unlock(lockKey);            &#125;        &#125;);    &#125;    // 6.4.返回过期的商铺信息    return shop;&#125;\n 封装 Redis 工具类\n基于 StringRedisTemplate 封装一个缓存工具类，满足下列需求：\n\n方法 1：将任意 Java 对象序列化为 json 并存储在 string 类型的 key 中，并且可以设置 TTL 过期时间\n方法 2：将任意 Java 对象序列化为 json 并存储在 string 类型的 key 中，并且可以设置逻辑过期时间，用于处理缓\n\n存击穿问题\n\n方法 3：根据指定的 key 查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题\n方法 4：根据指定的 key 查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题\n\n将逻辑进行封装\n@Slf4j@Componentpublic class CacheClient &#123;    private final StringRedisTemplate stringRedisTemplate;    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);    public CacheClient(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    public void set(String key, Object value, Long time, TimeUnit unit) &#123;        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);    &#125;    public void setWithLogicalExpire(String key, Object value, Long time, TimeUnit unit) &#123;        // 设置逻辑过期        RedisData redisData = new RedisData();        redisData.setData(value);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));        // 写入Redis        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));    &#125;    public &lt;R,ID&gt; R queryWithPassThrough(            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)&#123;        String key = keyPrefix + id;        // 1.从redis查询商铺缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isNotBlank(json)) &#123;            // 3.存在，直接返回            return JSONUtil.toBean(json, type);        &#125;        // 判断命中的是否是空值        if (json != null) &#123;            // 返回一个错误信息            return null;        &#125;        // 4.不存在，根据id查询数据库        R r = dbFallback.apply(id);        // 5.不存在，返回错误        if (r == null) &#123;            // 将空值写入redis            stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);            // 返回错误信息            return null;        &#125;        // 6.存在，写入redis        this.set(key, r, time, unit);        return r;    &#125;    public &lt;R, ID&gt; R queryWithLogicalExpire(            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 1.从redis查询商铺缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isBlank(json)) &#123;            // 3.存在，直接返回            return null;        &#125;        // 4.命中，需要先把json反序列化为对象        RedisData redisData = JSONUtil.toBean(json, RedisData.class);        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);        LocalDateTime expireTime = redisData.getExpireTime();        // 5.判断是否过期        if(expireTime.isAfter(LocalDateTime.now())) &#123;            // 5.1.未过期，直接返回店铺信息            return r;        &#125;        // 5.2.已过期，需要缓存重建        // 6.缓存重建        // 6.1.获取互斥锁        String lockKey = LOCK_SHOP_KEY + id;        boolean isLock = tryLock(lockKey);        // 6.2.判断是否获取锁成功        if (isLock)&#123;            // 6.3.成功，开启独立线程，实现缓存重建            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;                try &#123;                    // 查询数据库                    R newR = dbFallback.apply(id);                    // 重建缓存                    this.setWithLogicalExpire(key, newR, time, unit);                &#125; catch (Exception e) &#123;                    throw new RuntimeException(e);                &#125;finally &#123;                    // 释放锁                    unlock(lockKey);                &#125;            &#125;);        &#125;        // 6.4.返回过期的商铺信息        return r;    &#125;    public &lt;R, ID&gt; R queryWithMutex(            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 1.从redis查询商铺缓存        String shopJson = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isNotBlank(shopJson)) &#123;            // 3.存在，直接返回            return JSONUtil.toBean(shopJson, type);        &#125;        // 判断命中的是否是空值        if (shopJson != null) &#123;            // 返回一个错误信息            return null;        &#125;        // 4.实现缓存重建        // 4.1.获取互斥锁        String lockKey = LOCK_SHOP_KEY + id;        R r = null;        try &#123;            boolean isLock = tryLock(lockKey);            // 4.2.判断是否获取成功            if (!isLock) &#123;                // 4.3.获取锁失败，休眠并重试                Thread.sleep(50);                return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);            &#125;            // 4.4.获取锁成功，根据id查询数据库            r = dbFallback.apply(id);            // 5.不存在，返回错误            if (r == null) &#123;                // 将空值写入redis                stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);                // 返回错误信息                return null;            &#125;            // 6.存在，写入redis            this.set(key, r, time, unit);        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;finally &#123;            // 7.释放锁            unlock(lockKey);        &#125;        // 8.返回        return r;    &#125;    private boolean tryLock(String key) &#123;        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \"1\", 10, TimeUnit.SECONDS);        return BooleanUtil.isTrue(flag);    &#125;    private void unlock(String key) &#123;        stringRedisTemplate.delete(key);    &#125;&#125;\n在 ShopServiceImpl 中\n@Resourceprivate CacheClient cacheClient; @Override    public Result queryById(Long id) &#123;        // 解决缓存穿透        Shop shop = cacheClient                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);        // 互斥锁解决缓存击穿        // Shop shop = cacheClient        //         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);        // 逻辑过期解决缓存击穿        // Shop shop = cacheClient        //         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);        if (shop == null) &#123;            return Result.fail(\"店铺不存在！\");        &#125;        // 7.返回        return Result.ok(shop);    &#125;\n 优惠卷秒杀\n 全局唯一 ID\n每个店铺都可以发布优惠券：\n\n当用户抢购时，就会生成订单并保存到 tb_voucher_order 这张表中，而订单表如果使用数据库自增 ID 就存在一些问题：\n\nid 的规律性太明显\n受单表数据量的限制\n\n场景分析：如果我们的 id 具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。\n场景分析二：随着我们商城规模越来越大，mysql 的单表的容量不宜超过 500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的 id 是不能一样的， 于是乎我们需要保证 id 的唯一性。\n全局 ID 生成器，是一种在分布式系统下用来生成全局唯一 ID 的工具，一般要满足下列特性：\n\n为了增加 ID 的安全性，我们可以不直接使用 Redis 自增的数值，而是拼接一些其它信息：\nID 的组成部分：符号位：1bit，永远为 0\n时间戳：31bit，以秒为单位，可以使用 69 年\n序列号：32bit，秒内的计数器，支持每秒产生 2^32 个不同 ID\n Redis 实现全局唯一 Id\n@Componentpublic class RedisIdWorker &#123;    /**     * 开始时间戳     */    private static final long BEGIN_TIMESTAMP = 1640995200L;    /**     * 序列号的位数     */    private static final int COUNT_BITS = 32;    private StringRedisTemplate stringRedisTemplate;    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    public long nextId(String keyPrefix) &#123;        // 1.生成时间戳        LocalDateTime now = LocalDateTime.now();        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);        long timestamp = nowSecond - BEGIN_TIMESTAMP;        // 2.生成序列号        // 2.1.获取当前日期，精确到天        String date = now.format(DateTimeFormatter.ofPattern(\"yyyy:MM:dd\"));        // 2.2.自增长        long count = stringRedisTemplate.opsForValue().increment(\"icr:\" + keyPrefix + \":\" + date);        // 3.拼接并返回        return timestamp &lt;&lt; COUNT_BITS | count;    &#125;&#125;\n测试类\n知识小贴士：关于 countdownlatch\ncountdownlatch 名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题\n我们如果没有 CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到 CountDownLatch\nCountDownLatch 中有两个最重要的方法\n1、countDown\n2、await\nawait 方法 是阻塞方法，我们担心分线程没有执行完时，main 线程就先执行，所以使用 await 可以让 main 线程阻塞，那么什么时候 main 线程不再阻塞呢？当 CountDownLatch 内部维护的 变量变为 0 时，就不再阻塞，直接放行，那么什么时候 CountDownLatch 维护的变量变为 0 呢，我们只需要调用一次 countDown ，内部变量就减少 1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是 0，此时 await 就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。\n@Testvoid testIdWorker() throws InterruptedException &#123;    CountDownLatch latch = new CountDownLatch(300);    Runnable task = () -&gt; &#123;        for (int i = 0; i &lt; 100; i++) &#123;            long id = redisIdWorker.nextId(\"order\");            System.out.println(\"id = \" + id);        &#125;        latch.countDown();    &#125;;    long begin = System.currentTimeMillis();    for (int i = 0; i &lt; 300; i++) &#123;        es.submit(task);    &#125;    latch.await();    long end = System.currentTimeMillis();    System.out.println(\"time = \" + (end - begin));&#125;\n 添加优惠卷\n每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：\n\ntb_voucher：优惠券的基本信息，优惠金额、使用规则等\ntb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息\n平价卷由于优惠力度并不是很大，所以是可以任意领取\n而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段\n**新增普通卷代码： **VoucherController\n@PostMappingpublic Result addVoucher(@RequestBody Voucher voucher) &#123;    voucherService.save(voucher);    return Result.ok(voucher.getId());&#125;\n新增秒杀卷代码：\nVoucherController\n@PostMapping(\"seckill\")public Result addSeckillVoucher(@RequestBody Voucher voucher) &#123;    voucherService.addSeckillVoucher(voucher);    return Result.ok(voucher.getId());&#125;\nVoucherServiceImpl\n@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123;    // 保存优惠券    save(voucher);    // 保存秒杀信息    SeckillVoucher seckillVoucher = new SeckillVoucher();    seckillVoucher.setVoucherId(voucher.getId());    seckillVoucher.setStock(voucher.getStock());    seckillVoucher.setBeginTime(voucher.getBeginTime());    seckillVoucher.setEndTime(voucher.getEndTime());    seckillVoucherService.save(seckillVoucher);    // 保存秒杀库存到Redis中    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125;\n 实现秒杀下单\n下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的 controller 即可\n\n秒杀下单应该思考的内容：\n下单时需要判断两点：\n\n秒杀是否开始或结束，如果尚未开始或已经结束则无法下单\n库存是否充足，不足则无法下单\n\n下单核心逻辑分析：\n当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件\n比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单 id，如果有一个条件不满足则直接结束。\n\nVoucherOrderServiceImpl\n@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(\"秒杀尚未开始！\");    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(\"秒杀已经结束！\");    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(\"库存不足！\");    &#125;    //5，扣减库存    boolean success = seckillVoucherService.update()            .setSql(\"stock= stock -1\")            .eq(\"voucher_id\", voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(\"库存不足！\");    &#125;    //6.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 6.1.订单id    long orderId = redisIdWorker.nextId(\"order\");    voucherOrder.setId(orderId);    // 6.2.用户id    Long userId = UserHolder.getUser().getId();    voucherOrder.setUserId(userId);    // 6.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;\n 库存超卖问题分析\n有关超卖问题分析：在我们原有代码中是这么写的\nif (voucher.getStock() &lt; 1) &#123;       // 库存不足       return Result.fail(\"库存不足！\");   &#125;   //5，扣减库存   boolean success = seckillVoucherService.update()           .setSql(\"stock= stock -1\")           .eq(\"voucher_id\", voucherId).update();   if (!success) &#123;       //扣减库存       return Result.fail(\"库存不足！\");   &#125;\n假设线程 1 过来查询库存，判断出来库存大于 1，正准备去扣减库存，但是还没有来得及去扣减，此时线程 2 过来，线程 2 也去查询库存，发现这个数量一定也大于 1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。\n\n超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：\n\n悲观锁：\n悲观锁可以实现对于数据的串行化执行，比如 syn，和 lock 都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等\n乐观锁：\n乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大 1 ，如果大 1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大 1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大 1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如 cas\n乐观锁的典型代表：就是 cas，利用 cas 进行无锁化机制加锁，var5 是操作前读取的内存值，while 中的 var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值\n其中 do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。\nint var5;do &#123;    var5 = this.getIntVolatile(var1, var2);&#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));return var5;\n课程中的使用方式：\n课程中的使用方式是没有像 cas 一样带自旋的操作，也没有对 version 的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求 version 如果是 1 的情况下，才能操作，那么第一个线程在操作后，数据库中的 version 变成了 2，但是他自己满足 version=1 ，所以没有问题，此时线程 2 执行，线程 2 最后也需要加上条件 version =1 ，但是现在由于线程 1 已经操作过了，所以线程 2，操作时就不满足 version=1 的条件了，所以线程 2 无法执行成功\n\n 乐观锁解决超卖问题\n修改代码方案一、\nVoucherOrderServiceImpl 在扣减库存时，改为：\nboolean success = seckillVoucherService.update()            .setSql(\"stock= stock -1\") //set stock = stock -1            .eq(\"voucher_id\", voucherId).eq(\"stock\",voucher.getStock()).update(); //where id = ？ and stock = ?\n以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设 100 个线程同时都拿到了 100 的库存，然后大家一起去进行扣减，但是 100 个人中只有 1 个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败\n修改代码方案二、\n之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成 stock 大于 0 即可\nboolean success = seckillVoucherService.update()            .setSql(\"stock= stock -1\")            .eq(\"voucher_id\", voucherId).update().gt(\"stock\",0); //where id = ? and stock &gt; 0\n知识小扩展：\n针对 cas 中的自旋压力过大，我们可以使用 Longaddr 这个类去解决\nJava8 提供的一个对 AtomicLong 改进后的一个类，LongAdder\n大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用 syn 来的好\n所以利用这么一个类，LongAdder 来进行优化\n如果获取某个值，则会对 cell 和 base 的值进行递增，最后返回一个完整的值\n\n 优惠券秒杀-一人一单\n需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单\n现在的问题在于：\n优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单\n具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷 id 和用户 id 查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单\n\nVoucherOrderServiceImpl\n初步代码：增加一人一单逻辑\n@Overridepublic Result seckillVoucher(Long voucherId) &#123;    // 1.查询优惠券    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);    // 2.判断秒杀是否开始    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(\"秒杀尚未开始！\");    &#125;    // 3.判断秒杀是否已经结束    if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;        // 尚未开始        return Result.fail(\"秒杀已经结束！\");    &#125;    // 4.判断库存是否充足    if (voucher.getStock() &lt; 1) &#123;        // 库存不足        return Result.fail(\"库存不足！\");    &#125;    // 5.一人一单逻辑    // 5.1.用户id    Long userId = UserHolder.getUser().getId();    int count = query().eq(\"user_id\", userId).eq(\"voucher_id\", voucherId).count();    // 5.2.判断是否存在    if (count &gt; 0) &#123;        // 用户已经购买过了        return Result.fail(\"用户已经购买过一次！\");    &#125;    //6，扣减库存    boolean success = seckillVoucherService.update()            .setSql(\"stock= stock -1\")            .eq(\"voucher_id\", voucherId).update();    if (!success) &#123;        //扣减库存        return Result.fail(\"库存不足！\");    &#125;    //7.创建订单    VoucherOrder voucherOrder = new VoucherOrder();    // 7.1.订单id    long orderId = redisIdWorker.nextId(\"order\");    voucherOrder.setId(orderId);    voucherOrder.setUserId(userId);    // 7.3.代金券id    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    return Result.ok(orderId);&#125;\n存在问题： 现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作\n注意： 在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个 createVoucherOrder 方法，同时为了确保他线程安全，在方法上添加了一把 synchronized 锁\n@Transactionalpublic synchronized Result createVoucherOrder(Long voucherId) &#123;\tLong userId = UserHolder.getUser().getId();         // 5.1.查询订单        int count = query().eq(\"user_id\", userId).eq(\"voucher_id\", voucherId).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了            return Result.fail(\"用户已经购买过一次！\");        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(\"stock = stock - 1\") // set stock = stock - 1                .eq(\"voucher_id\", voucherId).gt(\"stock\", 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            return Result.fail(\"库存不足！\");        &#125;        // 7.创建订单        VoucherOrder voucherOrder = new VoucherOrder();        // 7.1.订单id        long orderId = redisIdWorker.nextId(\"order\");        voucherOrder.setId(orderId);        // 7.2.用户id        voucherOrder.setUserId(userId);        // 7.3.代金券id        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        // 7.返回订单id        return Result.ok(orderId);&#125;\n，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制锁粒度 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：\nintern() 这个方法是从常量池中拿到数据，如果我们直接使用 userId.toString() 他拿到的对象实际上是不同的对象，new 出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用 intern()方法\n@Transactionalpublic  Result createVoucherOrder(Long voucherId) &#123;\tLong userId = UserHolder.getUser().getId();\tsynchronized(userId.toString().intern())&#123;         // 5.1.查询订单        int count = query().eq(\"user_id\", userId).eq(\"voucher_id\", voucherId).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了            return Result.fail(\"用户已经购买过一次！\");        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(\"stock = stock - 1\") // set stock = stock - 1                .eq(\"voucher_id\", voucherId).gt(\"stock\", 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            return Result.fail(\"库存不足！\");        &#125;        // 7.创建订单        VoucherOrder voucherOrder = new VoucherOrder();        // 7.1.订单id        long orderId = redisIdWorker.nextId(\"order\");        voucherOrder.setId(orderId);        // 7.2.用户id        voucherOrder.setUserId(userId);        // 7.3.代金券id        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        // 7.返回订单id        return Result.ok(orderId);    &#125;&#125;\n但是以上代码还是存在问题，问题的原因在于当前方法被 spring 的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：\n在 seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度\n\n但是以上做法依然有问题，因为你调用的方法，其实是 this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务\n\n 集群环境下的并发问题\n通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。\n1、我们将服务启动两份，端口分别为 8081 和 8082：\n\n2、然后修改 nginx 的 conf 目录下的 nginx.conf 文件，配置反向代理和负载均衡：\n\n具体操作(略)\n有关锁失效原因分析\n由于现在我们部署了多个 tomcat，每个 tomcat 都有一个属于自己的 jvm，那么假设在服务器 A 的 tomcat 内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器 B 的 tomcat 内部，又有两个线程，但是他们的锁对象写的虽然和服务器 A 一样，但是锁对象却不是同一个，所以线程 3 和线程 4 可以实现互斥，但是却无法和线程 1 和线程 2 实现互斥，这就是 集群环境下，syn 锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。\n\n 分布式锁\n 基本原理和实现方式对比\n分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。\n分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路\n\n那么分布式锁他应该满足一些什么样的条件呢？\n可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思\n互斥：互斥是分布式锁的最基本的条件，使得程序串行执行\n高可用：程序不易崩溃，时时刻刻都保证较高的可用性\n高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能\n安全性：安全也是程序中必不可少的一环\n\n常见的分布式锁有三种\nMysql：mysql 本身就带有锁机制，但是由于 mysql 性能本身一般，所以采用分布式锁的情况下，其实使用 mysql 作为分布式锁比较少见\nRedis：redis 作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用 redis 或者 zookeeper 作为分布式锁，利用 setnx 这个方法，如果插入 key 成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁\nZookeeper：zookeeper 也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解 zookeeper 的原理和分布式锁的实现，所以不过多阐述\n\n Redis 分布式锁的实现核心思路\n实现分布式锁时需要实现的两个基本方法：\n\n\n获取锁：\n\n互斥：确保只能有一个线程获取锁\n非阻塞：尝试一次，成功返回 true，失败返回 false\n\n\n\n释放锁：\n\n手动释放\n超时释放：获取锁时添加一个超时时间\n\n\n\n\n核心思路：\n我们利用 redis 的 setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个 key 了，返回了 1，如果结果是 1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可\n\n 实现分布式锁版本一\n\n加锁逻辑\n\n锁的基本接口\n\nSimpleRedisLock\n利用 setnx 方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性\nprivate static final String KEY_PREFIX=\"lock:\"@Overridepublic boolean tryLock(long timeoutSec) &#123;    // 获取线程标示    String threadId = Thread.currentThread().getId()    // 获取锁    Boolean success = stringRedisTemplate.opsForValue()            .setIfAbsent(KEY_PREFIX + name, threadId + \"\", timeoutSec, TimeUnit.SECONDS);    return Boolean.TRUE.equals(success);&#125;\n\n释放锁逻辑\n\nSimpleRedisLock\n释放锁，防止删除别人的锁\npublic void unlock() &#123;    //通过del删除锁    stringRedisTemplate.delete(KEY_PREFIX + name);&#125;\n\n修改业务代码\n\n@Override  public Result seckillVoucher(Long voucherId) &#123;      // 1.查询优惠券      SeckillVoucher voucher = seckillVoucherService.getById(voucherId);      // 2.判断秒杀是否开始      if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;          // 尚未开始          return Result.fail(\"秒杀尚未开始！\");      &#125;      // 3.判断秒杀是否已经结束      if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;          // 尚未开始          return Result.fail(\"秒杀已经结束！\");      &#125;      // 4.判断库存是否充足      if (voucher.getStock() &lt; 1) &#123;          // 库存不足          return Result.fail(\"库存不足！\");      &#125;      Long userId = UserHolder.getUser().getId();      //创建锁对象(新增代码)      SimpleRedisLock lock = new SimpleRedisLock(\"order:\" + userId, stringRedisTemplate);      //获取锁对象      boolean isLock = lock.tryLock(1200);//加锁失败      if (!isLock) &#123;          return Result.fail(\"不允许重复下单\");      &#125;      try &#123;          //获取代理对象(事务)          IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();          return proxy.createVoucherOrder(voucherId);      &#125; finally &#123;          //释放锁          lock.unlock();      &#125;  &#125;\n Redis 分布式锁误删情况说明\n逻辑说明：\n持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程 2 来尝试获得锁，就拿到了这把锁，然后线程 2 在持有锁执行过程中，线程 1 反应过来，继续执行，而线程 1 执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程 2 的锁进行删除，这就是误删别人锁的情况说明\n解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程 1 卡顿，锁自动释放，线程 2 进入到锁的内部执行逻辑，此时线程 1 反应过来，然后删除锁，但是线程 1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程 2 走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。\n\n 解决 Redis 分布式锁误删问题\n需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用 UUID 表示）\n在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致\n\n如果一致则释放锁\n如果不一致则不释放锁\n\n核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。\n\n具体代码如下：加锁\nprivate static final String ID_PREFIX = UUID.randomUUID().toString(true) + \"-\";@Overridepublic boolean tryLock(long timeoutSec) &#123;   // 获取线程标示   String threadId = ID_PREFIX + Thread.currentThread().getId();   // 获取锁   Boolean success = stringRedisTemplate.opsForValue()                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);   return Boolean.TRUE.equals(success);&#125;\n释放锁\npublic void unlock() &#123;    // 获取线程标示    String threadId = ID_PREFIX + Thread.currentThread().getId();    // 获取锁中的标示    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);    // 判断标示是否一致    if(threadId.equals(id)) &#123;        // 释放锁        stringRedisTemplate.delete(KEY_PREFIX + name);    &#125;&#125;\n有关代码实操说明：\n在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的 value 值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。\n 分布式锁的原子性问题\n更为极端的误删逻辑说明：\n线程 1 现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程 2 进来，但是线程 1 他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程 1 的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，\n\n Lua 脚本解决多条命令原子性问题\nRedis 提供了 Lua 脚本功能，在一个脚本中编写多条 Redis 命令，确保多条命令执行时的原子性。Lua 是一种编程语言，它的基本语法大家可以参考网站：https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。\n这里重点介绍 Redis 提供的调用函数，语法如下：\nredis.call('命令名称', 'key', '其它参数', ...)\n例如，我们要执行 set name jack，则脚本是这样：\n# 执行 set name jackredis.call('set', 'name', 'jack')\n例如，我们要先执行 set name Rose，再执行 get name，则脚本如下：\n# 先执行 set name jackredis.call('set', 'name', 'Rose')# 再执行 get namelocal name = redis.call('get', 'name')# 返回return name\n写好脚本以后，需要用 Redis 命令来调用脚本，调用脚本的常见命令如下：\n\n例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：\n\n如果脚本中的 key、value 不想写死，可以作为参数传递。key 类型参数会放入 KEYS 数组，其它参数会放入 ARGV 数组，在脚本中可以从 KEYS 和 ARGV 数组获取这些参数：\n\n接下来我们来回一下我们释放锁的逻辑：\n释放锁的业务流程是这样的\n​ 1、获取锁中的线程标示\n​ 2、判断是否与指定的标示（当前线程标示）一致\n​ 3、如果一致则释放锁（删除）\n​ 4、如果不一致则什么都不做\n如果用 Lua 脚本来表示则是这样的：\n最终我们操作 redis 的拿锁比锁删锁的 lua 脚本就会变成这样\n-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示-- 获取锁中的标示，判断是否与当前线程标示一致if (redis.call('GET', KEYS[1]) == ARGV[1]) then  -- 一致，则删除锁  return redis.call('DEL', KEYS[1])end-- 不一致，则直接返回return 0\n 利用 Java 代码调用 Lua 脚本改造分布式锁\nlua 脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些 lua 表达式的含义。\n我们的 RedisTemplate 中，可以利用 execute 方法去执行 lua 脚本，参数对应关系就如下图股\n\nJava 代码\nprivate static final DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;    static &#123;        UNLOCK_SCRIPT = new DefaultRedisScript&lt;&gt;();        UNLOCK_SCRIPT.setLocation(new ClassPathResource(\"unlock.lua\"));        UNLOCK_SCRIPT.setResultType(Long.class);    &#125;public void unlock() &#123;    // 调用lua脚本    stringRedisTemplate.execute(            UNLOCK_SCRIPT,            Collections.singletonList(KEY_PREFIX + name),            ID_PREFIX + Thread.currentThread().getId());&#125;经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~\n小总结：\n基于 Redis 的分布式锁实现思路：\n\n利用 set nx ex 获取锁，并设置过期时间，保存线程标示\n释放锁时先判断线程标示是否与自己一致，一致则删除锁\n\n特性：\n\n利用 set nx 满足互斥性\n利用 set ex 保证故障时锁依然能释放，避免死锁，提高安全性\n利用 Redis 集群保证高可用和高并发特性\n\n\n\n\n\n笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过 lua 表达式来解决这个问题\n但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个 30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来 10 块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习 redission 啦\n测试逻辑：\n第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行 lua 来抢锁，当第一天线程利用 lua 删除锁时，lua 能保证他不能删除他的锁，第二个线程删除锁时，利用 lua 同样可以保证不会删除别人的锁，同时还能保证原子性。\n 分布式锁-redission\n 分布式锁-redission 功能介绍\n基于 setnx 实现的分布式锁存在下面的问题：\n重入问题：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如 HashTable 这样的代码中，他的方法都是使用 synchronized 修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的 synchronized 和 Lock 锁都是可重入的。\n不可重试：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。\n超时释放： 我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了 lua 表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患\n主从一致性： 如果 Redis 提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。\n\n那么什么是 Redission 呢\nRedisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。\nRedission 提供了分布式锁的多种多样的功能\n\n 分布式锁-Redission 快速入门\n引入依赖：\n&lt;dependency&gt;\t&lt;groupId&gt;org.redisson&lt;/groupId&gt;\t&lt;artifactId&gt;redisson&lt;/artifactId&gt;\t&lt;version&gt;3.13.6&lt;/version&gt;&lt;/dependency&gt;\n配置 Redisson 客户端：\n@Configurationpublic class RedissonConfig &#123;    @Bean    public RedissonClient redissonClient()&#123;        // 配置        Config config = new Config();        config.useSingleServer().setAddress(\"redis://192.168.150.101:6379\")            .setPassword(\"123321\");        // 创建RedissonClient对象        return Redisson.create(config);    &#125;&#125;\n如何使用 Redission 的分布式锁\n@Resourceprivate RedissionClient redissonClient;@Testvoid testRedisson() throws Exception&#123;    //获取锁(可重入)，指定锁的名称    RLock lock = redissonClient.getLock(\"anyLock\");    //尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位    boolean isLock = lock.tryLock(1,10,TimeUnit.SECONDS);    //判断获取锁成功    if(isLock)&#123;        try&#123;            System.out.println(\"执行业务\");        &#125;finally&#123;            //释放锁            lock.unlock();        &#125;    &#125;&#125;\n在 VoucherOrderServiceImpl\n注入 RedissonClient\n@Resourceprivate RedissonClient redissonClient;@Overridepublic Result seckillVoucher(Long voucherId) &#123;        // 1.查询优惠券        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);        // 2.判断秒杀是否开始        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(\"秒杀尚未开始！\");        &#125;        // 3.判断秒杀是否已经结束        if (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;            // 尚未开始            return Result.fail(\"秒杀已经结束！\");        &#125;        // 4.判断库存是否充足        if (voucher.getStock() &lt; 1) &#123;            // 库存不足            return Result.fail(\"库存不足！\");        &#125;        Long userId = UserHolder.getUser().getId();        //创建锁对象 这个代码不用了，因为我们现在要使用分布式锁        //SimpleRedisLock lock = new SimpleRedisLock(\"order:\" + userId, stringRedisTemplate);        RLock lock = redissonClient.getLock(\"lock:order:\" + userId);        //获取锁对象        boolean isLock = lock.tryLock();\t\t//加锁失败        if (!isLock) &#123;            return Result.fail(\"不允许重复下单\");        &#125;        try &#123;            //获取代理对象(事务)            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125; finally &#123;            //释放锁            lock.unlock();        &#125; &#125;\n 分布式锁-redission 可重入锁原理\n在 Lock 锁中，他是借助于底层的一个 voaltile 的一个 state 变量来记录重入的状态的，比如当前没有人持有这把锁，那么 state=0，假如有人持有这把锁，那么 state=1，如果持有这把锁的人再次持有这把锁，那么 state 就会+1 ，如果是对于 synchronized 而言，他在 c 语言代码中会有一个 count，原理和 state 类似，也是重入一次就加一，释放一次就-1 ，直到减少成 0 时，表示当前这把锁没有被人持有。\n在 redission 中，我们的也支持支持可重入锁\n在分布式锁中，他采用 hash 结构用来存储锁，其中大 key 表示表示这把锁是否存在，用小 key 表示当前这把锁被哪个线程持有，所以接下来我们一起分析一下当前的这个 lua 表达式\n这个地方一共有 3 个参数\nKEYS[1] ： 锁名称\nARGV[1]： 锁失效时间\n**ARGV[2]： id + **​ **&quot;**​ **😗*​ **&quot;​ ** + threadId; 锁的小 key\nexists: 判断数据是否存在 name：是 lock 是否存在,如果==0，就表示当前这把锁不存在\nredis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往 redis 里边去写数据 ，写成一个 hash 结构\nLock{\n​ id + **&quot;**​ **😗*​ &quot; + threadId : 1\n}\n如果当前这把锁存在，则第一个条件不满足，再判断\nredis.call(‘hexists’, KEYS[1], ARGV[2]) == 1\n此时需要通过大 key+小 key 判断当前这把锁是否是属于自己的，如果是自己的，则进行\nredis.call(‘hincrby’, KEYS[1], ARGV[2], 1)\n将当前这个锁的 value 进行+1 ，redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回 pttl，即为当前这把锁的失效时间\n如果小伙帮们看了前边的源码， 你会发现他会去判断当前这个方法的返回值是否为 null，如果是 null，则对应则前两个 if 对应的条件，退出抢锁逻辑，如果返回的不是 null，即走了第三个分支，在源码处会进行 while(true)的自旋抢锁。\n\"if (redis.call('exists', KEYS[1]) == 0) then \" +                  \"redis.call('hset', KEYS[1], ARGV[2], 1); \" +                  \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +                  \"return nil; \" +              \"end; \" +              \"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \" +                  \"redis.call('hincrby', KEYS[1], ARGV[2], 1); \" +                  \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +                  \"return nil; \" +              \"end; \" +              \"return redis.call('pttl', KEYS[1]);\"\n\n 分布式锁-redission 锁重试和 WatchDog 机制\n说明：由于课程中已经说明了有关 tryLock 的源码解析以及其看门狗原理，所以笔者在这里给大家分析 lock()方法的源码解析，希望大家在学习过程中，能够掌握更多的知识\n抢锁过程中，获得当前线程，通过 tryAcquire 进行抢锁，该抢锁逻辑和之前逻辑相同\n1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回 null\n2、判断当前这把锁是否是属于当前线程，如果是，则返回 null\n所以如果返回是 null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个 while( true) 再次进行 tryAcquire 进行抢锁\nlong threadId = Thread.currentThread().getId();Long ttl = tryAcquire(-1, leaseTime, unit, threadId);// lock acquiredif (ttl == null) &#123;    return;&#125;\n接下来会有一个条件分支，因为 lock 方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则 leaseTime 是他本身，所以如果传入了参数，此时 leaseTime != -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑\nif (leaseTime != -1) &#123;    return tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);&#125;\n如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()\nttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程\nRFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;    if (e != null) &#123;        return;    &#125;    // lock acquired    if (ttlRemaining == null) &#123;        scheduleExpirationRenewal(threadId);    &#125;&#125;);return ttlRemainingFuture;\n此逻辑就是续约逻辑，注意看 commandExecutor.getConnectionManager().newTimeout（） 此方法\nMethod( new TimerTask() {},参数 2 ，参数 3 )\n指的是：通过参数 2，参数 3 去描述什么时候去做参数 1 的事情，现在的情况是：10s 之后去做参数一的事情\n因为锁的失效时间是 30s，当 10s 之后，此时这个 timeTask 就触发了，他就去进行续约，把当前这把锁续约成 30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个 timeTask()，于是再过 10s 后又再设置一个 timerTask，完成不停的续约\n那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用 renewExpiration 这个方法，所以等到时间之后自然就释放了。\nprivate void renewExpiration() &#123;    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());    if (ee == null) &#123;        return;    &#125;    Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;        @Override        public void run(Timeout timeout) throws Exception &#123;            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());            if (ent == null) &#123;                return;            &#125;            Long threadId = ent.getFirstThreadId();            if (threadId == null) &#123;                return;            &#125;            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);            future.onComplete((res, e) -&gt; &#123;                if (e != null) &#123;                    log.error(\"Can't update lock \" + getName() + \" expiration\", e);                    return;                &#125;                if (res) &#123;                    // reschedule itself                    renewExpiration();                &#125;            &#125;);        &#125;    &#125;, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);    ee.setTimeout(task);&#125;\n 分布式锁-redission 锁的 MutiLock 原理\n为了提高 redis 的可用性，我们会搭建集群或者主从，现在以主从为例\n此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个 slave 变成 master，而此时新的 master 中实际上并没有锁信息，此时锁信息就已经丢掉了。\n\n为了解决这个问题，redission 提出来了 MutiLock 锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。\n\n那么 MutiLock 加锁原理是什么呢？笔者画了一幅图来说明\n当我们去设置了多个锁时，redission 会将多个锁添加到一个集合中，然后用 while 循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有 3 个锁，那么时间就是 4500ms，假设在这 4500ms 内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在 4500ms 有线程加锁失败，则会再次去进行重试.\n\n 秒杀优化\n 秒杀优化-异步秒杀思路\n我们来回顾一下下单流程\n当用户发起请求，此时会请求 nginx，nginx 会访问到 tomcat，而 tomcat 中的程序，会进行串行操作，分成如下几个步骤\n1、查询优惠卷\n2、判断秒杀库存是否足够\n3、查询订单\n4、校验是否是一人一单\n5、扣减库存\n6、创建订单\n在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？\n在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启 N 多线程，N 多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求\n\n优化方案：我们将耗时比较短的逻辑判断放入到 redis 中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行 queue 里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点\n第一个难点是我们怎么在 redis 中去快速校验一人一单，还有库存判断\n第二个难点是由于我们校验和 tomct 下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在 redis 操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步 queue 中去，后续操作中，可以通过这个 id 来查询我们 tomcat 中的下单逻辑是否完成了。\n\n我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导 redis 中去根据 key 找对应的 value 是否大于 0 即可，如果不充足，则直接结束，如果充足，继续在 redis 中判断用户是否可以下单，如果 set 集合中没有这条数据，说明他可以下单，如果 set 集合中没有这条记录，则将 userId 和优惠卷存入到 redis 中，并且返回 0，整个过程需要保证是原子性的，我们可以使用 lua 来操作\n当以上判断逻辑走完之后，我们可以判断当前 redis 中返回的结果是否是 0 ，如果是 0，则表示可以下单，则将之前说的信息存入到到 queue 中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单 id 来判断是否下单成功。\n\n 秒杀优化-Redis 完成秒杀资格判断\n需求：\n\n\n新增秒杀优惠券的同时，将优惠券信息保存到 Redis 中\n\n\n基于 Lua 脚本，判断秒杀库存、一人一单，决定用户是否抢购成功\n\n\n如果抢购成功，将优惠券 id 和用户 id 封装后存入阻塞队列\n\n\n开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能\n\n\n\nVoucherServiceImpl\n@Override@Transactionalpublic void addSeckillVoucher(Voucher voucher) &#123;    // 保存优惠券    save(voucher);    // 保存秒杀信息    SeckillVoucher seckillVoucher = new SeckillVoucher();    seckillVoucher.setVoucherId(voucher.getId());    seckillVoucher.setStock(voucher.getStock());    seckillVoucher.setBeginTime(voucher.getBeginTime());    seckillVoucher.setEndTime(voucher.getEndTime());    seckillVoucherService.save(seckillVoucher);    // 保存秒杀库存到Redis中    //SECKILL_STOCK_KEY 这个变量定义在RedisConstans中    //private static final String SECKILL_STOCK_KEY =\"seckill:stock:\"    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125;\n完整 lua 表达式\n-- 1.参数列表-- 1.1.优惠券idlocal voucherId = ARGV[1]-- 1.2.用户idlocal userId = ARGV[2]-- 1.3.订单idlocal orderId = ARGV[3]-- 2.数据key-- 2.1.库存keylocal stockKey = 'seckill:stock:' .. voucherId-- 2.2.订单keylocal orderKey = 'seckill:order:' .. voucherId-- 3.脚本业务-- 3.1.判断库存是否充足 get stockKeyif(tonumber(redis.call('get', stockKey)) &lt;= 0) then    -- 3.2.库存不足，返回1    return 1end-- 3.2.判断用户是否下单 SISMEMBER orderKey userIdif(redis.call('sismember', orderKey, userId) == 1) then    -- 3.3.存在，说明是重复下单，返回2    return 2end-- 3.4.扣库存 incrby stockKey -1redis.call('incrby', stockKey, -1)-- 3.5.下单（保存用户）sadd orderKey userIdredis.call('sadd', orderKey, userId)-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...redis.call('xadd', 'stream.orders', '*', 'userId', userId, 'voucherId', voucherId, 'id', orderId)return 0\n当以上 lua 表达式执行完毕后，剩下的就是根据步骤 3,4 来执行我们接下来的任务了\nVoucherOrderServiceImpl\n@Overridepublic Result seckillVoucher(Long voucherId) &#123;    //获取用户    Long userId = UserHolder.getUser().getId();    long orderId = redisIdWorker.nextId(\"order\");    // 1.执行lua脚本    Long result = stringRedisTemplate.execute(            SECKILL_SCRIPT,            Collections.emptyList(),            voucherId.toString(), userId.toString(), String.valueOf(orderId)    );    int r = result.intValue();    // 2.判断结果是否为0    if (r != 0) &#123;        // 2.1.不为0 ，代表没有购买资格        return Result.fail(r == 1 ? \"库存不足\" : \"不能重复下单\");    &#125;    //TODO 保存阻塞队列    // 3.返回订单id    return Result.ok(orderId);&#125;\n 秒杀优化-基于阻塞队列实现秒杀优化\nVoucherOrderServiceImpl\n修改下单动作，现在我们去下单时，是通过 lua 表达式去原子执行判断逻辑，如果判断我出来不为 0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是 0，则把下单的逻辑保存到队列中去，然后异步执行\n//异步处理线程池private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的@PostConstructprivate void init() &#123;   SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());&#125;// 用于线程池处理的任务// 当初始化完毕后，就会去从对列中去拿信息 private class VoucherOrderHandler implements Runnable&#123;        @Override        public void run() &#123;            while (true)&#123;                try &#123;                    // 1.获取队列中的订单信息                    VoucherOrder voucherOrder = orderTasks.take();                    // 2.创建订单                    handleVoucherOrder(voucherOrder);                &#125; catch (Exception e) &#123;                    log.error(\"处理订单异常\", e);                &#125;          \t &#125;        &#125;       private void handleVoucherOrder(VoucherOrder voucherOrder) &#123;            //1.获取用户            Long userId = voucherOrder.getUserId();            // 2.创建锁对象            RLock redisLock = redissonClient.getLock(\"lock:order:\" + userId);            // 3.尝试获取锁            boolean isLock = redisLock.lock();            // 4.判断是否获得锁成功            if (!isLock) &#123;                // 获取锁失败，直接返回失败或者重试                log.error(\"不允许重复下单！\");                return;            &#125;            try &#123;\t\t\t\t//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效                proxy.createVoucherOrder(voucherOrder);            &#125; finally &#123;                // 释放锁                redisLock.unlock();            &#125;    &#125;     //a\tprivate BlockingQueue&lt;VoucherOrder&gt; orderTasks =new  ArrayBlockingQueue&lt;&gt;(1024 * 1024);    @Override    public Result seckillVoucher(Long voucherId) &#123;        Long userId = UserHolder.getUser().getId();        long orderId = redisIdWorker.nextId(\"order\");        // 1.执行lua脚本        Long result = stringRedisTemplate.execute(                SECKILL_SCRIPT,                Collections.emptyList(),                voucherId.toString(), userId.toString(), String.valueOf(orderId)        );        int r = result.intValue();        // 2.判断结果是否为0        if (r != 0) &#123;            // 2.1.不为0 ，代表没有购买资格            return Result.fail(r == 1 ? \"库存不足\" : \"不能重复下单\");        &#125;        VoucherOrder voucherOrder = new VoucherOrder();        // 2.3.订单id        long orderId = redisIdWorker.nextId(\"order\");        voucherOrder.setId(orderId);        // 2.4.用户id        voucherOrder.setUserId(userId);        // 2.5.代金券id        voucherOrder.setVoucherId(voucherId);        // 2.6.放入阻塞队列        orderTasks.add(voucherOrder);        //3.获取代理对象         proxy = (IVoucherOrderService)AopContext.currentProxy();        //4.返回订单id        return Result.ok(orderId);    &#125;      @Transactional    public  void createVoucherOrder(VoucherOrder voucherOrder) &#123;        Long userId = voucherOrder.getUserId();        // 5.1.查询订单        int count = query().eq(\"user_id\", userId).eq(\"voucher_id\", voucherOrder.getVoucherId()).count();        // 5.2.判断是否存在        if (count &gt; 0) &#123;            // 用户已经购买过了           log.error(\"用户已经购买过了\");           return ;        &#125;        // 6.扣减库存        boolean success = seckillVoucherService.update()                .setSql(\"stock = stock - 1\") // set stock = stock - 1                .eq(\"voucher_id\", voucherOrder.getVoucherId()).gt(\"stock\", 0) // where id = ? and stock &gt; 0                .update();        if (!success) &#123;            // 扣减失败            log.error(\"库存不足\");            return ;        &#125;        save(voucherOrder);    &#125;\n小总结：\n秒杀业务的优化思路是什么？\n\n先利用 Redis 完成库存余量、一人一单判断，完成抢单业务\n再将下单业务放入阻塞队列，利用独立线程异步下单\n基于阻塞队列的异步秒杀存在哪些问题？\n\n内存限制问题\n数据安全问题\n\n\n\n Redis 消息队列\n Redis 消息队列-认识消息队列\n什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括 3 个角色：\n\n消息队列：存储和管理消息，也被称为消息代理（Message Broker）\n生产者：发送消息到消息队列\n消费者：从消息队列获取消息并处理消息\n\n\n使用队列的好处在于 解耦： 所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。\n这种场景在我们秒杀中就变成了：我们下单之后，利用 redis 去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。\n这里我们可以使用一些现成的 mq，比如 kafka，rabbitmq 等等，但是呢，如果没有安装 mq，我们也可以直接使用 redis 提供的 mq 方案，降低我们的部署和学习成本。\n Redis 消息队列-基于 List 实现消息队列\n基于 List 结构模拟消息队列\n消息队列（Message Queue），字面意思就是存放消息的队列。而 Redis 的 list 数据结构是一个双向链表，很容易模拟出队列效果。\n队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP 来实现。\n不过要注意的是，当队列中没有消息时 RPOP 或 LPOP 操作会返回 null，并不像 JVM 的阻塞队列那样会阻塞并等待消息。因此这里应该使用 BRPOP 或者 BLPOP 来实现阻塞效果。\n\n基于 List 的消息队列有哪些优缺点？\n优点：\n\n利用 Redis 存储，不受限于 JVM 内存上限\n基于 Redis 的持久化机制，数据安全性有保证\n可以满足消息有序性\n\n缺点：\n\n无法避免消息丢失\n只支持单消费者\n\n Redis 消息队列-基于 PubSub 的消息队列\nPubSub（发布订阅）是 Redis2.0 版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个 channel，生产者向对应 channel 发送消息后，所有订阅者都能收到相关消息。\nSUBSCRIBE channel [channel] ：订阅一个或多个频道\nPUBLISH channel msg ：向一个频道发送消息\nPSUBSCRIBE pattern[pattern] ：订阅与 pattern 格式匹配的所有频道\n\n基于 PubSub 的消息队列有哪些优缺点？\n优点：\n\n采用发布订阅模型，支持多生产、多消费\n\n缺点：\n\n不支持数据持久化\n无法避免消息丢失\n消息堆积有上限，超出时数据丢失\n\n Redis 消息队列-基于 Stream 的消息队列\nStream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。\n发送消息的命令：\n\n例如：\n\n读取消息的方式之一：XREAD\n\n例如，使用 XREAD 读取第一个消息：\n\nXREAD 阻塞方式，读取最新的消息：\n\n在业务开发中，我们可以循环的调用 XREAD 阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下\n\n注意：当我们指定起始 ID 为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过 1 条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题\nSTREAM 类型消息队列的 XREAD 命令特点：\n\n消息可回溯\n一个消息可以被多个消费者读取\n可以阻塞读取\n有消息漏读的风险\n\n Redis 消息队列-基于 Stream 的消息队列-消费者组\n消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：\n\n创建消费者组：\n\nkey：队列名称\ngroupName：消费者组名称\nID：起始 ID 标示，$代表队列中最后一个消息，0 则代表队列中第一个消息\nMKSTREAM：队列不存在时自动创建队列\n其它常见命令：\n删除指定的消费者组\nXGROUP DESTORY key groupName\n给指定的消费者组添加消费者\nXGROUP CREATECONSUMER key groupname consumername\n删除消费者组中的指定消费者\nXGROUP DELCONSUMER key groupname consumername\n从消费者组读取消息：\nXREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]\n\ngroup：消费组名称\nconsumer：消费者名称，如果消费者不存在，会自动创建一个消费者\ncount：本次查询的最大数量\nBLOCK milliseconds：当没有消息时最长等待时间\nNOACK：无需手动 ACK，获取到消息后自动确认\nSTREAMS key：指定队列名称\nID：获取消息的起始 ID：\n\n“&gt;”：从下一个未消费的消息开始\n其它：根据指定 id 从 pending-list 中获取已消费但未确认的消息，例如 0，是从 pending-list 中的第一个消息开始\n消费者监听消息的基本思路：\nSTREAM 类型消息队列的 XREADGROUP 命令特点：\n\n消息可回溯\n可以多消费者争抢消息，加快消费速度\n可以阻塞读取\n没有消息漏读的风险\n有消息确认机制，保证消息至少被消费一次\n\n最后我们来个小对比\n\n 基于 Redis 的 Stream 结构作为消息队列，实现异步秒杀下单\n需求：\n\n创建一个 Stream 类型的消息队列，名为 stream.orders\n修改之前的秒杀下单 Lua 脚本，在认定有抢购资格后，直接向 stream.orders 中添加消息，内容包含 voucherId、userId、orderId\n项目启动时，开启一个线程任务，尝试获取 stream.orders 中的消息，完成下单\\\n\n修改 lua 表达式,新增 3.6\n\nVoucherOrderServiceImpl\nprivate class VoucherOrderHandler implements Runnable &#123;    @Override    public void run() &#123;        while (true) &#123;            try &#123;                // 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                    Consumer.from(\"g1\", \"c1\"),                    StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),                    StreamOffset.create(\"stream.orders\", ReadOffset.lastConsumed())                );                // 2.判断订单信息是否为空                if (list == null || list.isEmpty()) &#123;                    // 如果为null，说明没有消息，继续下一次循环                    continue;                &#125;                // 解析数据                MapRecord&lt;String, Object, Object&gt; record = list.get(0);                Map&lt;Object, Object&gt; value = record.getValue();                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);                // 3.创建订单                createVoucherOrder(voucherOrder);                // 4.确认消息 XACK                stringRedisTemplate.opsForStream().acknowledge(\"s1\", \"g1\", record.getId());            &#125; catch (Exception e) &#123;                log.error(\"处理订单异常\", e);                //处理异常消息                handlePendingList();            &#125;        &#125;    &#125;    private void handlePendingList() &#123;        while (true) &#123;            try &#123;                // 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                    Consumer.from(\"g1\", \"c1\"),                    StreamReadOptions.empty().count(1),                    StreamOffset.create(\"stream.orders\", ReadOffset.from(\"0\"))                );                // 2.判断订单信息是否为空                if (list == null || list.isEmpty()) &#123;                    // 如果为null，说明没有异常消息，结束循环                    break;                &#125;                // 解析数据                MapRecord&lt;String, Object, Object&gt; record = list.get(0);                Map&lt;Object, Object&gt; value = record.getValue();                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);                // 3.创建订单                createVoucherOrder(voucherOrder);                // 4.确认消息 XACK                stringRedisTemplate.opsForStream().acknowledge(\"s1\", \"g1\", record.getId());            &#125; catch (Exception e) &#123;                log.error(\"处理pendding订单异常\", e);                try&#123;                    Thread.sleep(20);                &#125;catch(Exception e)&#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n 达人探店\n 达人探店-发布探店笔记\n发布探店笔记\n探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：\ntb_blog：探店笔记表，包含笔记中的标题、文字、图片等\ntb_blog_comments：其他用户对探店笔记的评价\n具体发布流程\n\n上传接口\n@Slf4j@RestController@RequestMapping(\"upload\")public class UploadController &#123;    @PostMapping(\"blog\")    public Result uploadImage(@RequestParam(\"file\") MultipartFile image) &#123;        try &#123;            // 获取原始文件名称            String originalFilename = image.getOriginalFilename();            // 生成新文件名            String fileName = createNewFileName(originalFilename);            // 保存文件            image.transferTo(new File(SystemConstants.IMAGE_UPLOAD_DIR, fileName));            // 返回结果            log.debug(\"文件上传成功，&#123;&#125;\", fileName);            return Result.ok(fileName);        &#125; catch (IOException e) &#123;            throw new RuntimeException(\"文件上传失败\", e);        &#125;    &#125;&#125;\n注意：同学们在操作时，需要修改 SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在 nginx 上或者是云存储上。\nBlogController\n@RestController@RequestMapping(\"/blog\")public class BlogController &#123;    @Resource    private IBlogService blogService;    @PostMapping    public Result saveBlog(@RequestBody Blog blog) &#123;        //获取登录用户        UserDTO user = UserHolder.getUser();        blog.setUpdateTime(user.getId());        //保存探店博文        blogService.saveBlog(blog);        //返回id        return Result.ok(blog.getId());    &#125;&#125;\n 达人探店-查看探店笔记\n实现查看发布探店笔记的接口\n\n实现代码：\nBlogServiceImpl\n@Overridepublic Result queryBlogById(Long id) &#123;    // 1.查询blog    Blog blog = getById(id);    if (blog == null) &#123;        return Result.fail(\"笔记不存在！\");    &#125;    // 2.查询blog有关的用户    queryBlogUser(blog);    return Result.ok(blog);&#125;\n 达人探店-点赞功能\n初始代码\n@GetMapping(\"/likes/&#123;id&#125;\")public Result queryBlogLikes(@PathVariable(\"id\") Long id) &#123;    //修改点赞数量    blogService.update().setSql(\"liked = liked +1 \").eq(\"id\",id).update();    return Result.ok();&#125;\n问题分析：这种方式会导致一个用户无限点赞，明显是不合理的\n造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库+1，所以才会出现这个问题\n\n完善点赞功能\n需求：\n\n同一个用户只能点赞一次，再次点击则取消点赞\n如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段 Blog 类的 isLike 属性）\n\n实现步骤：\n\n给 Blog 类中添加一个 isLike 字段，标示是否被当前用户点赞\n修改点赞功能，利用 Redis 的 set 集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1\n修改根据 id 查询 Blog 的业务，判断当前登录用户是否点赞过，赋值给 isLike 字段\n修改分页查询 Blog 业务，判断当前登录用户是否点赞过，赋值给 isLike 字段\n\n为什么采用 set 集合：\n因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是\n具体步骤：\n1、在 Blog 添加一个字段\n@TableField(exist = false)private Boolean isLike;\n2、修改代码\n@Override   public Result likeBlog(Long id)&#123;       // 1.获取登录用户       Long userId = UserHolder.getUser().getId();       // 2.判断当前登录用户是否已经点赞       String key = BLOG_LIKED_KEY + id;       Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString());       if(BooleanUtil.isFalse(isMember))&#123;            //3.如果未点赞，可以点赞           //3.1 数据库点赞数+1           boolean isSuccess = update().setSql(\"liked = liked + 1\").eq(\"id\", id).update();           //3.2 保存用户到Redis的set集合           if(isSuccess)&#123;               stringRedisTemplate.opsForSet().add(key,userId.toString());           &#125;       &#125;else&#123;            //4.如果已点赞，取消点赞           //4.1 数据库点赞数-1           boolean isSuccess = update().setSql(\"liked = liked - 1\").eq(\"id\", id).update();           //4.2 把用户从Redis的set集合移除           if(isSuccess)&#123;               stringRedisTemplate.opsForSet().remove(key,userId.toString());           &#125;       &#125;\n 达人探店-点赞排行榜\n在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的 TOP5，形成点赞排行榜：\n之前的点赞是放到 set 集合，但是 set 集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的 set 集合，就是咱们的 sortedSet\n\n我们接下来来对比一下这些集合的区别是什么\n所有点赞的人，需要是唯一的，所以我们应当使用 set 或者是 sortedSet\n其次我们需要排序，就可以直接锁定使用 sortedSet 啦\n\n修改代码\nBlogServiceImpl\n点赞逻辑代码\n@Override public Result likeBlog(Long id) &#123;     // 1.获取登录用户     Long userId = UserHolder.getUser().getId();     // 2.判断当前登录用户是否已经点赞     String key = BLOG_LIKED_KEY + id;     Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());     if (score == null) &#123;         // 3.如果未点赞，可以点赞         // 3.1.数据库点赞数 + 1         boolean isSuccess = update().setSql(\"liked = liked + 1\").eq(\"id\", id).update();         // 3.2.保存用户到Redis的set集合  zadd key value score         if (isSuccess) &#123;             stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());         &#125;     &#125; else &#123;         // 4.如果已点赞，取消点赞         // 4.1.数据库点赞数 -1         boolean isSuccess = update().setSql(\"liked = liked - 1\").eq(\"id\", id).update();         // 4.2.把用户从Redis的set集合移除         if (isSuccess) &#123;             stringRedisTemplate.opsForZSet().remove(key, userId.toString());         &#125;     &#125;     return Result.ok(); &#125; private void isBlogLiked(Blog blog) &#123;     // 1.获取登录用户     UserDTO user = UserHolder.getUser();     if (user == null) &#123;         // 用户未登录，无需查询是否点赞         return;     &#125;     Long userId = user.getId();     // 2.判断当前登录用户是否已经点赞     String key = \"blog:liked:\" + blog.getId();     Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());     blog.setIsLike(score != null); &#125;\n点赞列表查询列表\nBlogController\n@GetMapping(\"/likes/&#123;id&#125;\")public Result queryBlogLikes(@PathVariable(\"id\") Long id) &#123;    return blogService.queryBlogLikes(id);&#125;\nBlogService\n@Overridepublic Result queryBlogLikes(Long id) &#123;    String key = BLOG_LIKED_KEY + id;    // 1.查询top5的点赞用户 zrange key 0 4    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);    if (top5 == null || top5.isEmpty()) &#123;        return Result.ok(Collections.emptyList());    &#125;    // 2.解析出其中的用户id    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());    String idStr = StrUtil.join(\",\", ids);    // 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)    List&lt;UserDTO&gt; userDTOS = userService.query()            .in(\"id\", ids).last(\"ORDER BY FIELD(id,\" + idStr + \")\").list()            .stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    // 4.返回    return Result.ok(userDTOS);&#125;\n 好友关注\n 好友关注-关注和取消关注\n针对用户的操作：可以对用户进行关注和取消关注功能。\n\n实现思路：\n需求：基于该表数据结构，实现两个接口：\n\n关注和取关接口\n判断是否关注的接口\n\n关注是 User 之间的关系，是博主与粉丝的关系，数据库中有一张 tb_follow 表来标示：\n\n注意: 这里需要把主键修改为自增长，简化开发。\nFollowController\n//关注@PutMapping(\"/&#123;id&#125;/&#123;isFollow&#125;\")public Result follow(@PathVariable(\"id\") Long followUserId, @PathVariable(\"isFollow\") Boolean isFollow) &#123;    return followService.follow(followUserId, isFollow);&#125;//取消关注@GetMapping(\"/or/not/&#123;id&#125;\")public Result isFollow(@PathVariable(\"id\") Long followUserId) &#123;      return followService.isFollow(followUserId);&#125;\nFollowService\n取消关注service@Overridepublic Result isFollow(Long followUserId) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        // 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?        Integer count = query().eq(\"user_id\", userId).eq(\"follow_user_id\", followUserId).count();        // 3.判断        return Result.ok(count &gt; 0);    &#125; 关注service @Override    public Result follow(Long followUserId, Boolean isFollow) &#123;        // 1.获取登录用户        Long userId = UserHolder.getUser().getId();        String key = \"follows:\" + userId;        // 1.判断到底是关注还是取关        if (isFollow) &#123;            // 2.关注，新增数据            Follow follow = new Follow();            follow.setUserId(userId);            follow.setFollowUserId(followUserId);            boolean isSuccess = save(follow);        &#125; else &#123;            // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?            remove(new QueryWrapper&lt;Follow&gt;()                    .eq(\"user_id\", userId).eq(\"follow_user_id\", followUserId));        &#125;        return Result.ok();    &#125;\n 好友关注-共同关注\n想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求\n1、去查询用户的详情\n2、去查询用户的笔记\n以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到 idea 中就可以实现这两个功能了，我们的重点在于共同关注功能。\n\n// UserController 根据id查询用户@GetMapping(\"/&#123;id&#125;\")public Result queryUserById(@PathVariable(\"id\") Long userId)&#123;\t// 查询详情\tUser user = userService.getById(userId);\tif (user == null) &#123;\t\treturn Result.ok();\t&#125;\tUserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);\t// 返回\treturn Result.ok(userDTO);&#125;// BlogController  根据id查询博主的探店笔记@GetMapping(\"/of/user\")public Result queryBlogByUserId(\t\t@RequestParam(value = \"current\", defaultValue = \"1\") Integer current,\t\t@RequestParam(\"id\") Long id) &#123;\t// 根据用户查询\tPage&lt;Blog&gt; page = blogService.query()\t\t\t.eq(\"user_id\", id).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));\t// 获取当前页数据\tList&lt;Blog&gt; records = page.getRecords();\treturn Result.ok(records);&#125;\n接下来我们来看看共同关注如何实现：\n需求：利用 Redis 中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。\n当然是使用我们之前学习过的 set 集合咯，在 set 集合中，有交集并集补集的 api，我们可以把两人的关注的人分别放入到一个 set 集合中，然后再通过 api 去查看这两个 set 集合中的交集数据。\n\n我们先来改造当前的关注列表\n改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到 set 集合中，方便后续进行共同关注，同时当取消关注时，也需要从 set 集合中进行删除\nFollowServiceImpl\n@Overridepublic Result follow(Long followUserId, Boolean isFollow) &#123;    // 1.获取登录用户    Long userId = UserHolder.getUser().getId();    String key = \"follows:\" + userId;    // 1.判断到底是关注还是取关    if (isFollow) &#123;        // 2.关注，新增数据        Follow follow = new Follow();        follow.setUserId(userId);        follow.setFollowUserId(followUserId);        boolean isSuccess = save(follow);        if (isSuccess) &#123;            // 把关注用户的id，放入redis的set集合 sadd userId followerUserId            stringRedisTemplate.opsForSet().add(key, followUserId.toString());        &#125;    &#125; else &#123;        // 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?        boolean isSuccess = remove(new QueryWrapper&lt;Follow&gt;()                .eq(\"user_id\", userId).eq(\"follow_user_id\", followUserId));        if (isSuccess) &#123;            // 把关注用户的id从Redis集合中移除            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());        &#125;    &#125;    return Result.ok();&#125;\n具体的关注代码：\nFollowServiceImpl\n@Overridepublic Result followCommons(Long id) &#123;    // 1.获取当前用户    Long userId = UserHolder.getUser().getId();    String key = \"follows:\" + userId;    // 2.求交集    String key2 = \"follows:\" + id;    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);    if (intersect == null || intersect.isEmpty()) &#123;        // 无交集        return Result.ok(Collections.emptyList());    &#125;    // 3.解析id集合    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());    // 4.查询用户    List&lt;UserDTO&gt; users = userService.listByIds(ids)            .stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    return Result.ok(users);&#125;\n 好友关注-Feed 流实现方案\n当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做 Feed 流，关注推送也叫做 Feed 流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。\n对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容\n\n对于新型的 Feed 流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。\n\nFeed 流的实现有两种模式：\nFeed 流产品有两种常见模式：\nTimeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈\n\n优点：信息全面，不会有缺失。并且实现也相对简单\n缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低\n\n智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户\n\n优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷\n缺点：如果算法不精准，可能起到反作用\n本例中的个人页面，是基于关注的好友来做 Feed 流，因此采用 Timeline 的模式。该模式的实现方案有三种：\n\n我们本次针对好友的操作，采用的就是 Timeline 的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可\n，因此采用 Timeline 的模式。该模式的实现方案有三种：\n\n拉模式\n推模式\n推拉结合\n\n拉模式：也叫做读扩散\n该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序\n优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。\n缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。\n\n推模式：也叫做写扩散。\n推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了\n优点：时效快，不用临时拉取\n缺点：内存压力大，假设一个大 V 写信息，很多人关注他， 就会写很多分数据到粉丝那边去\n\n推拉结合模式：也叫做读写混合，兼具推和拉两种模式的优点。\n推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大 V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大 V 和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。\n\n 好友关注-推送到粉丝收件箱\n需求：\n\n修改新增探店笔记的业务，在保存 blog 到数据库的同时，推送到粉丝的收件箱\n收件箱满足可以根据时间戳排序，必须用 Redis 的数据结构实现\n查询收件箱数据时，可以实现分页查询\n\nFeed 流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。\n传统了分页在 feed 流是不适用的，因为我们的数据会随时发生变化\n假设在 t1 时刻，我们去读取第一页，此时 page = 1 ，size = 5 ，那么我们拿到的就是 106 这几条记录，假设现在 t2 时候又发布了一条记录，此时 t3 时刻，我们来读取第二页，读取第二页传入的参数是 page=2 ，size=5 ，那么此时读取到的第二页实际上是从 6 开始，然后是 62 ，那么我们就读取到了重复的数据，所以 feed 流的分页，不能采用原始方案来做。\n\nFeed 流的滚动分页\n我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据\n举个例子：我们从 t1 时刻开始，拿第一页数据，拿到了 10~6，然后记录下当前最后一次拿取的记录，就是 6，t2 时刻发布了新的记录，此时这个 11 放到最顶上，但是不会影响我们之前记录的 6，此时 t3 时刻来拿第二页，第二页这个时候拿数据，还是从 6 后一点的 5 去拿，就拿到了 5-1 的记录。我们这个地方可以采用 sortedSet 来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了\n\n核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的 redis 中去。\n@Overridepublic Result saveBlog(Blog blog) &#123;    // 1.获取登录用户    UserDTO user = UserHolder.getUser();    blog.setUserId(user.getId());    // 2.保存探店笔记    boolean isSuccess = save(blog);    if(!isSuccess)&#123;        return Result.fail(\"新增笔记失败!\");    &#125;    // 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?    List&lt;Follow&gt; follows = followService.query().eq(\"follow_user_id\", user.getId()).list();    // 4.推送笔记id给所有粉丝    for (Follow follow : follows) &#123;        // 4.1.获取粉丝id        Long userId = follow.getUserId();        // 4.2.推送        String key = FEED_KEY + userId;        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());    &#125;    // 5.返回id    return Result.ok(blog.getId());&#125;\n 好友关注-实现分页查询收邮箱\n需求：在个人主页的“关注”卡片中，查询并展示推送的 Blog 信息：\n具体操作如下：\n1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件\n2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据\n综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。\n这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。\n\n定义出来具体的返回值实体类\n@Datapublic class ScrollResult &#123;    private List&lt;?&gt; list;    private Long minTime;    private Integer offset;&#125;\nBlogController\n注意：RequestParam 表示接受 url 地址栏传参的注解，当方法上参数的名称和 url 地址栏不相同时，可以通过 RequestParam 来进行指定\n@GetMapping(\"/of/follow\")public Result queryBlogOfFollow(    @RequestParam(\"lastId\") Long max, @RequestParam(value = \"offset\", defaultValue = \"0\") Integer offset)&#123;    return blogService.queryBlogOfFollow(max, offset);&#125;\nBlogServiceImpl\n@Overridepublic Result queryBlogOfFollow(Long max, Integer offset) &#123;    // 1.获取当前用户    Long userId = UserHolder.getUser().getId();    // 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count    String key = FEED_KEY + userId;    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()        .reverseRangeByScoreWithScores(key, 0, max, offset, 2);    // 3.非空判断    if (typedTuples == null || typedTuples.isEmpty()) &#123;        return Result.ok();    &#125;    // 4.解析数据：blogId、minTime（时间戳）、offset    List&lt;Long&gt; ids = new ArrayList&lt;&gt;(typedTuples.size());    long minTime = 0; // 2    int os = 1; // 2    for (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; // 5 4 4 2 2        // 4.1.获取id        ids.add(Long.valueOf(tuple.getValue()));        // 4.2.获取分数(时间戳）        long time = tuple.getScore().longValue();        if(time == minTime)&#123;            os++;        &#125;else&#123;            minTime = time;            os = 1;        &#125;    &#125;\tos = minTime == max ? os : os + offset;    // 5.根据id查询blog    String idStr = StrUtil.join(\",\", ids);    List&lt;Blog&gt; blogs = query().in(\"id\", ids).last(\"ORDER BY FIELD(id,\" + idStr + \")\").list();    for (Blog blog : blogs) &#123;        // 5.1.查询blog有关的用户        queryBlogUser(blog);        // 5.2.查询blog是否被点赞        isBlogLiked(blog);    &#125;    // 6.封装并返回    ScrollResult r = new ScrollResult();    r.setList(blogs);    r.setOffset(os);    r.setMinTime(minTime);    return Result.ok(r);&#125;\n 附近商户\n 附近商户-GEO 数据结构的基本用法\nGEO 就是 Geolocation 的简写形式，代表地理坐标。Redis 在 3.2 版本中加入了对 GEO 的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：\n\nGEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）\nGEODIST：计算指定的两个点之间的距离并返回\nGEOHASH：将指定 member 的坐标转为 hash 字符串形式并返回\nGEOPOS：返回指定 member 的坐标\nGEORADIUS：指定圆心、半径，找到该圆内包含的所有 member，并按照与圆心之间的距离排序后返回。6.以后已废弃\nGEOSEARCH：在指定范围内搜索 member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能\nGEOSEARCHSTORE：与 GEOSEARCH 功能一致，不过可以把结果存储到一个指定的 key。 6.2.新功能\n\n 附近商户-导入店铺数据到 GEO\n具体场景说明：\n\n当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的 GEO，向后台传入当前 app 收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型 type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。\n\n我们要做的事情是：将数据库表中的数据导入到 redis 中去，redis 中的 GEO，GEO 在 redis 中就一个 menber 和一个经纬度，我们把 x 和 y 轴传入到 redis 做的经纬度位置去，但我们不能把所有的数据都放入到 menber 中去，毕竟作为 redis 是一个内存级数据库，如果存海量数据，redis 还是力不从心，所以我们在这个地方存储他的 id 即可。\n但是这个时候还有一个问题，就是在 redis 中并没有存储 type，所以我们无法根据 type 来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以 typeId 为 key 存入同一个 GEO 集合中即可\n代码\nHmDianPingApplicationTests\n@Testvoid loadShopData() &#123;    // 1.查询店铺信息    List&lt;Shop&gt; list = shopService.list();    // 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));    // 3.分批完成写入Redis    for (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;        // 3.1.获取类型id        Long typeId = entry.getKey();        String key = SHOP_GEO_KEY + typeId;        // 3.2.获取同类型的店铺的集合        List&lt;Shop&gt; value = entry.getValue();        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = new ArrayList&lt;&gt;(value.size());        // 3.3.写入redis GEOADD key 经度 纬度 member        for (Shop shop : value) &#123;            // stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());            locations.add(new RedisGeoCommands.GeoLocation&lt;&gt;(                    shop.getId().toString(),                    new Point(shop.getX(), shop.getY())            ));        &#125;        stringRedisTemplate.opsForGeo().add(key, locations);    &#125;&#125;\n 附近商户-实现附近商户功能\nSpringDataRedis 的 2.3.9 版本并不支持 Redis 6.2 提供的 GEOSEARCH 命令，因此我们需要提示其版本，修改自己的 POM\n第一步：导入 pom\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;    &lt;version&gt;6.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n第二步：\nShopController\n@GetMapping(\"/of/type\")public Result queryShopByType(        @RequestParam(\"typeId\") Integer typeId,        @RequestParam(value = \"current\", defaultValue = \"1\") Integer current,        @RequestParam(value = \"x\", required = false) Double x,        @RequestParam(value = \"y\", required = false) Double y) &#123;   return shopService.queryShopByType(typeId, current, x, y);&#125;\nShopServiceImpl\n@Override    public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) &#123;        // 1.判断是否需要根据坐标查询        if (x == null || y == null) &#123;            // 不需要坐标查询，按数据库查询            Page&lt;Shop&gt; page = query()                    .eq(\"type_id\", typeId)                    .page(new Page&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));            // 返回数据            return Result.ok(page.getRecords());        &#125;        // 2.计算分页参数        int from = (current - 1) * SystemConstants.DEFAULT_PAGE_SIZE;        int end = current * SystemConstants.DEFAULT_PAGE_SIZE;        // 3.查询redis、按照距离排序、分页。结果：shopId、distance        String key = SHOP_GEO_KEY + typeId;        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() // GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE                .search(                        key,                        GeoReference.fromCoordinate(x, y),                        new Distance(5000),                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)                );        // 4.解析出id        if (results == null) &#123;            return Result.ok(Collections.emptyList());        &#125;        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();        if (list.size() &lt;= from) &#123;            // 没有下一页了，结束            return Result.ok(Collections.emptyList());        &#125;        // 4.1.截取 from ~ end的部分        List&lt;Long&gt; ids = new ArrayList&lt;&gt;(list.size());        Map&lt;String, Distance&gt; distanceMap = new HashMap&lt;&gt;(list.size());        list.stream().skip(from).forEach(result -&gt; &#123;            // 4.2.获取店铺id            String shopIdStr = result.getContent().getName();            ids.add(Long.valueOf(shopIdStr));            // 4.3.获取距离            Distance distance = result.getDistance();            distanceMap.put(shopIdStr, distance);        &#125;);        // 5.根据id查询Shop        String idStr = StrUtil.join(\",\", ids);        List&lt;Shop&gt; shops = query().in(\"id\", ids).last(\"ORDER BY FIELD(id,\" + idStr + \")\").list();        for (Shop shop : shops) &#123;            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());        &#125;        // 6.返回        return Result.ok(shops);    &#125;\n 用户签到\n 用户签到-BitMap 功能演示\n我们针对签到功能完全可以通过 mysql 来完成，比如说以下这张表\n\n用户一次签到，就是一条记录，假如有 1000 万用户，平均每人每年签到次数为 10 次，则这张表一年的数据量为 1 亿条\n每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共 22 字节的内存，一个月则最多需要 600 多字节\n我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了\n我们可以采用类似这样的方案来实现我们的签到需求。\n我们按月来统计用户签到信息，签到记录为 1，未签到则记录为 0.\n把每一个 bit 位对应当月的每一天，形成了映射关系。用 0 和 1 标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示\nRedis 中是利用 string 类型数据结构实现 BitMap，因此最大上限是 512M，转换为 bit 则是 2^32 个 bit 位。\n\nBitMap 的操作命令有：\n\nSETBIT：向指定位置（offset）存入一个 0 或 1\nGETBIT ：获取指定位置（offset）的 bit 值\nBITCOUNT ：统计 BitMap 中值为 1 的 bit 位的数量\nBITFIELD ：操作（查询、修改、自增）BitMap 中 bit 数组中的指定位置（offset）的值\nBITFIELD_RO ：获取 BitMap 中 bit 数组，并以十进制形式返回\nBITOP ：将多个 BitMap 的结果做位运算（与 、或、异或）\nBITPOS ：查找 bit 数组中指定范围内第一个 0 或 1 出现的位置\n\n 用户签到-实现签到功能\n需求：实现签到接口，将当前用户当天签到信息保存到 Redis 中\n思路：我们可以把年和月作为 bitMap 的 key，然后保存到一个 bitMap 中，每次签到就到对应的位上把数字从 0 变成 1，只要对应是 1，就表明说明这一天已经签到了，反之则没有签到。\n我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改 bitMap。\n\n代码\nUserController\n@PostMapping(\"/sign\")public Result sign()&#123;   return userService.sign();&#125;\nUserServiceImpl\n@Overridepublic Result sign() &#123;    // 1.获取当前登录用户    Long userId = UserHolder.getUser().getId();    // 2.获取日期    LocalDateTime now = LocalDateTime.now();    // 3.拼接key    String keySuffix = now.format(DateTimeFormatter.ofPattern(\":yyyyMM\"));    String key = USER_SIGN_KEY + userId + keySuffix;    // 4.获取今天是本月的第几天    int dayOfMonth = now.getDayOfMonth();    // 5.写入Redis SETBIT key offset 1    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true);    return Result.ok();&#125;\n 用户签到-签到统计\n问题 1： 什么叫做连续签到天数？\n从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。\n\nJava 逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非 0 的数字即可，每得到一个非 0 的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了\n问题 2： 如何得到本月到今天为止的所有签到数据？\nBITFIELD key GET u[dayOfMonth] 0\n假设今天是 10 号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是 10 号，那么就是 10 位，去拿这段时间的数据，就能拿到所有的数据了，那么这 10 天里边签到了多少次呢？统计有多少个 1 即可。\n问题 3：如何从后向前遍历每个 bit 位？\n注意：bitMap 返回的数据是 10 进制，哪假如说返回一个数字 8，那么我哪儿知道到底哪些是 0，哪些是 1 呢？我们只需要让得到的 10 进制数字和 1 做与运算就可以了，因为 1 只有遇见 1 才是 1，其他数字都是 0 ，我们把签到结果和 1 进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。\n需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数\n有用户有时间我们就可以组织出对应的 key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了\n\n代码\nUserController\n@GetMapping(\"/sign/count\")public Result signCount()&#123;    return userService.signCount();&#125;\nUserServiceImpl\n@Overridepublic Result signCount() &#123;    // 1.获取当前登录用户    Long userId = UserHolder.getUser().getId();    // 2.获取日期    LocalDateTime now = LocalDateTime.now();    // 3.拼接key    String keySuffix = now.format(DateTimeFormatter.ofPattern(\":yyyyMM\"));    String key = USER_SIGN_KEY + userId + keySuffix;    // 4.获取今天是本月的第几天    int dayOfMonth = now.getDayOfMonth();    // 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(            key,            BitFieldSubCommands.create()                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0)    );    if (result == null || result.isEmpty()) &#123;        // 没有任何签到结果        return Result.ok(0);    &#125;    Long num = result.get(0);    if (num == null || num == 0) &#123;        return Result.ok(0);    &#125;    // 6.循环遍历    int count = 0;    while (true) &#123;        // 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0        if ((num &amp; 1) == 0) &#123;            // 如果为0，说明未签到，结束            break;        &#125;else &#123;            // 如果不为0，说明已签到，计数器+1            count++;        &#125;        // 把数字右移一位，抛弃最后一个bit位，继续下一个bit位        num &gt;&gt;&gt;= 1;    &#125;    return Result.ok(count);&#125;\n 额外加餐-关于使用 bitmap 来解决缓存穿透的方案\n回顾缓存穿透：\n发起了一个数据库不存在的，redis 里边也不存在的数据，通常你可以把他看成一个攻击\n解决方案：\n\n判断 id&lt;0\n如果数据库是空，那么就可以直接往 redis 里边把这个空数据缓存起来\n\n第一种解决方案：遇到的问题是如果用户访问的是 id 不存在的数据，则此时就无法生效\n第二种解决方案：遇到的问题是：如果是不同的 id 那就可以防止下次过来直击数据\n所以我们如何解决呢？\n我们可以将数据库的数据，所对应的 id 写入到一个 list 集合中，当用户过来访问的时候，我们直接去判断 list 中是否包含当前的要查询的数据，如果说用户要查询的 id 数据并不在 list 集合中，则直接返回，如果 list 中包含对应查询的 id 数据，则说明不是一次缓存穿透数据，则直接放行。\n\n现在的问题是这个主键其实并没有那么短，而是很长的一个 主键\n哪怕你单独去提取这个主键，但是在 11 年左右，淘宝的商品总量就已经超过 10 亿个\n所以如果采用以上方案，这个 list 也会很大，所以我们可以使用 bitmap 来减少 list 的存储空间\n我们可以把 list 数据抽象成一个非常大的 bitmap，我们不再使用 list，而是将 db 中的 id 数据利用哈希思想，比如：\nid % bitmap.size = 算出当前这个 id 对应应该落在 bitmap 的哪个索引上，然后将这个值从 0 变成 1，然后当用户来查询数据时，此时已经没有了 list，让用户用他查询的 id 去用相同的哈希算法， 算出来当前这个 id 应当落在 bitmap 的哪一位，然后判断这一位是 0，还是 1，如果是 0 则表明这一位上的数据一定不存在， 采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。\n\n UV 统计\n UV 统计-HyperLogLog\n首先我们搞懂两个概念：\n\nUV：全称 Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1 天内同一个用户多次访问该网站，只记录 1 次。\nPV：全称 Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录 1 次 PV，用户多次打开页面，则记录多次 PV。往往用来衡量网站的流量。\n\n通常来说 UV 会比 PV 大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值\nUV 统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到 Redis 中，数据量会非常恐怖，那怎么处理呢？\nHyperloglog(HLL)是从 Loglog 算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：https://juejin.cn/post/6844903785744056333#heading-0\nRedis 中的 HLL 是基于 string 结构实现的，单个 HLL 的内存永远小于 16kb，内存占用低的令人发指！作为代价，其测量结果是概率性的，有小于 0.81％的误差。不过对于 UV 统计来说，这完全可以忽略。\n\n UV 统计-测试百万数据的统计\n测试思路：我们直接利用单元测试，向 HyperLogLog 中添加 100 万条数据，看看内存占用和统计效果如何\n\n经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小\n","categories":["计算机"],"tags":["Redis"]},{"title":"校招总结","url":"/2025/03/04/%E6%A0%A1%E6%8B%9B%E6%80%BB%E7%BB%93/","content":" 总结\n太长不看，直接上结果。有面试的公司和结果都在下面这个表中了，只能说我还是太菜了，具体复盘过几天考完 midterm 有空再写。\n\n\n\n公司\n面试\n\n\n\n\n快手\n一面挂\n\n\n招银云创\n一面挂\n\n\n完美世界\n一面挂\n\n\n古茗\n一面挂\n\n\n虎牙\n一面挂\n\n\n金山办公\n一面挂\n\n\n腾讯\n一面挂\n\n\n中国平安\n一面挂\n\n\n安克创新\n一面挂\n\n\n科大讯飞\n一面挂\n\n\n数禾科技\n一面挂\n\n\n信飞科技\n一面挂\n\n\n作业帮\n一面挂\n\n\n中信银行\n一面挂\n\n\n南瑞\n一面挂\n\n\n小鹏汽车\n二面挂\n\n\n字节跳动\n二面挂\n\n\n新华三\n二面挂\n\n\n顺丰\n二面挂\n\n\n联通数科\n二面挂\n\n\n阿里云\n二面挂\n\n\n华为\n三面无消息\n\n\n拼多多\nHR 面挂\n\n\nTP-LINK\nOffer 已拒\n\n\n中海油\nOffer\n\n\n\n其中这个中海油还是这个月来的消息。去年秋招 9 月投的简历，当时看到招聘公告上说是该年泰晤士排名前三十的学校可以免笔试，结果一查咱学校刚好 28（今年去查就是 32 了笑死），便捡了个便宜。结果面试过程也是巨水无比，5 分钟问了一些个人的基本情况就结束了，然后不到三小时就有 hr 联系问我意向了。其他各种私企都是旱的旱死，涝的涝死，牛逼的一堆 offer，小垃圾都是正宗的 0，我就是后者。前几天已经递交材料上去了，如果这个真的成了话，就可以正式开摆不想管春招了。主要是这找工作也太过于折磨和抽象了，去年做一对笔试测评，面了一堆，结果竹篮打水一场空，今年上来直接给我几乎是白送了个，可能这就是运气吧。这几天刚好公布了预录取名单：\n\n其实去年年底那两个（华为和拼多多）还是挺有希望的，我都在考虑和纠结这两个怎么选了，去网上查了一堆信息对比优劣，结果到最后一个都没。感觉就是考虑太多了，以后还是活在当下能摆则摆吧，只能说任何时候都不能抱有太大的期望，不然心态上可能顶不住。\n对于这个 TPLINK，当时直接给他忘签两方了，不过就算想起来也不一定会签字，毕竟这家公司网上的风评简直是一边倒，不予置评。\n至于美国这边的就更没什么好说的了，连笔试都没几个，别说面试了。这边太看重经验了，应届玩不了一点（只能说很难，但是肯定有人上岸），再加上身份也是大问题，还有其他包括吃、玩、文化以及人身安全和医疗的问题，总体来看还是国内呆着舒服，这边除了工资高也没啥其他的优点了。当然工资高消费也高，能攒下来其实不一定有多少，不过 wlb 倒是相对国内要好很多。\n 国内校招\n\n\n\n序号\n公司\n职位\n申请日期\n类型\n测评\n笔试\n一面\n二面\n三面\nHR 面\n备注\n链接\n\n\n\n\n1\n中国电信\n软件开发工程师（合肥） 合肥分公司\n2024/9/10\n国企\n\n\n\n\n\n\n9.16 寄\nhttps://campus.51job.com/chinatelecom/job.html\n\n\n2\n中国电信\n云计算工程师（合肥） 合肥分公司\n2024/9/10\n国企\n\n\n\n\n\n\n9.16 寄\nhttps://campus.51job.com/chinatelecom/job.html\n\n\n3\n小红书\n【2025 校招】后端开发工程师-社区工程\n2024/9/10\n私企\n\n10.13\n\n\n\n\n\nhttps://job.xiaohongshu.com/campus/position/13554\n\n\n4\n小红书\n【2025 校招】Java 开发工程师-广告系统\n2024/9/10\n私企\n\n9.14\n\n\n\n\n笔试寄\nhttps://job.xiaohongshu.com/campus/position/13343\n\n\n5\n小米集团\n云端软件后端开发工程师-汽车\n2024/9/10\n私企\n\n\n\n\n\n\n\nhttps://xiaomi.jobs.f.mioffice.cn/campus/position/7405940068927815788/detail\n\n\n6\n小米集团\n软件开发工程师-java 方向\n2024/9/10\n私企\n9.13\n9.19\n\n\n\n\n9.26 转岗\nhttps://xiaomi.jobs.f.mioffice.cn/campus/position/7405934106763116652/detail\n\n\n7\n蔚来\n校招-应用软件研发 - 后端研发\n2024/9/10\n私企\n\n\n\n\n\n\n简历寄\nhttps://nio.jobs.feishu.cn/campus/position/7394352855569140006/detail\n\n\n8\n蔚来\n校招-后台开发工程师\n2024/9/10\n私企\n\n\n\n\n\n\n简历寄\nhttps://nio.jobs.feishu.cn/campus/position/7394352293208262962/detail\n\n\n9\n蔚来\n校招-测试工程师\n2024/9/10\n私企\n\n\n\n\n\n\n简历寄\nhttps://nio.jobs.feishu.cn/campus/position/7405891287997843724/detail\n\n\n10\n中国电信\nIT 应用研发岗（上海）\n2024/9/10\n国企\n\n11.22\n\n\n\n\n\nhttps://campus.51job.com/chinatelecom/jobdetail.html?ctmid=6271848&amp;type=1&amp;coid=7324396\n\n\n11\n中国电信\n后端开发工程师（上海） 天翼云科技有限公司\n2024/9/10\n国企\n\n\n\n\n\n\n\nhttps://campus.51job.com/chinatelecom/jobdetail.html?ctmid=6271848&amp;type=1&amp;coid=7324408\n\n\n12\nB 站\nJava 开发工程师(商业检索工程)【2025 届】\n2024/9/10\n私企\n\n\n\n\n\n\n简历寄\nhttps://jobs.bilibili.com/campus/positions/20178\n\n\n13\nB 站\nJava 工程师（大会员）【2025 届】\n2024/9/10\n私企\n\n\n\n\n\n\n简历寄\nhttps://jobs.bilibili.com/campus/positions/20154\n\n\n14\n招商银行·招银网络科技\n测试开发工程师\n2024/9/10\n国企\n9.19\n9.23\n\n\n\n\n笔试寄\nhttps://cmbnt.cmbchina.com/pages/socialRecruit/detail.html?jobId=3E931A81A27A4D12A7CC65ECD6971AED&amp;currentType=0&amp;isTop=0\n\n\n15\n联想\nJava 开发工程师\n2024/9/10\n私企\n\n\n\n\n\n\n\nhttps://talent.lenovo.com.cn/position/detail?id=1300\n\n\n16\n携程集团\nJava 开发工程师（2025 届秋招）\n2024/9/10\n私企\n9.16\n10.9\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/trip/37757\n\n\n17\n字节跳动\n后端开发工程师-抖音电商\n2024/9/10\n私企\n\n\n\n\n\n\n\nhttps://jobs.bytedance.com/campus/position/7395136646390614299/detail\n\n\n18\n字节跳动\n后端开发工程师-飞书\n2024/9/10\n私企\n\n\n10.1\n10.18\n\n\n二面寄\nhttps://jobs.bytedance.com/campus/position/7396975800875026714/detail\n\n\n19\n奇安信\n服务端开发工程师-Java\n2024/9/10\n私企\n\n10.12\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/qianxin/29182#/job/fe641ac8-844f-4c03-9795-4bba1c7e5ef6\n\n\n20\n搜狐畅游\n【2025 届秋招】Java 开发工程师\n2024/9/10\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/cyou-inc/42233\n\n\n21\n信也科技\n2025 届校招-Java 开发工程师(支付系统)\n2024/9/10\n私企\n\n10.28\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/paipaidai/146147?sourceToken=4718c89404bc203070e0647773db2ae8#/job/7808ff7c-a1e0-4e7b-92ac-9984189b20cb\n\n\n22\n招商银行\n信息技术岗（Java 开发工程师）\n2024/9/10\n国企\n\n\n\n\n\n\n\nhttps://career.cmbchina.com/positionDetail/school?publishId=F4D10C3A-7F17-4136-BA1E-A4B7857DB1FB\n\n\n23\n小鹏汽车\n【25 届校招】全栈开发工程师\n2024/9/10\n私企\n\n\n9.24\n10.11\n\n\n二面寄\nhttps://xiaopeng.jobs.feishu.cn/campus/position/7409001570886617407/detail\n\n\n24\n小鹏汽车\n【25 届校招】Java 后端开发工程师\n2024/9/10\n私企\n\n\n\n\n\n\n\nhttps://xiaopeng.jobs.feishu.cn/campus/position/7410772068977576243/detail\n\n\n25\n用友\nJava 开发工程师-25 届\n2024/9/10\n私企\n9.16\n10.16\n\n\n\n\n\nhttps://career.yonyou.com/SU6486ca53bef57c16d35313ab/pb/posDetail.html?postId=668b3bfb1c240e2e76ea1a87&amp;postType=campus\n\n\n26\n满帮集团\nJava 开发工程师\n2024/9/10\n私企\n\n10.11\n\n\n\n\n笔试寄\nhttps://app.mokahr.com/campus-recruitment/manbang/94191#/job/e0d567b5-eea7-481b-968d-56ade7c1afd8\n\n\n27\n恒生电子\nJava 开发工程师(J10310)\n2024/9/10\n私企\n\n\n\n\n\n\n\nhttps://campus.hundsun.com/campus/detail?jobAdId=eef92019-afe8-4eb8-b2ba-0bbe833e1c3f\n\n\n28\n信飞科技\nJAVA 开发工程师【25 届校招】\n2024/9/10\n私企\n9.14\n9.22\n11.1\n\n\n\n\nhttps://app.mokahr.com/social-recruitment/xinyongfei/148039?sourceToken=fe1b746c63a46d78187384bf15bd1f45&amp;previewKey=2b93c5b1480641e981ded181c69ea0feaeb16f4bbae744ae8bbc6561eb13d681#/job/78eae15f-f336-4c95-9102-dadf3e912d95\n\n\n29\n中国电信天翼云\n【超级优才】后端开发工程师（深圳）(003631)\n2024/9/10\n国企\n\n\n\n\n\n\n\nhttps://wecruit.hotjob.cn/SU62b2ae672f9d24458d72f9cc/pb/posDetail.html?showDeliver=1&amp;postId=66bb3e681c240e4f7fa0e9bd&amp;postType=campus\n\n\n30\n阿里大文娱集团\n阿里影业-Java 开发工程师-上海\n2024/9/10\n私企\n\n\n\n\n\n\n\nhttps://jobs.alibaba-dme.com/campus/position-detail?lang\\=zh&amp;positionId\\=2040913\n\n\n31\n阿里大文娱集团\n阿里影业淘麦郎-Java 开发工程师-麦座\n2024/9/10\n私企\n\n\n\n\n\n\n\nhttps://jobs.alibaba-dme.com/campus/position-detail?lang\\=zh&amp;positionId\\=2033524\n\n\n32\n理想汽车\n后端开发工程师\n2024/9/10\n私企\n\n\n\n\n\n\n\nhttps://www.lixiang.com/employ/detail/14572.html?jobCode\\=A52214&amp;fromJob\\=1\n\n\n33\n海信集团\n信动力 T 计划-软件开发工程师（Java 方向）(J36181)\n2024/9/10\n国企\n\n\n\n\n\n\n\nhttps://jobs.hisense.com/7/detail?jobAdId\\=a9b91304-9fa4-4c03-ab77-e0d57f90ff34&amp;activityGuid\\=1045e143-9785-4b72-9866-dac6a206c3b3&amp;ActivityJumpPage\\=PortalPage\n\n\n34\n拼多多\n服务端研发工程师\n2024/9/10\n私企\n9.13\n9.21\n10.19\n10.28\n11.6\n11.23\nHR 面寄\nhttps://careers.pinduoduo.com/campus/grad/technical-session/detail?positionId=ce0f5d44-7fd6-490a-82b9-f136f7608f6d\n\n\n35\n搜狐\nJava 开发工程师（汽车）\n2024/9/10\n私企\n\n\n\n\n\n\n简历寄\nhttps://app.mokahr.com/campus_apply/sohu/5682#/job/7179cb99-f3e9-4a3f-abaf-2c80a329bead\n\n\n36\n去哪儿旅行\nJava 开发工程师（2025）\n2024/9/10\n私企\n9.21\n10.1\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/qunar/37595?sourceToken\\=0cfbbd65e0b0c0e4fdfb9ec700a6edf9#/job/74c4a5f7-7d84-41c4-b0d7-14e6ecb5dd80\n\n\n37\n360 集团\n服务端开发工程师-Java（北京）-4481(J11282)\n2024/9/10\n私企\n\n9.14\n\n\n\n\n\nhttps://360campus.zhiye.com/campus/detail?jobAdId=f70e3ad6-b676-42de-b308-f52fa57f34c2\n\n\n38\n中国建设银行\n科技类专项人才\n2024/9/11\n国企\n\n\n\n\n\n\n\nhttps://job1.ccb.com/cn/job/job_detail.html?planId=2024083019406911&amp;planPost=20240307154139607767&amp;planType=XY&amp;orgId=2041560&amp;secondOrgId=2046410&amp;\n\n\n39\n淘天集团\n研发工程师 JAVA\n2024/9/11\n私企\n10.9\n10.16\n\n\n\n\n\nhttps://talent.taotian.com/campus/position-detail?lang=zh&amp;positionId=2039214\n\n\n40\n应用材料（中国）有限公司\n软件工程师(上海)\n2024/9/11\n外企\n\n\n\n\n\n\n\nhttps://q.yingjiesheng.com/jobdetail/157766002.html\n\n\n41\n台积电（中国）有限公司\n2025 校招-软件开发工程师\n2024/9/11\n外企\n\n\n\n\n\n\n\nhttps://q.yingjiesheng.com/jobdetail/157825363.html\n\n\n42\n台积电（中国）有限公司\n2025 校招-JAVA/C#开发工程师\n2024/9/11\n外企\n\n\n\n\n\n\n\nhttps://q.yingjiesheng.com/jobdetail/157816773.html\n\n\n43\n米哈游\n后端开发工程师\n2024/9/11\n私企\n\n10.12\n\n\n\n\n笔试寄\nhttps://jobs.mihoyo.com/?sharePageId=56263&amp;recommendationCode=OHLJ9&amp;isRecommendation=true#/campus/position/5367\n\n\n44\n百度\n北京-Java 研发工程师(J73126)\n2024/9/11\n私企\n\n10.15\n\n\n\n\n\nhttps://talent.baidu.com/jobs/detail/GRADUATE/9abcb019-2eca-48b1-9c6e-225e6b80262d\n\n\n45\nOPPO\n后端工程师\n2024/9/11\n私企\n9.21\n9.21\n\n\n\n\n\nhttps://careers.oppo.com/university/oppo/campus/post/1227?recruitType=Graduate\n\n\n46\nMiniMax\n服务端研发工程师-2025 届\n2024/9/11\n私企\n\n\n\n\n\n\n简历寄\nhttps://vrfi1sk8a0.jobs.feishu.cn/referral/campus/position/7278321351855720764/detail?token=MzsxNzIwNTIzODM5NzkyOzcxNzkwMzgyMTkwNTIyNjk1NzI7MDsx\n\n\n47\n华为\n软件开发工程师\n2024/9/11\n私企\n9.25\n9.25\n11.21\n11.21\n11.25\n\n\nhttps://career.huawei.com/reccampportal/portal5/campus-recruitment-detail.html?jobId=13609&amp;dataSource=1&amp;jobType=2\n\n\n48\n蚂蚁集团\n初级研发工程师-JAVA\n2024/9/12\n私企\n9.13\n9.29\n\n\n\n\n\nhttps://talent.antgroup.com/campus-position?positionId=24061100671827\n\n\n49\n京东\n后端开发工程师\n2024/9/12\n私企\n9.14\n10.11\n\n\n\n\n\nhttps://campus.jd.com/#/details?id=5437\n\n\n50\n万德 Wind\n软件工程师（JAVA）\n2024/9/12\n私企\n\n\n\n\n\n\n\nhttps://www.wind.com.cn/portal/zh/JoinUs/recruit.html?positionType\\=9002&amp;channelPositionId\\=37\n\n\n51\n南京银行\n总行信息技术部软件开发岗\n2024/9/12\n国企\n\n\n\n\n\n\n\nhttps://job.njcb.com.cn/#/position/campus/details?id=30577&amp;bm0000=1100007&amp;zpreqItemId=5796\n\n\n52\nCVTE\nWeb 后台开发工程师\n2024/9/12\n私企\n\n9.27\n\n\n\n\n笔试寄\nhttps://campus.cvte.com/position/399721113e4e497bb8b2e48e96bc90e8\n\n\n53\n中科曙光\n【2025】Java 开发工程师（云控制台方向）(J12312)\n2024/9/12\n国企\n\n\n\n\n\n\n\nhttps://neitui.italent.cn/sugon/sharejobs?shareId=b9ba1420-f534-455d-8f61-ddb573201290&amp;language=zh_CN\n\n\n54\n腾讯\n软件开发-全栈开发方向\n2024/9/12\n私企\n9.13\n\n12.3\n\n\n\n\nhttps://join.qq.com/post_detail.html?pid=1&amp;id=137&amp;tid=2\n\n\n55\n国轩高科\nJava 软件工程师（工研总院岗）(J12450)\n2024/9/14\n私企\n9.14\n\n\n\n\n\n测评寄\nhttps://gotion.zhiye.com/campus/detail?jobAdId=1b7b31db-ac79-4350-b5f8-897badcdaf34\n\n\n56\n中国银行\n信息科技岗-软件中心（合肥）\n2024/9/14\n国企\n\n线下无法参加\n\n\n\n\n\nhttps://campus.chinahr.com/pages/2025-boc/#/jobs\n\n\n57\n中国银行\n信息科技岗-安徽省分行\n2024/9/14\n国企\n\n线下无法参加\n\n\n\n\n\nhttps://campus.chinahr.com/pages/2025-boc/#/jobs\n\n\n58\n中国银行\n管理培训生（信息科技）\n2024/9/14\n国企\n\n线下无法参加\n\n\n\n\n\nhttps://campus.chinahr.com/pages/2025-boc/#/jobs\n\n\n59\n中国农业银行\n省分行本部科技人才岗\n2024/9/15\n国企\n\n\n\n\n\n\n\nhttps://career.abchina.com.cn/build/index.html#/PositionDetails/:42072745\n\n\n60\n中国交通银行\n软件开发工程师\n2024/9/15\n国企\n\n\n\n\n\n\n\nhttps://job.bankcomm.com/index.do#/school/recruitmentInfo/?positionId=36509\n\n\n61\n中国工商银行\n安徽省行本部-科技菁英\n2024/9/15\n国企\n\n线下无法参加\n\n\n\n\n\nhttps://job.icbc.com.cn/pc/index.html#/main/school/postDetail/00000000000005305502\n\n\n62\n顺丰\nJAVA 开发工程师\n2024/9/15\n私企\n9.16\n9.21\n11.12\n11.14\n\n\n\nhttps://campus.sf-express.com/#/postDetail/1589\n\n\n63\n徽商银行\n总行-金融科技岗（系统开发部）\n2024/9/19\n国企\n\n\n\n\n\n\n\nhttp://rczp.hsbank.com.cn/pc/#/InternshipDetails?id=158&amp;title= 徽商银行2025年全球校园招聘公告&amp;type=校园招聘&amp;parentPlanId=xyzp60682&amp;channelCode=xyzp60682\n\n\n64\n招银云创\nJava 开发工程师（杭州）\n2024/9/19\n国企\n\n10.9\n10.18\n\n\n\n一面寄\nhttps://app.mokahr.com/campus-recruitment/mbcloud/150116#/job/4deabf06-6ec8-4f56-b0ca-46d38cdf1510\n\n\n65\n饿了么\n研发工程师 JAVA\n2024/9/21\n私企\n\n\n\n\n\n\n简历寄\nhttps://talent.ele.me/campus/position-detail?lang=zh&amp;positionId=39900001712\n\n\n66\n阿里国际\n研发工程师 JAVA\n2024/9/21\n私企\n\n10.14\n\n\n\n\n\nhttps://aidc-jobs.alibaba.com/campus/position-detail?lang\\=zh&amp;positionId\\=302032514\n\n\n67\n阿里云\n研发工程师 JAVA\n2024/9/21\n私企\n2.15\n\n2.2\n2.21\n\n\n\nhttps://careers.aliyun.com/campus/position-detail?lang=zh&amp;positionId=9900004501\n\n\n68\n腾讯音乐\n软件开发-后台开发方向\n2024/9/21\n私企\n\n\n\n\n\n\n\nhttps://join.tencentmusic.com/campus/post-details?id=13091\n\n\n69\n滴滴\n25 届正式批-研发工程师（Golang/Java/C++/PHP）\n2024/9/21\n私企\n\n9.28\n\n\n\n\n笔试寄\nhttps://campus.didiglobal.com/campus\\_apply/didiglobal/96064#/job/2915fe47-e17c-4f42-bf4c-b58640b45063\n\n\n70\n网易\nJava 开发工程师-有道\n2024/9/21\n私企\n\n9.28\n\n\n\n\n笔试寄\nhttps://campus.163.com/app/detail/index?id=2943&amp;projectId=61\n\n\n71\n快手\n客户端开发工程师\n2024/9/21\n私企\n\n\n\n\n\n\n简历寄\nhttps://campus.kuaishou.cn/recruit/campus/e/#/campus/job-info/7327\n\n\n72\n中国银联\n技术开发类\n2024/9/21\n国企\n\n10.22\n\n\n\n\n\nhttps://join.unionpay.com/SU6551ec6e4c45f74c9a423549/pb/posDetail.html?postId\\=66e3d8bf4c45f74ff842998e&amp;postType\\=campus\n\n\n73\n中国移动通信有限公司\nJava 开发工程师（后端）\n2024/9/21\n国企\n\n10.26\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/scrd/postprocess2?projectId=101290&amp;from=campusList&amp;jobNumber=CC000413680J40604849613\n\n\n74\n中国移动通信有限公司\n软件开发岗-通用应用开发方向（广州）\n2024/9/21\n国企\n\n10.26\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/scrd/postprocess2?projectId\\=101290&amp;from\\=campusList&amp;jobNumber\\=CC000413680J40604849613\n\n\n75\n中国移动通信有限公司\n软件开发岗-政企方向（深圳）\n2024/9/21\n国企\n\n10.26\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/scrd/postprocess2?projectId=101290&amp;from=campusList&amp;jobNumber=CC000413680J40604849613\n\n\n76\n中信银行\n信息科技类（开发）(A002094)\n2024/9/21\n国企\n\n10.25\n11.22\n\n\n\n\nhttps://job.citicbank.com/#\n\n\n77\n中国农业发展银行\n软件研发岗（合肥）\n2024/9/22\n国企\n\n线下无法参加\n\n\n\n\n\nhttps://campus.chinahr.com/pages/adbc2025/#/jobs\n\n\n78\n中国农业发展银行\n信息技术岗\n2024/9/22\n国企\n\n线下无法参加\n\n\n\n\n\nhttps://campus.chinahr.com/pages/adbc2025/#/jobs\n\n\n79\n中国邮政储蓄银行\n信息技术岗（合肥）\n2024/9/22\n国企\n\n\n\n\n\n\n\nhttps://psbc2025.zhaopin.com/jobs/index.html?id=1388453\n\n\n80\n中国邮政储蓄银行\n信息技术岗\n2024/9/22\n国企\n\n\n\n\n\n\n\nhttps://psbc2025.zhaopin.com/jobs/index.html?id=1388453\n\n\n81\n南京熊猫电子股份有限公司\n软件研发工程师\n2024/9/22\n国企\n\n\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/jobv1/CC120101320J40473231205?refcode=4430&amp;srccode=443001&amp;jobSourceType=2\n\n\n82\n中国机械工业集团有限公司\n计算机应用、软件工程\n2024/9/22\n国企\n\n\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/jobv1/CC120493770J40598297013?refcode=4430&amp;srccode=443001&amp;jobSourceType=2\n\n\n83\n中国船舶集团有限公司\n数据处理/软件开发研发工程师\n2024/9/22\n国企\n\n\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/jobv1/CCL1226837610J40665639805?refcode=4430&amp;srccode=443001&amp;jobSourceType=2\n\n\n84\n合肥通用机械研究院有限公司\n计算机应用、软件工程\n2024/9/22\n国企\n\n\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/jobv1/CC857183560J40729096615?refcode=4430&amp;srccode=443001&amp;jobSourceType=1\n\n\n85\n中电福富信息科技有限公司\nJAVA 开发工程师(2025 届校园招聘)-合肥\n2024/9/22\n国企\n\n\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/jobv1/CC180936110J40658257408?refcode\\=4430&amp;srccode\\=443001&amp;jobSourceType\\=1\n\n\n86\n银联商务支付股份有限公司江苏分公司\nJava 开发工程师（南京校园招聘）\n2024/9/22\n国企\n\n\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/jobv1/CC131826240J40477244002?refcode=4430&amp;srccode=443001&amp;jobSourceType=1\n\n\n87\n中国三星\nSRC-G-后端开发工程师\n2024/9/22\n外企\n\n\n\n\n\n\n\nhttps://dearsamsung.zhiye.com/#/samsung/pc/campus/xzlb\n\n\n88\n中兴通讯\n软件开发工程师\n2024/9/22\n私企\n9.25\n10.12\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/zte/46903#/job/cdcd53d3-a906-4149-bc7a-93be196f4ee8\n\n\n89\n新国都\nJava 开发工程师\n2024/9/22\n私企\n\n\n\n\n\n\n寄\nhttps://app.mokahr.com/campus-recruitment/xgd/7850?sourceToken=4814765e4ef02beb7e628f0daf238af2#/job/6df3f86d-abf3-4af0-9fd5-686666fdc799\n\n\n90\n美团\n软件开发工程师（后端方向）\n2024/9/22\n私企\n\n10.12\n\n\n\n\n\nhttps://zhaopin.meituan.com/web/position/detail?jobUnionId=2606352552&amp;jobShareType=1&amp;highlightType=campus\n\n\n91\n中国人寿\n“展翼计划”科技岗（安徽） 金融科技类\n2024/9/22\n国企\n\n11.2\n\n\n\n\n\nhttps://chinalife.zhiye.com/custom/zwxq?hideMenu=1&amp;jobAdId=32b3795b-6357-4ff1-9bff-0c38ee158233&amp;activityGuid=&amp;jc=2&amp;ClassificationTwo=寿险安徽分公司本部&amp;ClassificationOne=金融科技类\n\n\n92\n招联金融\n后台开发-武汉(2025 校招)\n2024/9/24\n国企\n\n\n\n\n\n\n\nhttps://wecruit.hotjob.cn/SU61027bb10dcad47a7e23e040/pb/posDetail.html?postId=66d52c4f1eb80543258a384c&amp;postType=campus\n\n\n93\n中国光大银行\n软件开发岗（合肥）\n2024/9/25\n国企\n\n\n\n\n\n\n\nhttps://eoap.cebbank.com/uiap/wt/CEB/zpzh/postDetail?recruitType=1&amp;postId=105388\n\n\n94\n美的\n软件开发工程师\n2024/9/26\n私企\n\n\n\n\n\n\n\nhttps://careers.midea.com/schoolOut/post/details?positionId\\=8a9295f58f298fec018f2d865526021d&amp;projectRuleId\\=0189c022-07a2-421d-b2c6-1635ee9fa4a5&amp;tabActive\\=8&amp;projectType\\=8&amp;recruitCategoryId\\=56293ba92698407a82d4649b4753d158\n\n\n95\n荣耀\n通用软件开发工程师\n2024/9/26\n私企\n\n\n\n\n\n\n\nhttps://career.honor.com/SU60eea919bef57c1023f6fe78/pb/posDetail.html?postId=66a2097b1c240e2e7612fbd5&amp;postType=campus\n\n\n96\nTP-LINK\n软件工程师（南京）\n2024/9/26\n私企\n\n10.5\n10.9\n10.11\n10.15\n\n10.23 offer 21k\nhttps://hr.tp-link.com.cn/jobDetail/6613\n\n\n97\n中国联通\nIT 系统支撑岗\n2024/9/26\n国企\n\n11.1\n\n\n\n\n\nhttps://www.iguopin.com/job/detail?id=109814615549935798\n\n\n98\n中国民生银行\n2025 届校园招聘——金融科技\n2024/9/26\n私企\n\n\n\n\n\n\n\nhttps://career.cmbc.com.cn/#/app/recruitmentview/e4897522-e4f0-4668-8557-8ddead0f234e\n\n\n99\n上海银行\n总行科技&amp;大数据岗（应用开发）\n2024/9/26\n国企\n\n\n\n\n\n\n\nhttps://bosc.zhiye.com/campus/detail?jobAdId=6c4c10d1-8cf1-4fa4-b17b-2e0c68e38d7a\n\n\n100\n神州信息\n2025 届-Java 开发工程师（广州）(J17160)\n2024/9/26\n私企\n\n10.9\n\n\n\n\n\nhttps://dcits.zhiye.com/campus/detail?jobAdId=b700aeb6-eb51-418d-b63f-0fe7066173fe\n\n\n101\n上海金融期货信息技术有限公司\n软件开发工程师-Java(J10424)\n2024/9/26\n私企\n\n\n\n\n\n\n\nhttps://cffexit.zhiye.com/zpdetail/390705223\n\n\n102\n菜鸟\nJava Software Engineer\n2024/9/27\n私企\n\n\n\n\n\n\n\nhttps://cn-jobs.cainiao.com/campus/position-detail?lang=zh&amp;positionId=30002039701\n\n\n103\nTCL\n后端开发工程师（JAVA）\n2024/9/27\n国企\n9.27\n10.11\n\n\n\n\n\nhttps://wecruit.hotjob.cn/SU64893571bef57c16d356b99e/pb/posDetail.html?postId=66c324381c240e39b5c5f2a2&amp;postType=campus\n\n\n104\n格力\n应用软件设计\n2024/9/27\n私企\n\n\n\n\n\n\n\nhttps://zhaopin.greeyun.com/job?JobCode=G0019c0f\n\n\n105\n华硕\nJava 开发工程师(2025 届)(J10601)\n2024/9/27\n私企\n\n\n\n\n\n\n简历寄\nhttps://asustek.zhiye.com/campus/detail?jobAdId=221c40cf-37fe-4dd0-97fd-caed3d7b12ea\n\n\n106\n电网安全稳定控制技术分公司\n软件研发(新能源并网分析与控制)\n2024/9/27\n国企\n\n\n\n\n\n\n简历寄\nhttp://job.sgepri.sgcc.com.cn/nari-career-ui/recuritDetail?id=1fcb1f01bb16455488bfe9edce190f61&amp;type=02&amp;userId=fa787a8447344d6b967ea4174b5299b4\n\n\n107\n南京南瑞信息通信科技有限公司\n软件研发(信息安全)\n2024/9/27\n国企\n9.27\n\n10.13\n\n\n\n\nhttp://job.sgepri.sgcc.com.cn/nari-career-ui/recuritDetail?id=0284995827fd4b16aae3c0dce934b396&amp;type=02&amp;userId=fa787a8447344d6b967ea4174b5299b4\n\n\n108\n中国电建集团华东勘测设计研究院有限公司\n华东院 2025 校园招聘\n2024/9/27\n国企\n\n\n\n\n\n\n\nhttps://zhaopin.powerchina.cn/apply/view/recruit/detailTd/3149/336\n\n\n109\n北京华科软科技有限公司\nJava 开发工程师\n2024/9/27\n国企\n\n\n\n\n\n\n\nhttps://zhaopin.powerchina.cn/apply/view/recruit/detailTd/2208/307\n\n\n110\n中电建装备集团有限公司\n中电建武汉铁塔有限公司管理岗、技术岗\n2024/9/27\n国企\n\n\n\n\n\n\n\nhttps://zhaopin.powerchina.cn/apply/view/recruit/detailTd/2759/320\n\n\n111\n广发银行总行\n总行金融科技类（广州、佛山）\n2024/9/27\n国企\n\n\n\n\n\n\n\nhttps://chinalife.zhiye.com/custom/zwxq?hideMenu=1&amp;jobAdId=7d725d4c-e584-420d-b99a-746a7feb02f3&amp;activityGuid=&amp;jc=2&amp;ClassificationTwo=广发银行总行&amp;ClassificationOne=金融科技类\n\n\n112\n浦发银行\n信息科技岗（广州分行）\n2024/9/27\n国企\n9.28\n10.12\n线下无法参加\n\n\n\n\nhttps://job.spdb.com.cn/jobDetail?jobId=10019663&amp;type=2\n\n\n113\n浦发银行\n信息科技岗（深圳分行）\n2024/9/27\n国企\n\n\n线下无法参加\n\n\n\n\nhttps://job.spdb.com.cn/jobDetail?jobId=10019692&amp;type=2\n\n\n114\n深信服\n（X-Star）深信服 25 届校招-JAVA 开发工程师\n2024/9/28\n私企\n\n\n\n\n\n\n\nhttps://hr.sangfor.com/campucompon/Delivery/4125\n\n\n115\n快手\nJava 开发工程师\n2024/9/28\n私企\n\n\n10.13\n\n\n\n一面寄\nhttps://campus.kuaishou.cn/#/campus/job-info/7156\n\n\n116\n科大讯飞\n飞凡计划-研发方向\n2024/9/28\n私企\n9.29\n10.13\n10.29\n\n\n\n\nhttps://campus.iflytek.com/official-pc/jobDetail?id=716&amp;projectId=13\n\n\n117\n科大讯飞\nJava 开发工程师\n2024/9/28\n私企\n\n11.24\n\n\n\n\n\nhttps://campus.iflytek.com/official-pc/jobDetail?id=723&amp;projectId=14\n\n\n118\n新华三\n软件开发工程师-Java(J17279)\n2024/9/28\n私企\n9.29\n10.24\n11.4\n11.6\n\n\n二面寄\nhttps://career.h3c.com/campus/detail?jobAdId=6bd127c8-0af3-4e01-84ee-03bb85f5ecee\n\n\n119\n虎牙\n(2025 届)后台开发工程师（Java 方向）\n2024/9/28\n私企\n\n\n10.25\n\n\n\n一面寄\nhttps://app.mokahr.com/campus_apply/huya/4112#/job/b0e1f41e-f3f8-4dba-a5bb-a8ae644664d4\n\n\n120\n海尔集团\n后端开发工程师\n2024/9/28\n私企\n\n\n\n\n\n\n简历寄\nhttps://maker.haier.net/client/campus/deliverfirst/id/31/fid/7/rid/32.html\n\n\n121\n同程旅行\nJAVA 开发工程师-苏州（25 届）\n2024/9/28\n私企\n\n10.11\n\n\n\n\n\nhttps://mhr.ly.com/recruit/schoolPortal/#/postDelivery?srt=0.26198736415035806\n\n\n122\n亚马逊\n软件开发工程师（上海 2024-25 校招）\n2024/9/28\n外企\n\n\n\n\n\n\n\nhttps://www.amazon.jobs/en/jobs/2731741/2024-25\n\n\n123\n施耐德电气\nEAE 软件开发工程师\n2024/9/28\n外企\n\n\n\n\n\n\n\nhttps://www.zhipin.com/zt/schneider/yanfaxinxing.html?source=99\n\n\n124\n先导智能\n软件开发工程师（2025 届校招）（珠海）(J16190)\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://leadchina.zhiye.com/campus/detail?jobAdId=e7833083-ec05-4a01-a439-0583be5db281\n\n\n125\n唯品会\n【2025 秋招】开发工程师（JAVA）\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://app-tc.mokahr.com/campus-recruitment/vipshophr/10039?previewKey=5a77f111a2994afc9669a3d68a8d050f139d9b6d4aa142029d3a9f20a6eba005#/job/d456fc72-2fb1-4edf-a6be-a6d83d908d27\n\n\n126\n京东方\n【创新业务】后端开发工程师（MOM 系统）（合肥）(J45853)\n2024/10/7\n私企\n10.9\n\n\n\n\n\n\nhttps://campus.boe.com/xzxq2022?jc=15&amp;ky=&amp;pi=1&amp;c=-1&amp;c1=0&amp;type=0&amp;jobId=880088657\n\n\n127\n润科通用\n软件类-campus-2025\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://wecruit.hotjob.cn/SU6461d2142f9d2433ba66d31d/pb/posDetail.html?postId=669a3b451eb8050602dbdd84&amp;postType=campus\n\n\n128\n北京计算机技术及应用研究所\n2025 届应用软件开发岗(J18716)\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://casic.m.zhiye.com/#/jobdetail?id=150932282\n\n\n129\n国元证券\nIT 类管培生\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://gyzq.zhiye.com/5/detail?jobAdId=255580be-2fe4-4c5e-bbf2-f97b344f2221\n\n\n130\n咪咕音乐\nJAVA 开发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://www.migu.cn/about/join/graduate/job/detail/MG6608744371.html\n\n\n131\n咪咕音乐\n后端开发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://www.migu.cn/about/join/graduate/job/detail/MG6052775050.html\n\n\n132\n中科创达\nJAVA 开发工程师\n2024/10/7\n私企\n\n10.9\n\n\n\n\n\nhttps://thundersoft.jobs.feishu.cn/campus/position/7418454509522995497/detail\n\n\n133\n大华股份\n【研发中心-成都】2025 届 Java 开发工程师(J21503)\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://job.dahuatech.com/#/CampusApply?id=754dd14b-5ed9-4844-b5ea-3c4092bfbc9d\n\n\n134\n宁德时代\n后端开发软件工程师\n2024/10/7\n私企\n10.15\n\n\n\n\n\n10.17 寄\nhttps://talent.catl.com/campus-recruitment/catlhr/142197#/job/c62e2ecd-0ff4-412c-84ba-c10042e4e58b\n\n\n135\n海康威视\n【2025 届校招】应用软件开发工程师\n2024/10/7\n国企\n10.11\n10.16\n\n\n\n\n\nhttps://campushr.hikvision.com/JobDetails.html?id\\=25647211087248d78469bed2b93424ca&amp;type\\=2&amp;batchId\\=0e58ff3c4aa343979ed97a54e4e41109\n\n\n136\n三七互娱\n后端开发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/37/25238?sourceToken=974e7eba170b288bb00457f03863d9bf#/job/c37c9641-45ad-40cc-a9c0-984b6d34c2e1\n\n\n137\n汇川技术\n【25 校招】Web 后端开发工程师\n2024/10/7\n私企\n10.15\n\n\n\n\n\n\nhttps://inovance.zhiye.com/campus/detail?jobAdId=0471a923-444b-4a2f-9864-c6868e4c4bdd\n\n\n138\n中国海油\n软件开发工程师（北京）\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/job/CC258591510J40754250115\n\n\n139\n中国海油\n计算机与信息类\n2024/10/7\n国企\n\n\n2.17\n\n\n\n2.17 offer\nhttps://xiaoyuan.zhaopin.com/job/CC258591510J40753919215\n\n\n140\n金山云\n25 届校招-研发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/kingsoft/39364?edit=1#/job/eb0297a2-8b61-434f-aeb0-641a4ebfea1f\n\n\n141\n索尼\n软件开发工程师(Cloud Native 领域系统)\n2024/10/7\n外企\n\n\n\n\n\n\n\nhttps://xyz.51job.com/External/Others/JobsSelect.aspx?JobID=cd02665e-32ed-4846-91ac-fe061a21ee9b&amp;CtmID=145ecf46-e080-455c-b218-a61c76b7b613&amp;JobSelectType=0&amp;prd=null&amp;prp=&amp;cd=&amp;cp=&amp;ruid=&amp;backurl=&amp;auid=&amp;uuid=&amp;partner=\n\n\n142\n索尼\n软件开发工程师(B2C 领域系统)\n2024/10/7\n外企\n\n\n\n\n\n\n\nhttps://xyz.51job.com/External/Others/JobsSelect.aspx?JobID\\=cd02665e-32ed-4846-91ac-fe061a21ee9b&amp;CtmID\\=145ecf46-e080-455c-b218-a61c76b7b613&amp;JobSelectType\\=0&amp;prd\\=null&amp;prp\\=&amp;cd\\=&amp;cp\\=&amp;ruid\\=&amp;backurl\\=&amp;auid\\=&amp;uuid\\=&amp;partner\\=\n\n\n143\n合合信息\n25 届秋招-后端开发工程师(J13099)\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://intsig.zhiye.com/campus/detail?jobAdId=47e33791-e2a8-459d-8258-4fb8589a1fb6\n\n\n144\n迅雷\n服务器开发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://campus.xunlei.com/campus_apply/xunlei/26600/#/job/968d22a9-0731-473d-836e-5e05caedde59\n\n\n145\n泰隆银行\nIT“菁英”人才（2025 届校招）(J12505)\n2024/10/7\n私企\n10.8\n\n\n\n\n\n\nhttps://zjtlcb.zhiye.com/campus/detail?jobAdId=6181c296-079d-4427-91a0-6810e8516eda\n\n\n146\n中国电子云\n【2025】云产品线-后端开发工程师（武汉）\n2024/10/7\n国企\n10.8\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/cestc/102244#/job/c0f5744a-b44c-433d-a36b-57b29d5f8195\n\n\n147\n中国邮政\n信息技术类\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/scrd/postprocess?cid=38689&amp;pid=101957340\n\n\n148\n中国邮政\n省信息技术中心-数据分析\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://xiaoyuan.zhaopin.com/scrd/postprocess?cid=38689&amp;pid=101957340\n\n\n149\n中能建数字科技集团有限公司\n数字化部项目研发岗\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://www.iguopin.com/job/detail?id=109767864193384630\n\n\n150\n中国能源建设集团浙江省电力设计院有限公司\n计算机工程师\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://www.iguopin.com/job/detail?id=109317574470144150\n\n\n151\n葛洲坝集团供应链管理有限公司\n研发工程师\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://www.iguopin.com/job/detail?id=110042336662126730\n\n\n152\n中国融通\n信息系统管理岗\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://job.crtc-hr.com/portal/#/recruitmentview/6771a0d4-6f84-4c5e-9a97-d5cefe850496/campus/\\u2f\\u72\\u65\\u63\\u72\\u75\\u69\\u74\\u6d\\u65\\u6e\\u74\\u2f\\u63\\u61\\u6d\\u70\\u75\\u73\\u2f\\u73\\u65\\u61\\u72\\u63\\u68\\u41\\u6c\\u6c?headStyle=false\n\n\n153\n酷睿程上海分公司\n软件研发工程师\n2024/10/7\n私企\n10.31\n\n\n\n\n\n\nhttps://carizon.jobs.feishu.cn/421026/position/7404754530829453607/detail\n\n\n154\n深圳精智达技术股份有限公司\nJAVA 工程师（深圳）\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://q.yingjiesheng.com/jobdetail/157630877.html?property={&quot;pageCode&quot;%3A&quot;&quot;,&quot;jobSource&quot;%3A&quot;网申&quot;,&quot;jobId&quot;%3A&quot;157630877&quot;,&quot;jobTitle&quot;%3A&quot;JAVA工程师（深圳）&quot;,&quot;jobRank&quot;%3A1,&quot;companyId&quot;%3A&quot;8983026&quot;,&quot;companyName&quot;%3A&quot;深圳精智达技术股份有限公司&quot;}\n\n\n155\n深圳精智达技术股份有限公司\nJAVA 工程师（合肥）\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://q.yingjiesheng.com/jobdetail/157630870.html?property={&quot;pageCode&quot;%3A&quot;&quot;,&quot;jobSource&quot;%3A&quot;网申&quot;,&quot;jobId&quot;%3A&quot;157630870&quot;,&quot;jobTitle&quot;%3A&quot;JAVA工程师（合肥）&quot;,&quot;jobRank&quot;%3A0,&quot;companyId&quot;%3A&quot;8983026&quot;,&quot;companyName&quot;%3A&quot;深圳精智达技术股份有限公司&quot;}\n\n\n156\n4399\n[2025 校招】Java 后端开发工程师\n2024/10/7\n私企\n\n10.28\n\n\n\n\n\nhttps://web.4399.com/campus/graduate/jishulei/kaifalei/#1230550\n\n\n157\n新浪微博\n软件开发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://career.sina.com.cn/campus-recruitment/sina/43536#/job/b788d407-70eb-4460-a7e0-911ccec71a8c\n\n\n158\n长光卫星技术股份有限公司\n软件开发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n简历寄\nhttps://xiaoyuan.zhaopin.com/job/CC262221580J40573535213\n\n\n159\n金山办公\n测试工程师-面向 25 届秋招-武汉\n2024/10/7\n私企\n\n10.12\n10.29\n\n\n\n一面寄\nhttps://app.mokahr.com/campus-recruitment/wps/41436?sourceToken=8379ee777457c4d22fc65d4439f660b3#/job/96041885-0eda-40e6-95d1-9db730fd3542\n\n\n160\n德赛西威汽车电子有限公司\n应用软件开发岗（2025 届-南京）\n2024/10/7\n私企\n10.15\n\n\n\n\n\n\nhttps://yesv-desaysv.jobs.feishu.cn/campus/position/7406206932346063115/detail\n\n\n161\n远景科技\n软件开发工程师\n2024/10/7\n私企\n10.8\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/envisiongroup/43123#/job/c7f96039-8970-4080-a9c5-d820bb702c79\n\n\n162\n数禾科技\n（2025 应届生）Java 工程师(J11338)\n2024/10/7\n私企\n\n10.23\n11.7\n\n\n\n\nhttps://shuhegroup1.zhiye.com/campus/detail?jobAdId=a8117385-d586-4d23-b23b-f45ac55abdd9\n\n\n163\n完美世界\nJava 开发工程师\n2024/10/7\n私企\n\n\n10.2\n\n\n\n一面寄\nhttps://app.mokahr.com/campus-recruitment/pwrd/140155#/job/d2a180fb-a67e-48f5-a4f2-bba4572a474b\n\n\n164\n中金公司\n【2025】软件开发岗(J17382)\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://cicc.zhiye.com/custom/campusxq?jc=2&amp;hideMenu=1&amp;jobAdId=ec6f62c2-b46f-4d98-b216-69ad622fc432\n\n\n165\n虾皮\n（25 届秋招）后端开发工程师-深圳\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/shopee/2962?sourceToken=1d70d3a2c4d1134f8c2ee537825e91ec#/job/aa0c2a2d-53be-4c68-a2cf-251aa9efc417\n\n\n166\n度小满\nJava 研发工程师-技术体系（上海）\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://talent.duxiaoman.com/campus-recruitment/duxiaoman/74050#/job/b294052e-9b91-4d8e-b6ad-f0ea90ec75ed\n\n\n167\nMomenta\n后端开发工程师（Java）\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://momenta.jobs.feishu.cn/campus/position/7400837412853532979/detail\n\n\n168\n高德地图\n研发工程师 JAVA-高德打车\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://talent.amap.com/campus/position-detail?lang=zh&amp;positionId=39900001820\n\n\n169\n高途集团\nJAVA 开发工程师-北京-2025 校招\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/bjhl/102145#/job/778eea27-d85c-4db7-ba9a-06ec7603a97a\n\n\n170\n中科芯\n软件开发工程师(J10177)\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://cksic.zhiye.com/campus/detail?jobAdId=4e17eb10-b18e-4d02-8df2-ca63354aad1d\n\n\n171\n英飞源技术\nJava 开发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://infypower.zhiye.com/campus/detail?jobAdId=e8c30faf-ccac-494a-96f4-c52f16d2abab\n\n\n172\n中科光电\n互联网工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttp://job.cn-amd.com/campus/details?id=58\n\n\n173\n贝壳找房\nJava 开发工程师【2025 届校招】(J63889)\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://campus.ke.com/campus/detail?jobAdId=1e8e54e0-79b2-40a6-a5ab-898e0427290e\n\n\n174\n作业帮\n[武汉]后端研发工程师\n2024/10/7\n私企\n\n10.24\n11.23\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/zuoyebang/150105#/job/98579db6-f4be-49c4-912f-bc2d2aa04b23\n\n\n175\n猿辅导\n2025 届校招-服务端研发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/fenbi/47742#/job/22c02e51-fd50-483f-ad90-097feff43db1\n\n\n176\n众安保险\n[2025 届秋招-ZA Bank]Java 开发工程师-深圳\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/zhongan/71908?sourceToken\\=c1ccb1fdb81c4cbcf002f290435cc50e#/job/c6abd93a-97ab-4889-9702-86e9177c5609\n\n\n177\n东方财富\n服务端开发工程师-Java 方向-25 届秋季校招\n2024/10/7\n私企\n10.8\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/eastmoney/57971#/job/61188eb1-28c5-49aa-adc6-74799efb7997\n\n\n178\n安克创新科技\n助理后台开发（Java）\n2024/10/7\n私企\n10.9\n10.17\n10.27\n\n\n\n\nhttps://anker-in.jobs.feishu.cn/campushirecn/position/7413306779402619145/detail?spread=DCZEPN2\n\n\n179\n中国平安\n2025 届总部科技管培生-后端\n2024/10/7\n私企\n10.23\n11.9\n11.13\n\n\n\n\nhttps://campus.pingan.com/positionDetail?positionId=bbe9b2612527319a8a97b6cdfece308b\n\n\n180\n哈啰\n【25 届英才】Java 开发工程师-软件研发中心-武汉\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://careers.hellobike.com/#/jobDetail?id\\=510969489\n\n\n181\n货拉拉\n【校招】后端开发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/huolalahr/98660#/job/587b9fca-71d5-4e4b-85ce-8208a72ef90a\n\n\n182\n苏宁易购\nJava 开发工程师\n2024/10/7\n私企\n\n\n\n\n\n\n\nhttps://campus.suning.cn/rps-campus/ftl/campus/managePositionDetail.htm?poId=26931\n\n\n183\n比亚迪\n比亚迪 2025 届秋季校园招聘\n2024/10/7\n私企\n10.8\n\n\n\n\n\n\nhttps://job.byd.com/portal/pc/#/school/schoolSangfor?1wdfb1LbMwhz4TymXhCJbg\\=\\=\n\n\n184\n中体彩科技发展有限公司\n软件开发工程师\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://24365.smartedu.cn/student/jobs/CgCvjB2U4w9uFDGrRENNYa/detail.html\n\n\n185\n北京计算机技术及应用研究所\njava 开发\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://24365.smartedu.cn/student/jobs/Hoi3ars7dRSA6798ssrCBu/detail.html\n\n\n186\n中电科金仓（北京）科技股份有限公司\nJava 开发工程师\n2024/10/7\n国企\n\n\n\n\n\n\n\nhttps://24365.smartedu.cn/student/jobs/5bUGZmSjasaiCX4b4mMLYU/detail.html#\n\n\n187\n古茗\n后端开发工程师\n2024/10/12\n私企\n\n10.18\n10.22\n\n\n\n一面寄\nhttps://app.mokahr.com/campus-recruitment/guming/39377#/job/d5188d1c-680b-4761-9c93-757ceb8ae187\n\n\n188\n数字马力\n25 届秋招-后端开发工程师-长沙\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/digital-engine/92713#/job/a6a7a153-f19f-40db-96e6-51708e22ca1a\n\n\n189\n联通数科\nJAVA 后端开发工程师(J12606)\n2024/10/12\n国企\n10.18\n10.18\n10.29\n11.6\n\n\n\nhttps://neitui.italent.cn/cudt/sharejobs?shareId=2cb3820f-5955-424b-bdc6-d750906fd03d&amp;language=zh_CN\n\n\n190\n得物\n【25 届校招】Java 开发工程师-杭州\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://campus.dewu.com/578078/position/7401796871620233510/detail\n\n\n191\n诺瓦星云\n25 届秋招-软件工程师（深圳）(J11699)\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://novastar.zhiye.com/campus/detail?jobAdId=56fb47af-c307-4336-a358-987a04d9790b\n\n\n192\ntp-link\n后台开发工程师（成都）(J10826)\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://career.tplinkglobal.com/form?fromPage=job&amp;jobAdId=07a2aa19-0e5a-4da9-9290-a51c97ef6fba&amp;userId=404789147\n\n\n193\n金蝶\n软件开发-JAVA\n2024/10/12\n私企\n\n10.13\n\n\n\n\n\nhttps://campus.51job.com/kingdee/\n\n\n194\n广电运通\n2025 届-软件工程师（Java 开发方向）\n2024/10/12\n国企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/grgbanking/39448#/job/73974af6-7c22-4503-8bd2-219797f0a098\n\n\n195\n兴业银行\nJava 开发工程师\n2024/10/12\n私企\n\n10.18\n\n\n\n\n\nhttps://job.cib.com.cn/#/positionDetails/1016354301425111040\n\n\n196\n吉利汽车\n后端开发工程师\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://autocampus.geely.com/campus-recruitment/geely/102225/#/job/2ea3708a-7d62-4a43-a8f1-03c7f5906a98\n\n\n197\n58 同城\n后端开发工程师(J32063)\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://career.58.com/campus/detail?jobAdId=1ce1ec33-74b0-4ec2-8a2d-7f5f7f99892f\n\n\n198\n阅文集团\nJava 开发工程师 QZ14\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://www.nowcoder.com/careers/yuewen/146828\n\n\n199\n挚文集团\n【2025 届秋招】Java 工程师（海外业务）\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/immomo/54299?sourceToken=24d7028898346cb2a27ae92fb4a04b8e#/job/22e14c14-6679-46ae-8be9-8a284e015204\n\n\n200\n挚文集团\n2025 届秋招】Java 开发工程师（陌陌业务）\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/immomo/54299?sourceToken=24d7028898346cb2a27ae92fb4a04b8e#/job/76d34ea1-0141-4aab-8e46-6455ebbaa915\n\n\n201\n盒马\n研发工程师 JAVA\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://hire.freshippo.com/campus/position-detail?lang\\=zh&amp;positionId\\=49900001703\n\n\n202\n真我\n后端工程师\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://careers.realme.com/university/realme/campus/post/1664?recruitType=Graduate\n\n\n203\n途游游戏\n后端开发工程师（北京）-2025 校招\n2024/10/12\n私企\n\n10.19\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/tuyoogame/71965#/job/e1bd7ba5-69d5-48f7-a63a-b9f5a829184f\n\n\n204\n中国船舶集团第 709 研究所\n软件工程师\n2024/10/12\n国企\n\n\n\n\n\n\n\nhttps://cssc709.zhiye.com/campus/detail?jobAdId=109c37a2-e600-40a6-a154-4f30c2dc0adb\n\n\n205\n华测导航\nJava 开发工程师(J11511)\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://huace.zhiye.com/campus/detail?jobAdId=38799700-cdda-41bf-917a-73d49bdd8689\n\n\n206\n康冠科技\n软件开发工程师(J10946)\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://careerktc.zhiye.com/campus/detail?jobAdId\\=9f7f26ad-91c2-42c1-a721-916ab7320f4e\n\n\n207\n浙江保融集团\n软件开发工程师（Java、Python）（2025 秋招）\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://campus.fingard.com/campus_apply/baorong/25901/#/job/493d3525-f9d4-4cc2-a0f1-8e61d30e2c28\n\n\n208\n杭州米加健康集团有限公司\nJava 开发工程师\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus_apply/mija/41909#/job/88a29cc2-c791-419e-9295-be288060a7a2\n\n\n209\n广联达\n25 届校招-Java 开发工程师\n2024/10/12\n私企\n10.18\n10.23\n\n\n\n\n\nhttps://campus.glodon.com/campus-recruitment/glodon/91966/#/job/b0471f67-7e87-48fa-a15f-9ba104e8bbea\n\n\n210\n迈瑞医疗\nRD11 软件开发工程师(J15551)\n2024/10/12\n私企\n10.14\n\n\n\n\n\n\nhttps://career.mindray.com/campus/detail?jobAdId=7cfa5b54-7d52-4bba-96b8-b2a15d320933\n\n\n211\n微派网络\n2025 校招-服务器开发工程师\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://wepie.jobs.feishu.cn/359597/position/7405546381568772361/detail\n\n\n212\n微派网络\n服务器开发实习生（贪吃蛇）\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://wepie.jobs.feishu.cn/359597/position/7351343364103620876/detail\n\n\n213\n微派网络\n2025 校招-IT 工程师\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://wepie.jobs.feishu.cn/359597/position/7407700866058684713/detail\n\n\n214\n长江存储\n软件开发(J13471)\n2024/10/12\n私企\n10.15\n\n\n\n\n\n\nhttps://ymtc.zhiye.com/campus/detail?jobAdId=94cdf56c-0e5d-4c6c-98d3-f1c4dc6b6980\n\n\n215\n烽火通信\n软件研发工程师（武汉）\n2024/10/12\n国企\n10.14\n10.14\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/whfhtx/73922#/job/63fdcd09-bb16-42f9-b5c2-a3589c7932eb\n\n\n216\n烽火星空\nJava 开发\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://career.fhss.com.cn/post\n\n\n217\n旷视科技\n后端开发工程师\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus\\_apply/megviihr/38642#/job/0902e993-00cf-4c02-8b62-35d60f3bde16\n\n\n218\n华勤技术\n应用软件开发工程师（2025 届）\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/hq/44757#/job/3b6b90d1-35cf-45be-b3b0-10af0fb4e5e0\n\n\n219\n竞技世界\nJava 开发工程师（2025）\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/jjworld/94602#/job/69c3b89d-1a6f-43c7-bb32-774bf9dc2936\n\n\n220\n最右\n【2025 校招】后台开发工程师\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus_apply/xiaochuankeji/3518#/job/9a6158bd-bd64-4ede-b1d8-86d0ce1702e2\n\n\n221\n喜马拉雅\n2025 校招-服务端开发\n2024/10/12\n私企\n\n10.26\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/himalaya/92431#/job/b01ca772-22c6-42c7-a341-0d6f927d81e2\n\n\n222\n好未来\n25 校招-JAVA 开发工程师\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://xiaozhao.100tal.com/campus-recruitment/tal/95443/#/job/318c7fb9-bdd6-406d-8eb1-7de95328a1f1\n\n\n223\n杭州银行\n总行信息技术部培训生(软件研发方向)\n2024/10/12\n国企\n\n\n\n\n\n\n\nhttps://myjob.hzbank.com.cn/hzzp-apply-web/static/index.html#/employDesc?id\\=27155781\n\n\n224\n奇瑞\n软件开发(J21576)\n2024/10/12\n私企\n10.16\n\n\n\n\n\n\nhttps://chery.zhiye.com/campus/detail?jobAdId=793a9378-c9fc-46a9-a2c9-7053dc410c75\n\n\n225\n小天才\n2025 届秋招-Java 开发工程师\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/eebbk/37594?sourceToken=6ef8d3e88d0533460387b2694b2fed24#/job/9cf34fd6-fccc-49fc-9af2-ed25b2a30c3a\n\n\n226\nSHEIN\nJAVA 工程师（广州）-2025 届\n2024/10/12\n私企\n10.15\n\n\n\n\n\n寄\nhttps://app.mokahr.com/campus-recruitment/shein/2932#/job/98751aa1-09be-4f3c-8dc3-1d1cc662cb93\n\n\n227\n中通快递\n中通快递-IT 校招-Java 开发-上海市\n2024/10/12\n私企\n10.15\n10.18\n\n\n\n\n寄\nhttps://hr.zto.com/position-detail?id=5480\n\n\n228\n瑞幸咖啡\n测试开发工程师（北京）\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus_apply/lkcoffee/45257?sourceToken=62d47e411f9ada5b1bccd95c3ba0e0c4#/job/5aa57646-d56d-499b-8c1d-01b8f92ea150\n\n\n229\n北京计算机技术及应用研究所\njava 开发(J18550)\n2024/10/12\n国企\n\n\n\n\n\n\n\nhttps://casic.zhiye.com/xiangqing?jobId\\=150935883\n\n\n230\n北京新风航天装备有限公司\n2025 届软件开发与集成师岗位(J18792)\n2024/10/12\n国企\n\n\n\n\n\n\n\nhttps://casic.zhiye.com/xiangqing?jobId=150946182\n\n\n231\n航天科工网络信息发展有限公司\n后端开发工程师(J18738)\n2024/10/12\n国企\n\n\n\n\n\n\n\nhttps://casic.zhiye.com/xiangqing?jobId=150946504\n\n\n232\n联友科技\n校招-后端开发工程师\n2024/10/12\n私企\n\n\n\n\n\n\n\nhttps://szly.zhiye.com/campus/detail?jobAdId=2b210091-076e-400d-be3d-94a15397a37c\n\n\n233\n石化盈科\nJAVA 开发初级工程师\n2024/10/17\n国企\n\n\n\n\n\n\n\nhttps://wecruit.hotjob.cn/SU66f110246202cc1a0cb26886/pb/posDetail.html?postId=66f3ebf96202cc1a0cbacbf9&amp;postType=campus\n\n\n234\n途虎养车\nJAVA 开发工程师（2025 届校招）-武汉\n2024/10/18\n私企\n\n\n\n\n\n\n\nhttps://app.mokahr.com/campus-recruitment/tuhu/28398#/job/bb1030fb-658f-429f-b73e-c4638f52b645\n\n\n235\n中国联合网络通信有限公司湖北省分公司\n软件开发工程师\n2024/10/24\n国企\n\n\n\n\n\n\n\nhttps://www.iguopin.com/job/detail?id=110781019363213409\n\n\n236\n合肥通用机械研究院有限公司\n计算机应用、软件工程\n2024/10/24\n国企\n\n\n\n\n\n\n\nhttps://www.iguopin.com/job/detail?id=109901936345481281\n\n\n237\n国家电投集团数字科技有限公司\n软件开发工程师（含前端、后端)\n2024/10/24\n国企\n\n\n\n\n\n\n\nhttps://www.iguopin.com/job/detail?id=113110305873068145\n\n\n238\n国机数字科技有限公司\n后端开发工程师（校招)\n2024/10/24\n国企\n\n\n\n\n\n\n\nhttps://www.iguopin.com/job/detail?id=113947129633833039\n\n\n239\n中电金信数字科技集团股份有限公司\n后端开发工程师\n2024/10/24\n国企\n\n\n\n\n\n\n\nhttps://www.iguopin.com/job/detail?id=112102300536799310\n\n\n240\n中国民航信息集团有限公司\nJava 后端软件开发工程师\n2024/10/24\n国企\n\n\n\n\n\n\n\nhttps://www.iguopin.com/job/detail?id=117617520873046051\n\n\n241\n腾讯\n软件开发-前端开发方向\n2025/2/19\n私企\n\n\n\n\n\n\n\nhttps://join.qq.com/post_detail.html?pid=1&amp;id=106&amp;tid=2\n\n\n242\n拼多多\nWeb 前端研发工程师\n2025/2/19\n私企\n\n\n\n\n\n\n\nhttps://careers.pddglobalhr.com/campus/grad/technical-session/detail?positionId=246e7516-9624-49d0-b5f8-2102d8f264b1\n\n\n243\nvivo\n软件工程师（后端方向）-25 届春招\n2025/2/19\n私企\n\n\n\n\n\n\n\nhttps://hr-campus.vivo.com/campus/detail?jobAdId\\=da255862-ce15-4bee-a118-283e3bb7e302\n\n\n244\n长鑫存储\n软件工程(J15880)\n2025/2/19\n私企\n\n\n\n\n\n\n\nhttp://jobs.cxmt.com/campus/detail?jobAdId=c73072b3-0a35-4540-b0b2-8b06ff279cf1\n\n\n245\nTestla\nMobile Application Development Engineer\n2025/2/19\n外企\n\n\n\n\n\n\n\nhttps://www.tesla.cn/careers/search/job/-mobile-application-development-engineer-138982\n\n\n246\nYY\nweb 前端开发工程师(J10477)\n2025/2/19\n私企\n\n\n\n\n\n\n\nhttps://yylive.zhiye.com/campus/detail?jobAdId=3a5d7681-40b1-47bd-96e7-0f22066e187f\n\n\n247\n网易\n前端开发工程师\n2025/2/19\n私企\n\n\n\n\n\n\n\nhttps://campus.163.com/app/detail/index?id=3089&amp;projectId=64\n\n\n248\n百度\n北京-Web 前端研发工程师(J73143)\n2025/2/19\n私企\n\n\n\n\n\n\n\nhttps://talent.baidu.com/jobs/detail/GRADUATE/c894b39c-db3a-4d4a-9948-a877c0f68969\n\n\n\n 校招笔面试记录\n\n\n\n行号\n公司\n类型\n状态\n时间\n\n\n\n\n1\n小米\n测评\n已完成\n2024-09-11 → 2024-09-14\n\n\n2\n用友\n测评\n已完成\n2024-09-11 → 2024-09-18\n\n\n3\n京东\n测评\n已完成\n2024-09-12 → 2024-09-19\n\n\n4\n腾讯\n测评\n已完成\n2024-09-12 → 2024-09-14\n\n\n5\n拼多多\n测评\n已完成\n2024/9/13\n\n\n6\n蚂蚁\n测评\n已完成\n2024/9/13\n\n\n7\n携程\n测评\n已完成\n2024-09-13 → 2024-09-18\n\n\n8\n信飞科技\n测评\n已完成\n2024/9/14\n\n\n9\n国轩高科\n测评\n已完成\n2024-09-14 → 2024-09-17\n\n\n10\n小红书\n笔试\n已完成\n2024-09-14 → 2024-09-14\n\n\n11\n360\n笔试\n已完成\n2024-09-14 → 2024-09-14\n\n\n12\n顺丰\n测评\n已完成\n2024/9/17\n\n\n13\n招银网络\n测评\n已完成\n2024-09-17 → 2024-09-23\n\n\n14\n去哪儿\n测评\n已完成\n2024-09-18 → 2024-09-22\n\n\n15\n小米\n笔试\n已完成\n2024-09-19 → 2024-09-19\n\n\n16\nOPPO\n测评\n已完成\n2024-09-20 → 2024-09-22\n\n\n17\nOPPO\n笔试\n已完成\n2024-09-21 → 2024-09-21\n\n\n18\n顺丰\n笔试\n已完成\n2024-09-21 → 2024-09-21\n\n\n19\n信飞科技\n笔试\n已完成\n2024/9/22\n\n\n20\n拼多多\n笔试\n已完成\n2024-09-22 → 2024-09-22\n\n\n21\n招银网络\n笔试\n已完成\n2024-09-23 → 2024-09-23\n\n\n22\n华为\n测评\n已完成\n2024-09-24 → 2024-09-26\n\n\n23\n中兴通讯\n测评\n已完成\n2024-09-24 → 2024-09-26\n\n\n24\n小鹏汽车\n一面\n已完成\n2024-09-25 → 2024-09-25\n\n\n25\n华为\n笔试\n已完成\n2024-09-25 → 2024-09-26\n\n\n26\n中兴通讯\n笔试\n已完成\n2024-09-26 → 2024-09-28\n\n\n27\n恒生电子\n笔试\n未完成\n2024-09-26 → 2024-09-26\n\n\n28\nCVTE\n笔试\n已完成\n2024-09-27 → 2024-09-27\n\n\n29\nTCL\n测评\n已完成\n2024-09-27 → 2024-09-30\n\n\n30\n南瑞\n测评\n已完成\n2024-09-27 → 2024-09-29\n\n\n31\n浦发银行\n测评\n已完成\n2024-09-28 → 2024-09-29\n\n\n32\n网易\n笔试\n已完成\n2024-09-28 → 2024-09-28\n\n\n33\n科大讯飞\n测评\n已完成\n2024-09-28 → 2024-10-01\n\n\n34\n新华三\n测评\n已完成\n2024-09-28 → 2024-10-13\n\n\n35\n滴滴\n笔试\n已完成\n2024-09-28 → 2024-09-28\n\n\n36\n蚂蚁\n笔试\n已完成\n2024-09-29 → 2024-09-29\n\n\n37\nTP-LINK\n笔试\n已完成\n2024-09-30 → 2024-10-06\n\n\n38\n远景科技\n测评\n已完成\n2024-10-07 → 2024-10-09\n\n\n39\n比亚迪\n测评\n已完成\n2024-10-07 → 2024-10-08\n\n\n40\n泰隆银行\n测评\n已完成\n2024/10/7\n\n\n41\n京东方\n测评\n已完成\n2024-10-08 → 2024-10-23\n\n\n42\n海康威视\n测评\n已完成\n2024-10-08 → 2024-10-15\n\n\n43\n汇川技术\n测评\n已完成\n2024-10-08 → 2024-10-23\n\n\n44\n中国电子云\n测评\n已完成\n2024-10-08 → 2024-10-10\n\n\n45\n东方财富\n测评\n已完成\n2024-10-08 → 2024-10-11\n\n\n46\n中科创达\n笔试\n已完成\n2024-10-08 → 2024-10-11\n\n\n47\n神州信息\n笔试\n已完成\n2024/10/9\n\n\n48\n淘天集团\n测评\n已完成\n2024/10/9\n\n\n49\nTCL\n笔试\n已完成\n2024-10-09 → 2024-10-11\n\n\n50\n安克创新\n测评\n已完成\n2024-10-09 → 2024-10-12\n\n\n51\n招银云创\n笔试\n已完成\n2024-10-09 → 2024-10-09\n\n\n52\nTP-LINK\n一面\n已完成\n2024-10-10 → 2024-10-10\n\n\n53\n携程\n笔试\n已完成\n2024-10-10 → 2024-10-10\n\n\n54\nTCL\n笔试\n已完成\n2024-10-10 → 2024-10-12\n\n\n55\n去哪儿旅行\n笔试\n已完成\n2024-10-10 → 2024-10-10\n\n\n56\n字节跳动\n一面\n已完成\n2024-10-10 → 2024-10-10\n\n\n57\n小鹏汽车\n二面\n已完成\n2024-10-11 → 2024-10-11\n\n\n58\n美团\nAI 面\n已完成\n2024-10-11 → 2024-10-13\n\n\n59\n满帮集团\n笔试\n已完成\n2024-10-11 → 2024-10-11\n\n\n60\n同程旅行\n笔试\n已完成\n2024-10-11 → 2024-10-11\n\n\n61\n德赛西威汽车电子\n测评\n已完成\n2024/10/12\n\n\n62\nTP-LINK\n二面\n已完成\n2024-10-12 → 2024-10-12\n\n\n63\n京东\n笔试\n已完成\n2024-10-12 → 2024-10-12\n\n\n64\n浦发银行\n笔试\n已完成\n2024-10-12 → 2024-10-12\n\n\n65\n米哈游\n笔试\n已完成\n2024-10-12 → 2024-10-12\n\n\n66\n奇安信\n笔试\n已完成\n2024-10-12 → 2024-10-12\n\n\n67\n美团\n笔试\n已完成\n2024-10-12 → 2024-10-12\n\n\n68\n金山办公\n笔试\n已完成\n2024-10-12 → 2024-10-12\n\n\n69\n迈瑞医疗\n测评\n已完成\n2024-10-13 → 2024-10-15\n\n\n70\n烽火通信\n测评\n已完成\n2024-10-13 → 2024-10-15\n\n\n71\n烽火通信\n笔试\n已完成\n2024-10-13 → 2024-10-15\n\n\n72\n华勤技术\n笔试\n未完成\n2024-10-13 → 2024-10-18\n\n\n73\n华勤技术\n测评\n未完成\n2024-10-13 → 2024-10-18\n\n\n74\n奇瑞\n测评\n已完成\n2024-10-13 → 2024-11-12\n\n\n75\n中通快递\n测评\n已完成\n2024-10-13 → 2024-10-16\n\n\n76\n小红书\n笔试\n已完成\n2024-10-13 → 2024-10-13\n\n\n77\n金蝶\n笔试\n已完成\n2024-10-13 → 2024-10-14\n\n\n78\n科大讯飞\n笔试\n已完成\n2024-10-13 → 2024-10-13\n\n\n79\n南瑞\n一面\n已完成\n2024-10-14 → 2024-10-14\n\n\n80\n宁德时代\n测评\n已完成\n2024-10-14 → 2024-10-16\n\n\n81\nSHEIN\n测评\n已完成\n2024-10-14 → 2024-10-16\n\n\n82\n快手\n一面\n已完成\n2024/10/14\n\n\n83\n好未来\n笔试\n未完成\n2024-10-14 → 2024-10-15\n\n\n84\n阿里国际\n笔试\n已完成\n2024-10-14 → 2024-10-14\n\n\n85\n兴业银行\n笔试\n已完成\n2024/10/15\n\n\n86\n长江存储\n测评\n已完成\n2024/10/15\n\n\n87\n百度\n笔试\n已完成\n2024-10-15 → 2024-10-16\n\n\n88\nTP-LINK\n三面\n已完成\n2024/10/16\n\n\n89\n安克创新\n笔试\n已完成\n2024-10-16 → 2024-10-18\n\n\n90\n海康威视\n笔试\n已完成\n2024-10-16 → 2024-10-17\n\n\n91\n古茗\n笔试\n已完成\n2024-10-16 → 2024-10-19\n\n\n92\n用友\n笔试\n已完成\n2024-10-16 → 2024-10-17\n\n\n93\n金蝶\n一面\n未完成\n2024/10/16\n\n\n94\n淘天集团\n笔试\n已完成\n2024-10-16 → 2024-10-16\n\n\n95\ntp-link\n测评\n未完成\n2024-10-17 → 2024-11-01\n\n\n96\n上海金融期货信息技术有限公司\n笔试\n未完成\n2024-10-17 → 2024-10-17\n\n\n97\n广联达\n测评\n已完成\n2024-10-17 → 2024-10-20\n\n\n98\n招银云创\n一面\n已完成\n2024/10/18\n\n\n99\n中通快递\n笔试\n已完成\n2024-10-18 → 2024-10-21\n\n\n100\n字节跳动\n二面\n已完成\n2024/10/18\n\n\n101\n途虎养车\n测评\n未完成\n2024-10-18 → 2024-10-21\n\n\n102\nTP-LINK\n座谈会\n已完成\n2024/10/18\n\n\n103\n途游游戏\n笔试\n已完成\n2024-10-18 → 2024-10-21\n\n\n104\n酷睿程\nAI 面\n未完成\n2024-10-18 → 2024-10-18\n\n\n105\n58 同城\n笔试\n未完成\n2024-10-18 → 2024-10-18\n\n\n106\n联通数科\n笔试\n已完成\n2024-10-18 → 2024-10-18\n\n\n107\n联通数科\n测评\n已完成\n2024-10-18 → 2024-10-20\n\n\n108\n拼多多\n一面\n已完成\n2024/10/19\n\n\n109\n徽商银行\n笔试\n未完成\n2024/10/19\n\n\n110\n完美世界\n一面\n已完成\n2024/10/21\n\n\n111\n中国平安\n测评\n已完成\n2024-10-21 → 2024-10-28\n\n\n112\n广联达\n笔试\n已完成\n2024-10-22 → 2024-10-23\n\n\n113\n南京银行\n笔试\n未完成\n2024-10-22 → 2024-10-22\n\n\n114\n中国银联\n笔试\n已完成\n2024-10-22 → 2024-10-22\n\n\n115\n虾皮\n笔试\n未完成\n2024-10-22 → 2024-10-22\n\n\n116\n古茗\n一面\n已完成\n2024/10/23\n\n\n117\n数禾科技\n笔试\n已完成\n2024-10-23 → 2024-10-30\n\n\n118\n中国电子云\n笔试\n未完成\n2024-10-24 → 2024-10-24\n\n\n119\n新华三\n笔试\n已完成\n2024-10-24 → 2024-10-24\n\n\n120\n作业帮\n笔试\n已完成\n2024-10-24 → 2024-10-27\n\n\n121\n中信银行\n笔试\n已完成\n2024-10-25 → 2024-10-25\n\n\n122\n虎牙\n一面\n已完成\n2024/10/25\n\n\n123\n中国银联\n测评\n已完成\n2024-10-26 → 2024-10-28\n\n\n124\n小天才\n笔试\n未完成\n2024-10-26 → 2024-10-27\n\n\n125\n喜马拉雅\n笔试\n已完成\n2024-10-26 → 2024-10-26\n\n\n126\n中国移动\n笔试\n已完成\n2024-10-26 → 2024-10-26\n\n\n127\n新华三\nAI 面\n已完成\n2024-10-28 → 2024-10-31\n\n\n128\n安克创新\n一面\n已完成\n2024-10-28 → 2024-10-28\n\n\n129\n信也科技\n笔试\n已完成\n2024-10-28 → 2024-10-28\n\n\n130\n4399\n笔试\n已完成\n2024-10-28 → 2024-10-28\n\n\n131\n拼多多\n二面\n已完成\n2024/10/29\n\n\n132\n中国移动\n测评\n已完成\n2024-10-30 → 2024-10-31\n\n\n133\n联通数科\n一面\n已完成\n2024-10-30 → 2024-10-30\n\n\n134\n金山办公\n一面\n已完成\n2024/10/30\n\n\n135\n科大讯飞\n一面\n已完成\n2024/10/30\n\n\n136\n杭州米加健康集团有限公司\n笔试\n已完成\n2024/11/1\n\n\n137\n酷睿程\n测评\n已完成\n2024-11-01 → 2024-11-01\n\n\n138\n酷睿程\n笔试\n未完成\n2024-11-01 → 2024-11-01\n\n\n139\n中国联通\n笔试\n已完成\n2024-11-01 → 2024-11-01\n\n\n140\n中国联通\n测评\n已完成\n2024-11-01 → 2024-11-02\n\n\n141\n中国移动\nAI 面\n未完成\n2024-11-02 → 2024-11-03\n\n\n142\n中国移动\n笔试\n已完成\n2024-11-02 → 2024-11-02\n\n\n143\n中国人寿\n笔试\n已完成\n2024-11-02 → 2024-11-02\n\n\n144\n中移金科\nAI 面\n已完成\n2024-11-04 → 2024-11-07\n\n\n145\n新华三\n一面\n已完成\n2024/11/5\n\n\n146\n拼多多\n三面\n已完成\n2024/11/6\n\n\n147\n新华三\n二面\n已完成\n2024/11/6\n\n\n148\n阅文集团\n笔试\n未完成\n2024-11-06 → 2024-11-06\n\n\n149\n中国平安\n笔试\n已完成\n2024-11-07 → 2024-11-09\n\n\n150\n联通数科\n二面\n已完成\n2024/11/7\n\n\n151\n泰隆银行\n笔试\n未完成\n2024-11-07 → 2024-11-07\n\n\n152\n数禾科技\n一面\n已完成\n2024/11/8\n\n\n153\n中国移动咪咕公司\n笔试\n未完成\n2024-11-09 → 2024-11-09\n\n\n154\n建信金科\n笔试\n未完成\n2024-11-10 → 2024-11-10\n\n\n155\n中移金科\n笔试\n未完成\n2024-11-10 → 2024-11-10\n\n\n156\n信飞科技\n一面\n已完成\n2024/11/11\n\n\n157\n顺丰\n一面\n已完成\n2024-11-12 → 2024-11-12\n\n\n158\n华为\n笔试\n已完成\n2024-11-13 → 2024-11-14\n\n\n159\n中国平安\n一面\n已完成\n2024/11/14\n\n\n160\n顺丰\n二面\n已完成\n2024-11-15 → 2024-11-15\n\n\n161\n菜鸟\n笔试\n未完成\n2024-11-15 → 2024-11-15\n\n\n162\n华为\n一面\n已完成\n2024/11/22\n\n\n163\n华为\n二面\n已完成\n2024/11/22\n\n\n164\n兴业数金\n一面\n未完成\n2024/11/22\n\n\n165\n烽火通信\n一面\n未完成\n2024/11/22\n\n\n166\n中信银行\n一面\n已完成\n2024/11/22\n\n\n167\n中国电信\n笔试\n已完成\n2024-11-23 → 2024-11-23\n\n\n168\n作业帮\n一面\n已完成\n2024/11/23\n\n\n169\n拼多多\nHR 面\n已完成\n2024/11/24\n\n\n170\n科大讯飞\n笔试\n已完成\n2024-11-24 → 2024-11-24\n\n\n171\n华为\n三面\n已完成\n2024/11/25\n\n\n172\n腾讯\n一面\n已完成\n2024/12/3\n\n\n173\n国元证券\n笔试\n未完成\n2024-12-07 → 2024-12-07\n\n\n174\n中海油\nAI 面\n已完成\n2024-12-10 → 2024-12-12\n\n\n175\n真我\n一面\n未完成\n2024/12/27\n\n\n176\n阿里云\n测评\n已完成\n2025/2/16\n\n\n177\n中国海油\n一面\n已完成\n2025/2/17\n\n\n178\n长鑫存储\n测评\n未完成\n2025/2/19\n\n\n179\n长鑫存储\nAI 面\n未完成\n2025/2/19\n\n\n180\n阿里云\n一面\n已完成\n2025/2/20\n\n\n181\nvivo\n测评\n未完成\n2025-02-21 → 2025-02-24\n\n\n182\n阿里云\n二面\n已完成\n2025/2/21\n\n\n\n Intern\n\n\n\n序号\n职位\n公司\n申请日期\n时间线\n链接\n\n\n\n\n1\nSoftware Engineer Internship\nNEW EIG\n2024.1.30\n2.14 rej\nhttps://wellfound.com/jobs/2883123-software-engineer-internship\n\n\n2\nFront-End Engineer Internship – 2024 (US)\nAmazon\n2024.1.30\n\nhttps://www.amazon.jobs/en/jobs/2402579/front-end-engineer-internship-2024-us\n\n\n3\nSoftware Engineering Intern\nRoche\n2024.1.30\n2.29 rej\nhttps://careers.roche.com/global/en/job/202401-102354?source=JB-12568\n\n\n4\nJr. Developer – Internship\nSHI International Corp.\n2024.1.30\n\nhttps://www.shi.com/\n\n\n5\nWeb Developer – Internship\nSHI International Corp.\n2024.1.30\n\nhttps://www.shi.com/\n\n\n6\nSoftware Engineering Intern - Summer 2024\nBox\n2024.1.30\n\nhttps://box.eightfold.ai/careers/job/584135972786?domain=box.com&amp;utm_source=linkedin\n\n\n7\nSummer 2024 Intern - Software Engineer\nSalesforce\n2024.1.31\n\nhttps://salesforce.wd12.myworkdayjobs.com/External_Career_Site/job/California---San-Francisco/Summer-2024-Intern---Software-Engineer_JR210683\n\n\n8\nSoftware Engineer Intern, Security Research\nDatadog\n2024.1.31\n3.22 rej\nhttps://app.ripplematch.com/v2/public/job/fa3414f8/details?from_page=company_branded_page\n\n\n9\nFront-End Software Engineer Intern\nIntuit\n2024.1.31\n\nhttps://jobs.intuit.com/job/-/-/27595/60092990192\n\n\n10\nSoftware Engineer Intern (Summer)\nDatadog\n2024.1.31\n\nhttps://app.ripplematch.com/v2/public/job/e9a5081a/details?from_page=company_branded_page\n\n\n11\nSoftware Engineering: Intern Opportunities for University Students, Redmond\nMicrosoft\n2024.1.31\n1.31 rej\nhttps://jobs.careers.microsoft.com/us/en/job/1590499/Software-Engineering:-Intern-Opportunities-for-University-Students,-Redmond\n\n\n12\nFrontend Developer intern\nCleanbot\n2024.1.31\n\nhttps://wellfound.com/company/cleanbot\n\n\n13\nJava Developer Intern at Red Collar\nRed Collar\n2024.1.31\n\nhttps://wellfound.com/jobs/2862740-java-developer-intern\n\n\n14\nFrontend Software Engineering Intern at Naos\nNaos\n2024.1.31\n1.31 accept; 2.8 vo cancel\nhttps://wellfound.com/jobs/2911565-frontend-software-engineering-intern\n\n\n15\nSoftware Engineer Intern at JETSWEAT\nJETSWEAT\n2024.1.31\n\nhttps://wellfound.com/jobs/307020-software-engineer-intern\n\n\n16\nFrontEnd Developer Intern at InstaHub\nInstaHub\n2024.1.31\n\nhttps://wellfound.com/jobs/1918025-frontend-developer-intern\n\n\n17\nSoftware Engineer Intern – Summer 2024\nSeismic\n2024.1.31\n\nhttps://seismic.com/careers/job-detail/?gh_jid=5063590004&amp;utm_source=Simplify&amp;gh_src=Simplify#tab-2\n\n\n18\nSoftware Engineering Intern - Summer 2024\nWayfair\n2024.1.31\n\nhttps://www.wayfair.com/careers/job/software-engineering-intern---summer-2024/7032310002/apply?gh_src=&amp;source=&amp;referredBy=&amp;utm_source=Simplify&amp;ref=Simplify&amp;src=Simplify\n\n\n19\nFull Stack Engineering Internship/Co-Op\nZoox\n2024.1.31\n\nhttps://jobs.lever.co/zoox/abeb8ade-5c9c-473b-ab81-6bbb1b26d95c\n\n\n20\nStudent Training in Engineering Program (STEP) Intern, 2024\nGoogle China\n2024.1.31\n2.5 rej\nhttps://www.google.com/about/careers/applications/jobs/results/79019773569966790-student-training-in-engineering-program-step-intern-2024?company=Fitbit&amp;company=GFiber&amp;company=Google&amp;company=YouTube&amp;company=Loon&amp;company=Verily Life Sciences&amp;company=Waymo&amp;company=Wing&amp;company=X&amp;distance=50&amp;employment_type=INTERN&amp;hl=zh_CN&amp;jld=10&amp;location=Beijing, Beijing, China\n\n\n21\nSoftware Developer Intern\nGroup One Trading LP\n2024.1.31\n\nhttps://nyu.joinhandshake.com/stu/jobs/8563719?utm_campaign=job_recommendation_digest&amp;utm_source=job_recommendation_mailer&amp;utm_medium=email\n\n\n22\nSummer Internship - Software Engineer\nDow Jones &amp; Co.\n2024.1.31\n3.25 rej\nhttps://nyu.joinhandshake.com/stu/jobs/8580600?utm_campaign=job_recommendation_digest&amp;utm_source=job_recommendation_mailer&amp;utm_medium=email\n\n\n23\nSoftware Developer Intern (New York) – Summer 2024\nThe D. E. Shaw Group\n2024.1.31\n2.16 rej\nhttps://nyu.joinhandshake.com/stu/jobs/7923446\n\n\n24\nSoftware Developer Summer Internship - 2024\nInteractive Brokers\n2024.1.31\n\nhttps://nyu.joinhandshake.com/stu/jobs/8514182\n\n\n25\nSoftware Developer Intern\nNokia\n2024.1.31\n3.4 rej\nhttps://fa-evmr-saasfaprod1.fa.ocs.oraclecloud.com/hcmUI/CandidateExperience/en/sites/CX_1/job/109?keyword=\t+Software+Dev+Cloud+Intern&amp;lastSelectedFacet=TITLES&amp;location=United+States&amp;locationId=300000000480126&amp;locationLevel=country&amp;mode=location&amp;selectedTitlesFacet=TRA\n\n\n26\nSoftware Engineering Intern - FullStack - Summer 2024\nYCharts\n2024.1.31\n\nhttps://nyu.joinhandshake.com/stu/jobs/8638394?ref=preview-header-click&amp;search_id=17b9831e-7d99-4de4-80c8-7e119d72da57\n\n\n27\nSoftware Engineer\nRepRally\n2024.1.31\n\nhttps://nyu.joinhandshake.com/stu/jobs/8181796?ref=preview-header-click&amp;search_id=17b9831e-7d99-4de4-80c8-7e119d72da57\n\n\n28\nSoftware Engineer Intern\nUrsaTech\n2024.1.31\n3.22 accepted\nhttps://nyu.joinhandshake.com/stu/jobs/7193801?ref=preview-header-click&amp;search_id=17b9831e-7d99-4de4-80c8-7e119d72da57\n\n\n29\nSoftware Engineer - Intern (Summer 2024)\nC3 AI\n2024.1.31\n3.10 rej\nhttps://boards.greenhouse.io/c3ascend/jobs/6906464002\n\n\n30\nSoftware Engineer Intern\nUnisys\n2024.1.31\n\nhttps://nyu.joinhandshake.com/stu/jobs/8637321?ref=preview-header-click&amp;search_id=17b9831e-7d99-4de4-80c8-7e119d72da57\n\n\n31\nSoftware Engineering Intern\nCopart, Inc\n2024.2.1\n\nhttps://www.indeed.com/cmp/Copart,-Inc/jobs?jk=b36e37717b6fe97c&amp;q=software&amp;l=&amp;start=0&amp;from=smart-apply\n\n\n32\nInternship for software\nLRIT\n2024.2.1\n\nhttps://www.indeed.com/viewjob?jk=55e880e910f0d316&amp;from=apply-conf\n\n\n33\nWeb Development Intern\ndecormatters\n2024.2.1\n\nhttps://www.company.decormatters.com/web-development-intern\n\n\n34\nSoftware Engineer Intern - Site Reliability - Summer 2024 - Hybrid or Full Remote from MI, FL, IL, NC, or TX (Paid)\nTechSmith Corporation\n2024.2.1\n2.15 rej\nhttps://jobs.jobvite.com/techsmith/job/ou45qfwN\n\n\n35\nSoftware Development Engineering Intern - Summer 2024\nWhat If Holdings\n2024.2.1\n2.23 rej\nhttps://workforcenow.adp.com/mascsr/default/mdf/recruitment/recruitment.html?lang=en_US&amp;cid=89b912a1-a238-4632-bdac-1557fc732c42&amp;ccId=19000101_000001&amp;jobId=454766\n\n\n36\nSoftware Engineer Front End Intern\nRippling\n2024.2.1\n\nhttps://ats.rippling.com/rippling/jobs/14d8c154-2161-4c47-b47a-4159954bdabe?applicant_guid=b7135d3e-0dce-449f-93d5-b53764472807&amp;source=JobTarget via JobTarget Organic Sites Bundle&amp;utm_source=JobTarget&amp;utm_medium=JobTarget Organic Sites Bundle&amp;utm_campaign=Software Engineer Front End Intern (9ad6a8be-e9b8-475d-841e-f59c417630f3)&amp;_jtochash=PLZdpPuAqV1pOcJ7YUBZdx&amp;_jtocprof=vbiTlq35qdrTvplJSUhwrQ7NlbRjK5j5\n\n\n37\nSoftware Engineer Intern\nPayPal\n2024.2.1\n\nhttps://boards.greenhouse.io/ripplematchinterns/jobs/6905845002?utm_source=Simplify&amp;gh_src=Simplify#app\n\n\n38\nInternship Opportunities\nGrowGuide International\n2024.2.1\n2.6 accept 2.15 vo 2.20 offer\nhttps://www.ziprecruiter.com/jobs/growguide-international-3b7f4e57/internship-opportunities-b38c5c85\n\n\n39\nSoftware Engineer Intern, Pay Anyone Engineering\nChime\n2024.2.3\n\nhttps://boards.greenhouse.io/chime/jobs/7106567002?gh_jid=7106567002&amp;utm_source=Otta\n\n\n40\nSoftware Engineer Intern, User Experience Engineering\nThousandEyes\n2024.2.3\n\nhttps://boards.greenhouse.io/thousandeyes/jobs/5669890\n\n\n41\nSoftware Engineer Intern, Cloud and Enterprise Agents\nThousandEyes\n2024.2.3\n\nhttps://boards.greenhouse.io/thousandeyes/jobs/5669839\n\n\n42\nSummer 2024 Software Engineering Internship\nPendo\n2024.2.3\n2.5 rej\nhttps://boards.greenhouse.io/pendo/jobs/7116151002\n\n\n43\nSoftware Engineering Intern x5 (Viator)\nTripAdvisor\n2024.2.3\n\nhttps://boards.greenhouse.io/tripadvisor/jobs/5662036\n\n\n44\nIntern, Software Engineer\nVerint Systems Inc.\n2024.2.3\n\nhttps://fa-epcb-saasfaprod1.fa.ocs.oraclecloud.com/hcmUI/CandidateExperience/en/sites/CX/job/2299\n\n\n45\nIntern - Developer\nGroupsoft US, Inc.\n2024.2.3\n\nhttps://nyu.joinhandshake.com/stu/jobs/8524894?ref=preview-header-click&amp;search_id=857e5356-581e-4f92-82e0-8cac19833040\n\n\n46\nSoftware Engineering Internship – Summer 2024\nHudson River Trading\n2024.2.3\n2.6 rej\nhttps://www.hudsonrivertrading.com/careers/job/?q=software&amp;_4118765=Internship&amp;gh_jid=5271837&amp;req_id=447\n\n\n47\nFront End UI Developer Intern, Summer 2024\nJobfair®\n2024.2.3\n\nhttps://nyu.joinhandshake.com/stu/postings?page=2&amp;per_page=25&amp;sort_direction=desc&amp;sort_column=default&amp;query=intern&amp;job.job_types[]=3\n\n\n48\nMapping Web Internship/Co-op, Zoox\nZoox\n2024.2.3\n\nhttps://jobs.lever.co/zoox/a11fee05-06f2-488c-a285-67bed1e8405c\n\n\n49\nSoftware Engineering Intern, Support Systems - Summer 2024\nVerkada\n2024.2.4\n\nhttps://boards.greenhouse.io/verkada/jobs/4231968007\n\n\n50\nFull Stack Software Engineer Intern Fall 2024, FY24 (Meraki)\nCisco\n2024.2.4\n2.5 rej\nhttps://jobs.cisco.com/jobs/ProjectDetail/Full-Stack-Software-Engineer-Intern-Fall-2024-FY24-Meraki/1417726\n\n\n51\nYahoo Summer Intern (US) - Sports, Finance, Mail &amp; More!\nYahoo\n2024.2.4\n2.24 rej\nhttps://ouryahoo.wd5.myworkdayjobs.com/careers/job/United-States-of-America---Remote/Yahoo-Summer-Intern--US----Sports--Finance--Mail---More-_JR0023139\n\n\n52\nSoftware Engineering Intern\nCadence\n2024.2.4\n\nhttps://cadence.wd1.myworkdayjobs.com/en-US/External_Careers/job/SAN-JOSE/Software-Engineering-Intern---Summer-2024_R45546-2\n\n\n53\nWeb Developer Intern\nHarold-Jean-Louis\n2024.2.4\n\nhttps://jobs.smartrecruiters.com/HaroldJean-LouisInc/743999957128803-web-developer-intern?utm_source=ziprecruiter\n\n\n54\nSummer Internship 2024 - Platform Software Developer - Fort Wayne, IN\nStryker\n2024.2.6\n2.11 rej\nhttps://stryker.wd1.myworkdayjobs.com/zh-CN/StrykerCareers/job/Indiana/Summer-Internship-2024---Platform-Software-Developer---Fort-Wayne--IN_R504861?utm_source=Simplify&amp;ref=Simplify\n\n\n55\nSoftware Engineer Internship\nRobert Half\n2024.2.8\n\nhttps://apply.workable.com/qualitest-1/j/5DC41C5A00/apply/\n\n\n56\nSoftware Developer Intern\nQualitest\n2024.2.8\n\nhttps://apply.workable.com/qualitest-1/j/5DC41C5A00/apply\n\n\n57\nSoftware Developer Intern (New York) – Summer 2024\nThe D. E. Shaw Group\n2024.2.9\n\nhttps://www.deshaw.com/careers/software-developer-intern-new-york-summer-2024-4803\n\n\n58\nBackend Engineering Intern ('24)\nTinder\n2024.2.9\n\nhttps://jobs.lever.co/matchgroup/2f8a7eac-19f9-4078-b03f-11ee276cb853\n\n\n59\nInternships for Software Engineers - Summer 2024\nNXP Semiconductors\n2024.2.9\n\nhttps://nxp.wd3.myworkdayjobs.com/zh-CN/careers/job/Austin-Oakhill-Office/Internships-for-Software-Engineers---Summer-2024_R-10048773\n\n\n60\nSWE Intern, Summer 2024\nJobfair®\n2024.2.9\n\nhttps://nyu.joinhandshake.com/stu/jobs/8558701\n\n\n61\nSoftware Engineering, Security - Intern - 2024\nMongoDB\n2024.2.9\n2.17 rej\nhttps://app.ripplematch.com/v2/public/job/2349ff3d/details\n\n\n62\nTechnology Internship Program\nPENNYMAC\n2024.2.9\n2.13 rej\nhttps://careers-pennymac.icims.com/jobs/29151/intern/job?iis=Handshake&amp;ref=Simplify&amp;src=Simplify&amp;utm_source=Simplify&amp;mobile=false&amp;width=1110&amp;height=500&amp;bga=true&amp;needsRedirect=false&amp;jan1offset=-300&amp;jun1offset=-240\n\n\n63\nSoftware Intern, Web front-end\nNvidia\n2024.2.9\n\nhttps://nvidia.wd5.myworkdayjobs.com/en-US/NVIDIAExternalCareerSite/job/China-Shanghai/Software-Intern--Web-front-end_JR1977725\n\n\n64\nFront End Developer\ntheFuteur\n2024.2.9\n\nhttps://nyu.joinhandshake.com/stu/postings?page=1&amp;per_page=50&amp;sort_direction=desc&amp;sort_column=default&amp;job.job_applicant_preference.accepts_opt_cpt_candidates=true&amp;job.job_types[]=3&amp;job.on_site=true&amp;job.hybrid=true\n\n\n65\nSoftware Engineer Intern (2024 Summer)\nWhova, Inc.\n2024.2.9\n\nhttps://nyu.joinhandshake.com/stu/jobs/8523494\n\n\n66\nSoftware Engineering Intern - Computer Networking\nJuniper Networks\n2024.2.9\n\nhttps://nyu.joinhandshake.com/stu/jobs/8597483\n\n\n67\nSummer 2024 - Software Engineer Intern\nCoinbase\n2024.2.9\n\nhttps://www.coinbase.com/careers/positions/5442125\n\n\n68\nIntern – Software Engineering\nKargo\n2024.2.9\n\nhttps://www.kargo.com/careers?gh_jid=4224192007\n\n\n69\nSoftware Engineer, Intern - Summer 2024\nVisa\n2024.2.9\n2.12 rej\nhttps://jobs.smartrecruiters.com/Visa/743999964525703-software-engineer-intern-summer-2024\n\n\n70\nFrontend Engineering Intern-Summer 2024\nMark43\n2024.2.9\n\nhttps://mark43.com/list-job/?gh_jid=5437630\n\n\n71\nSoftware Engineering Intern (Summer 2024)\nThe Boring Company\n2024.2.9\n\nhttps://jobs.lever.co/boringcompany/8a8147f3-855d-4bd6-8221-a65a4291fea3/apply\n\n\n72\nSoftware Engineer Intern\nHudl\n2024.2.9\n2.14 rej\nhttps://boards.greenhouse.io/hudl/jobs/5450878\n\n\n73\nSoftware Engineering Internship Backend\nidentifeye HEALTH\n2024.2.9\n\nhttps://boards.greenhouse.io/tesseract/jobs/5881613003\n\n\n74\nFullstack Software Engineer Intern\nSkydio\n2024.2.9\n2.15 rej\nhttps://boards.greenhouse.io/skydio/jobs/5738838003\n\n\n75\n2024 Summer – Software Engineering Intern\nWorkiva\n2024.2.9\n2.15 rej\nhttps://workiva.wd1.myworkdayjobs.com/careers/job/Remote---IA/XMLNAME-2024-Summer---Software-Engineering-Intern_R7868\n\n\n76\nFull-Stack Intern\nUncountable\n2024.2.9\n\nhttps://jobs.lever.co/uncountable/6328427a-9047-44d5-82d6-56d533d8622e\n\n\n77\nSoftware Engineer – Intern\nZipRecruiter\n2024.2.9\n2.25 oa 2.26 rej\nhttps://boards.greenhouse.io/ziprecruiter/jobs/5281195\n\n\n78\nInternship – Front End Javascript\nINT Inc.\n2024.2.9\n\nhttps://www.int.com/jobs/internship-front-end-javascript/\n\n\n79\nWeb Development Intern\nSuperhuman Bikes\n2024.2.9\n\nhttps://www.indeed.com/jobs?q=software+engineer+intern&amp;sc=0kf%3Aattr(EXSNN|FCGTU|HFDVW|QJZM9|UTPWG%252COR)%3B&amp;vjk=f10ffedb894ab6d9\n\n\n80\nSoftware Engineer, Intern/Co-op\nMeta\n2024.2.9\n\nhttps://www.metacareers.com/jobs/1007975740551656\n\n\n81\nSoftware Engineer – Intern\nAcorns\n2024.2.10\n\nhttps://boards.greenhouse.io/acorns/jobs/5693697\n\n\n82\nSoftware Engineer – Summer Internship\nAdvisor360°\n2024.2.10\n3.19 rej\nhttps://www.advisor360.com/careers?gh_jid=5058836004\n\n\n83\nSoftware Engineering Intern\nAscend Analytics\n2024.2.10\n2.13 rej\nhttps://boards.greenhouse.io/ascendanalytics/jobs/4369048005\n\n\n84\nSoftware Development Engineer in Test Intern (Summer 2024)\nRocket Lawyer\n2024.2.10\n2.12 rej\nhttps://jobs.lever.co/rocketlawyer/1213bc12-4ae1-4117-b52e-5c2ed4a1a71b\n\n\n85\nTechnology Intern\nUniversaCare\n2024.2.11\n\nhttps://www.ziprecruiter.com/jobs/universacare-25fb161c/technology-intern-24b36ef1\n\n\n86\nSoftware Engineer Internship\nRokt\n2024.2.15\n\nhttps://nyu.joinhandshake.com/stu/jobs/8686918?ref=preview-header-click&amp;search_id=5f5725db-0bb6-4d04-ac67-79bca12cf2b4\n\n\n87\nSoftware Engineering Intern (San Jose)\nF5\n2024.2.15\n\nhttps://www.linkedin.com/jobs/search/?currentJobId=3765965982&amp;f_E=1&amp;keywords=software engineer&amp;origin=JOB_SEARCH_PAGE_JOB_FILTER\n\n\n88\nSoftware Engineering Intern, Frontend - Summer 2024\nVerkada\n2024.2.15\n\nhttps://www.linkedin.com/jobs/search/?currentJobId=3765965982&amp;keywords=Verkada&amp;origin=JOBS_HOME_SEARCH_BUTTON&amp;refresh=true\n\n\n89\nSoftware Engineering Intern\nElectric Hydrogen\n2024.2.15\n2.24 rej\nhttps://www.linkedin.com/jobs/search/?currentJobId=3774839731&amp;f_E=1&amp;keywords=software engineer&amp;origin=JOB_SEARCH_PAGE_JOB_FILTER\n\n\n90\nSoftware Engineer Intern - Analysis Workflows (US)\nAddepar\n2024.2.15\n4.2 rej\nhttps://www.linkedin.com/jobs/view/3812245373/?alertAction=markasviewed&amp;savedSearchId=1740451315&amp;refId=ByteString(length%3D16%2Cbytes%3D119ccf6f...02b044f7)&amp;trackingId=VYRrZHFKpXJaExrUz4A5vQ%3D%3D&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=3THPvBmv8qob81&amp;trk=eml-email_job_alert_confirmation_01-job_alert-4-member_details_mercado&amp;trkEmail=eml-email_job_alert_confirmation_01-job_alert-4-member_details_mercado-null-jkz8q4~lsnr46os~3a-null-jobs~view\n\n\n91\nSoftware Engineer - Intern\nPlaid\n2024.2.15\n\nhttps://www.untapped.io/app/discover/jobs/plaid/software-engineer-intern/e4cd29a7-c3df-4c51-821c-688241921f25?recommended=1\n\n\n92\nSoftware Engineer Intern (Summer 2024)\nSchneider Electric\n2024.2.18\n2.19 rej\nhttps://www.linkedin.com/jobs/view/3829522406/?trackingId=GwLZrOcoSLuK39KrPvYBkA%3D%3D&amp;refId=BjFFFsNwSyWoVC9aWe6KFw%3D%3D&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=3YvrlHTstLsb81&amp;trk=eml-email_jobs_viewed_job_reminder_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_jobs_viewed_job_reminder_01-job_card-0-jobcard_body-null-jkz8q4~lsrwgyld~5l-null-null&amp;eid=jkz8q4-lsrwgyld-5l&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYjY4N2NhZDQ0NjllYWQ4ZTZmN2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5NjFiNGYxZDA3NGI4ZWNhMWUxOTRkOWRmMjA4MDM4NzFhMThiYjNjNjBiOWQ1NTk5LDEsMQ%3D%3D\n\n\n93\nSoftware Engineer Intern\nResMed\n2024.2.18\n2.21 rej\nhttps://www.linkedin.com/jobs/view/3833728003/?trackingId=KlSLHpgZTGW1wXvWrCRd5w%3D%3D&amp;refId=hrJhq7PnS6uX31y9Z4IhTg%3D%3D&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=3YvrlHTstLsb81&amp;trk=eml-email_jobs_viewed_job_reminder_01-job_card-0-job_posting&amp;trkEmail=eml-email_jobs_viewed_job_reminder_01-job_card-0-job_posting-null-jkz8q4~lsrwgyld~5l-null-null&amp;eid=jkz8q4-lsrwgyld-5l&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYjY4N2NhZDQ0NjllYWQ4ZTZmN2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5NjFiNGYxZDA3NGI4ZWNhMWUxOTRkOWRmMjA4MDM4NzFhMThiYjNjNjBiOWQ1NTk5LDEsMQ%3D%3D\n\n\n94\nSoftware Engineering Intern, Frontend - Summer 2024\nVerkada\n2024.2.18\n\nhttps://boards.greenhouse.io/verkada/jobs/4135591007?utm_source=Simplify&amp;source=untapped&amp;gh_src=Simplify\n\n\n95\nSoftware Engineer Intern\nRoku\n2024.2.20\n\nhttps://simplify.jobs/p/478bccb0-7330-4556-9b62-beac65f56b97/Software-Engineer-Intern\n\n\n96\n2024 Software Engineering Intern (Fall 2024 or Spring 2025 Graduate)\nThe Trade Desk\n2024.2.20\n\nhttps://nyu.joinhandshake.com/stu/jobs/8690345?utm_campaign=job_alert_digest&amp;utm_source=activity_mailer&amp;utm_medium=email\n\n\n97\nSoftware Engineering Intern\nBloom Energy Corporation\n2024.2.20\n\nhttps://nyu.joinhandshake.com/stu/jobs/8684827?utm_campaign=job_alert_digest&amp;utm_source=activity_mailer&amp;utm_medium=email\n\n\n98\nSoftware Engineer Intern\nAddepar\n2024.2.21\n4.2 rej\nhttps://simplify.jobs/p/bbac8202-2617-481b-99cd-fcb3674222c0/Software-Engineer-Intern\n\n\n99\nWeb Development Intern\nIdeas United\n2024.2.21\n3.1 rej\nhttps://simplify.jobs/p/c174bc65-5bfd-451f-8609-44d52455bd63/Web-Development-Intern\n\n\n100\nSummer Software Intern\nStoke Space\n2024.2.22\n2.27 rej\nhttps://simplify.jobs/p/5a8127b4-433c-4b44-8061-47cee8495899/Summer-Software-Intern\n\n\n101\nSoftware Engineer Graduate Intern.\nIntel\n2024.2.22\n3.5 rej\nhttps://www.linkedin.com/jobs/view/3836233952/?trackingId=KyTSJH2GS8qmsvb91XtQ2w%3D%3D&amp;refId=ZFJ85NP9QL%2BW1Twyv96fqg%3D%3D&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=3Vn5gWJbzDxH81&amp;trk=eml-email_jobs_viewed_job_reminder_01-job_card-0-job_posting&amp;trkEmail=eml-email_jobs_viewed_job_reminder_01-job_card-0-job_posting-null-jkz8q4~lsxly4as~go-null-null&amp;eid=jkz8q4-lsxly4as-go&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYjI4ZGM3ZDU0ODkwYWY4ODY4N2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5MTVjN2UwZTE0NjhkZTg5NDVhMDNlMGIzYmEwOWM5ZjdkZjkxZDhiNzEwZWQyNWVmLDEsMQ%3D%3D\n\n\n102\nSoftware Developer Summer 2024 Intern\nU.S. News &amp; World Report\n2024.2.22\n\nhttps://www.linkedin.com/jobs/view/3837186991/?trackingId=WI%2FZVGuxQ56VRPy64AQ0mw%3D%3D&amp;refId=soVSgRN0RlKv89Gsp90ayw%3D%3D&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=3Vn5gWJbzDxH81&amp;trk=eml-email_jobs_viewed_job_reminder_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_jobs_viewed_job_reminder_01-job_card-0-jobcard_body-null-jkz8q4~lsxly4as~go-null-null&amp;eid=jkz8q4-lsxly4as-go&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYjI4ZGM3ZDU0ODkwYWY4ODY4N2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5MTVjN2UwZTE0NjhkZTg5NDVhMDNlMGIzYmEwOWM5ZjdkZjkxZDhiNzEwZWQyNWVmLDEsMQ%3D%3D\n\n\n103\nSoftware Developer Intern\nTraceLink\n2024.2.22\n\nhttps://www.linkedin.com/jobs/view/3837802677/?trackingId=KtpTsJloQvClTqPb1NzIeQ%3D%3D&amp;refId=rH6VbdpqS1KdBDFdV%2BDjfw%3D%3D&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=3Vn5gWJbzDxH81&amp;trk=eml-email_jobs_viewed_job_reminder_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_jobs_viewed_job_reminder_01-job_card-0-jobcard_body-null-jkz8q4~lsxly4as~go-null-null&amp;eid=jkz8q4-lsxly4as-go&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYjI4ZGM3ZDU0ODkwYWY4ODY4N2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5MTVjN2UwZTE0NjhkZTg5NDVhMDNlMGIzYmEwOWM5ZjdkZjkxZDhiNzEwZWQyNWVmLDEsMQ%3D%3D\n\n\n104\nSoftware Engineer Intern- Summer 2024\nSensata Technologies\n2024.2.22\n3.13 rej\nhttps://www.linkedin.com/jobs/view/3707052597/?alternateChannel=search&amp;refId=xvruSNEawINZ9rO6spuuvw%3D%3D&amp;trackingId=7XgyUJIg847qLSINUPEPfg%3D%3D&amp;trk=d_flagship3_search_srp_jobs\n\n\n105\nProgrammer Intern\nAcuity Insurance\n2024.2.22\n\nhttps://www.linkedin.com/jobs/view/3814033349/?alternateChannel=search&amp;refId=xvruSNEawINZ9rO6spuuvw%3D%3D&amp;trackingId=Vaaj8fOaGiq7omp6u9Hf1w%3D%3D&amp;trk=d_flagship3_search_srp_jobs\n\n\n106\nSoftware Engineer Intern\nLacework\n2024.2.23\n\nhttps://simplify.jobs/p/d8d10607-246f-4188-b836-2e619adde0f5/Software-Engineer-Intern\n\n\n107\nSoftware Engineering Intern (Summer 2024)\nSigma Computing\n2024.2.23\n\nhttps://www.linkedin.com/jobs/view/3832619040/?trackingId=BKbRDTFIPt%2BG1h467l9uaQ%3D%3D&amp;refId=ByteString(length%3D16%2Cbytes%3D78939785...0276da00)&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=3_JDW2764zzr81&amp;trk=eml-email_job_alert_digest_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_job_alert_digest_01-job_card-0-jobcard_body-null-jkz8q4~lsz6xqpo~gi-null-null&amp;eid=jkz8q4-lsz6xqpo-gi&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYjM4ZGNiZDM0NDliYTg4ZTZlN2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5NTZjZGU0YzA0MzljZWVhMjE2MGU0MmJhM2ZlN2JiNjFiYzg3ZGYyM2Y2OTFlODQ2LDEsMQ%3D%3D\n\n\n108\nIT Application Development - Intern\nFLEETCOR\n2024.2.23\n\nhttps://www.linkedin.com/jobs/view/3838491749/?trackingId=da00WcbXRGQxMwhXBBfMIQ%3D%3D&amp;refId=ByteString(length%3D16%2Cbytes%3D78939785...0276da00)&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=3_JDW2764zzr81&amp;trk=eml-email_job_alert_digest_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_job_alert_digest_01-job_card-0-jobcard_body-null-jkz8q4~lsz6xqpo~gi-null-null&amp;eid=jkz8q4-lsz6xqpo-gi&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYjM4ZGNiZDM0NDliYTg4ZTZlN2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5NTZjZGU0YzA0MzljZWVhMjE2MGU0MmJhM2ZlN2JiNjFiYzg3ZGYyM2Y2OTFlODQ2LDEsMQ%3D%3D\n\n\n109\nSoftware Engineer Intern, Front End (Summer 2024)\nNotion\n2024.2.24\n3.22 rej\nhttps://www.linkedin.com/jobs/view/3829141664/?alternateChannel=search&amp;refId=wXpJVH%2BvSFqha1opkxlFbA%3D%3D&amp;trackingId=ZEX7nuPeW8pgTFyRQKYpig%3D%3D&amp;trk=d_flagship3_search_srp_jobs\n\n\n110\nSoftware Engineer Summer Internship\nVWH Capital Management, LP\n2024.2.24\n\nhttps://nyu.joinhandshake.com/stu/jobs/8437482?ref=preview-header-click&amp;search_id=703bce9f-d89b-40f6-8f6e-ca7ed54ef2e0\n\n\n111\nFrontend UI Engineer Intern\nSub360, Inc.\n2024.2.24\n\nhttps://nyu.joinhandshake.com/stu/jobs/8554987?ref=preview-header-click&amp;search_id=563f8fa9-7ab6-4f99-8567-9309ce53fbd7\n\n\n112\n2024 Summer Internship (Hybrid)\nFIA Tech\n2024.2.24\n\nhttps://www.ziprecruiter.com/jobs/fia-tech-25472a1f/2024-summer-internship-hybrid-1f66fc3d?zrclid=8ea3bd0c-42c6-48a0-898c-0cafb8c31d2e&amp;lvk=XDRSiVR3EzOznAyCLHEagg.--NGqSkbuS-&amp;contact_id=5be9dac8&amp;expires=1709134509&amp;tsid=111000153&amp;utm_campaign=43024\n\n\n113\nFull Stack Software Engineer INTERN - (Summer 2024)\nAmple, Inc.\n2024.2.24\n4.4 rej\nhttps://simplify.jobs/p/a14c5352-a5da-4b5b-9a4f-93e8c1d3858c/Full-Stack-Software-Engineer-INTERN\n\n\n114\nFullstack Engineer Intern\nPlus\n2024.2.24\n\nhttps://www.linkedin.com/jobs/view/3839104021/?trackingId=h1WvrSK4%2BA9V5OrF1akirg%3D%3D&amp;refId=ByteString(length%3D16%2Cbytes%3Dcde8c461...137d0ad3)&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=0dZ7RibG_6AH81&amp;trk=eml-email_job_alert_digest_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_job_alert_digest_01-job_card-0-jobcard_body-null-jkz8q4~lt0mhifv~z5-null-null&amp;eid=jkz8q4-lt0mhifv-z5&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYmM4ZWNmZDk0MTlmYWU4ODYyN2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5MTJjZGRkZjU3ZmJjZDJiYjQ0MGVjMWM1N2M1ODEyOGU3MTkwMmM2YjI4NGYxZjNhLDEsMQ%3D%3D\n\n\n115\nSoftware engineer, intern\nWatershed\n2024.2.24\n\nhttps://www.linkedin.com/jobs/view/3837351051/?trackingId=XizinSwvvaRE7Hac0z2J4w%3D%3D&amp;refId=ByteString(length%3D16%2Cbytes%3Dcde8c461...137d0ad3)&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=0dZ7RibG_6AH81&amp;trk=eml-email_job_alert_digest_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_job_alert_digest_01-job_card-0-jobcard_body-null-jkz8q4~lt0mhifv~z5-null-null&amp;eid=jkz8q4-lt0mhifv-z5&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYmM4ZWNmZDk0MTlmYWU4ODYyN2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5MTJjZGRkZjU3ZmJjZDJiYjQ0MGVjMWM1N2M1ODEyOGU3MTkwMmM2YjI4NGYxZjNhLDEsMQ%3D%3D\n\n\n116\nIntern - Software Engineer\nSambaNova Systems\n2024.2.24\n3.20 rej\nhttps://www.linkedin.com/jobs/view/3728128369/?trackingId=WTytjHARsiZPRC0vmiFvpA%3D%3D&amp;refId=ByteString(length%3D16%2Cbytes%3Dcde8c461...137d0ad3)&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=0dZ7RibG_6AH81&amp;trk=eml-email_job_alert_digest_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_job_alert_digest_01-job_card-0-jobcard_body-null-jkz8q4~lt0mhifv~z5-null-null&amp;eid=jkz8q4-lt0mhifv-z5&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYmM4ZWNmZDk0MTlmYWU4ODYyN2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5MTJjZGRkZjU3ZmJjZDJiYjQ0MGVjMWM1N2M1ODEyOGU3MTkwMmM2YjI4NGYxZjNhLDEsMQ%3D%3D\n\n\n117\nJava Developer - 2024 Internship\nMotorola Solutions\n2024.2.24\n\nhttps://www.linkedin.com/jobs/view/3815531059/?eBP=CwEAAAGN3bUWsTaRByx5vq0VdCx_NPBWm54pBMzHjiZnlaYGFad8Fix-kho-SgxEMVsUDlH9kfFJaO1sjRJ4VI1ELeHjn6rNSfSH2lK69GJTmNy9D2Z8FXzU72iLb1hZyFPq4RKiZId4Ex5QyhLtNnoGV1ucxZi5OX5916Pfx9koOJ7w1lERdvqFq9wcXZV9n9acKuua0IS9sJ3puqQIe4qFxAgma02_g9CGUDBbj53l4PZECD8Kkf5YrzXTcOoUSMx17HF1e243F-OksVRyfmXXTZAYeVkMX1MlA_MmEzSdvfUuyB4fdTX8UR5q8X0A__rZon28qKf7t01eSWFXqtqXo-D1TX8ivsxg9we5GWdD52pz32lBJLP3x_cHQ12KXK_0usqTnjBTERG-G8j-Tp6iix7vnvp_dfrXYki2fLuX&amp;refId=M0csEqRHRwSmw1ct%2BvnP7g%3D%3D&amp;trackingId=iGpcas8%2BU%2FAfHmnq9FmcoA%3D%3D&amp;trk=flagship3_search_srp_jobs\n\n\n118\nSoftware Engineering Intern\nImprivata\n2024.2.24\n\nhttps://www.linkedin.com/jobs/view/3833846088/?eBP=CwEAAAGN3bUWsmM2qvCEZb5eXsWy5iuf1KCfLWRoakUACCSG1BYZFrhcukMEjS_TFIGnxkhBl9m_RUohjcx7q_kfl0wrLOuBDIVRtqSD8RwBMORF9LylMGmMmuqz-q-ghcCkQ8pY1d8g1mnquCCC8NdENv29DuLGMMgFP4bjB0Z0C5R48Oy8328A-kf3EbTKJtulM1P3PHpaI6pZ_XoPqKAgFUdmhtE58M761Yyt8C4nboPgO2UIrx5VfkqjfYaxc5oLSIgZOdYxStYEYlXSd0c0Lt-TCcYee_h0a5Fsy8sZ38EGpMaGDkHSjObnduuTETNjeoBnC-BMec15ntBHV9o44CxfEi3JXG0rWivM9C3KX3KbO6Tpojfi0b1lYC8Ik8srg9H8TA8yc9boRDTSXCkX8n-xLcRagYxs_FtcSFeK&amp;refId=M0csEqRHRwSmw1ct%2BvnP7g%3D%3D&amp;trackingId=ANikPzb887wX2mvqWt2HcA%3D%3D&amp;trk=flagship3_search_srp_jobs\n\n\n119\nSummer Software Development Intern\nMontrose Environmental Group\n2024.2.24\n\nhttps://www.linkedin.com/jobs/view/3838922026/?eBP=CwEAAAGN3bUWslmdMB3LCs8_n6UtXwsUTC9UzzykvoEomcY1iYNB4SpNGKHL2bufN2LGzReAGfNHDXjtSCWvrfro8GwaN7rfS-6U5jCQzQV8nuvjqKeozLvijyyf-97JEm98fcIyHFsQUQ4ShEhQ7Bh7VZ_eaGhVL5I1SXA-RYqsR1Pu-_dd3h4NfB-mPkbpRKlAIObk8zwytCvN0D7pkgEr-T50DskaAUxLLGCLf8AnuhbfrAWCbAAlz-DugaMNJQGN7RMOMm90SlAF95xcfwWTtlvNa_sEBeR96jlHZ0PR_kNB6Tod-VDlXWmFZqVEZmBWFh6zLwGLaa3d5ukOLd9J_t7cwVMkV48vjqshu7s6LWYrRiAKKZLSx9fygaetgt73nsG5EWum41nQApOYETA8eRhTf5Gtd4qIkaosuLDu&amp;refId=M0csEqRHRwSmw1ct%2BvnP7g%3D%3D&amp;trackingId=H%2B1bOSozZhoaHATbEoScUQ%3D%3D&amp;trk=flagship3_search_srp_jobs\n\n\n120\nWeb Developer - 2024 Summer Intern\nSabre Corporation\n2024.2.24\n3.15 rej\nhttps://www.linkedin.com/jobs/view/3833820537/?alternateChannel=search&amp;refId=M0csEqRHRwSmw1ct%2BvnP7g%3D%3D&amp;trackingId=xwWFq1H9CWvE%2BRE%2Be1gUvQ%3D%3D&amp;trk=d_flagship3_search_srp_jobs\n\n\n121\nSummer Intern - Software Engineering\nIngram Micro\n2024.2.26\n\nhttps://www.linkedin.com/jobs/view/3840336122/?trackingId=UF1esfJcJbhjxkkAZT2Z6A%3D%3D&amp;refId=ByteString(length%3D16%2Cbytes%3D61379a65...c705288b)&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=1xowWjN0Q1DH81&amp;trk=eml-email_job_alert_digest_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_job_alert_digest_01-job_card-0-jobcard_body-null-jkz8q4~lt3h68vj~j-null-null&amp;eid=jkz8q4-lt3h68vj-j&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYmQ4N2NhZDQ0MDk5YTg4ZjZhN2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5NTRkOWJmZTM0Y2ZhY2I4Njc2YjcwZDdiODk0MjAwYWQ4ZjJmMTRlZjhhNTgzY2ZkLDEsMQ%3D%3D\n\n\n122\nSoftware Engineer Intern (Americas Campus - Summer 2024)\nFactSet\n2024.2.26\n\nhttps://www.linkedin.com/jobs/view/3840626639/?eBP=NOT_ELIGIBLE_FOR_CHARGING&amp;refId=HjwP06y8EXgTAUue%2FfeJwA%3D%3D&amp;trackingId=r9ftyHOLBCGftMK1n9vDcw%3D%3D&amp;trk=flagship3_search_srp_jobs\n\n\n123\nSoftware Engineer Internship\nRTI International\n2024.2.26\n\nhttps://www.linkedin.com/jobs/view/3831890397/?alternateChannel=search&amp;refId=HjwP06y8EXgTAUue%2FfeJwA%3D%3D&amp;trackingId=7O5PnIBgivenmXa3Sskuug%3D%3D&amp;trk=d_flagship3_search_srp_jobs\n\n\n124\nSoftware Engineering Intern, Fall 2024\nThe Walt Disney Company\n2024.2.26\n2.27 rej\nhttps://www.linkedin.com/jobs/view/3838607847/?trackingId=lqAXZeNuH7pTM7I5BcTmOA%3D%3D&amp;refId=ByteString(length%3D16%2Cbytes%3D61379a65...c705288b)&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=1xowWjN0Q1DH81&amp;trk=eml-email_job_alert_digest_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_job_alert_digest_01-job_card-0-jobcard_body-null-jkz8q4~lt3h68vj~j-null-null&amp;eid=jkz8q4-lt3h68vj-j&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYmQ4N2NhZDQ0MDk5YTg4ZjZhN2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5NTRkOWJmZTM0Y2ZhY2I4Njc2YjcwZDdiODk0MjAwYWQ4ZjJmMTRlZjhhNTgzY2ZkLDEsMQ%3D%3D\n\n\n125\nUX Engineer: Internship Opportunities\nMicrosoft\n2024.2.26\n3.25 rej\nhttps://www.linkedin.com/jobs/view/3838607847/?trackingId=lqAXZeNuH7pTM7I5BcTmOA%3D%3D&amp;refId=ByteString(length%3D16%2Cbytes%3D61379a65...c705288b)&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=1xowWjN0Q1DH81&amp;trk=eml-email_job_alert_digest_01-job_card-0-jobcard_body&amp;trkEmail=eml-email_job_alert_digest_01-job_card-0-jobcard_body-null-jkz8q4~lt3h68vj~j-null-null&amp;eid=jkz8q4-lt3h68vj-j&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVmYmQ4N2NhZDQ0MDk5YTg4ZjZhN2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5NTRkOWJmZTM0Y2ZhY2I4Njc2YjcwZDdiODk0MjAwYWQ4ZjJmMTRlZjhhNTgzY2ZkLDEsMQ%3D%3D\n\n\n126\nSWE Intern, Summer 2024\nJobfair®\n2024.2.27\n\nhttps://nyu.joinhandshake.com/stu/jobs/8707545?utm_campaign=job_alert_digest&amp;utm_source=activity_mailer&amp;utm_medium=email\n\n\n127\nSoftware Engineer Intern\nNAVEX Global\n2024.2.27\n3.10 rej\nhttps://www.indeed.com/viewjob?jk=660435f37d2e7cdd&amp;tk=1hnmcanj3hdi8800&amp;from=serp&amp;vjs=3\n\n\n128\nFront End Developer Intern\nOSF HealthCare\n2024.2.28\n2.29 rej\nhttps://www.linkedin.com/jobs/view/3841924189/?trackingId=zZjACdt3QNTuYF%2FfrP9lCg%3D%3D&amp;refId=ByteString(length%3D16%2Cbytes%3De156e8b8...aef5092d)&amp;midToken=AQGaJX2eb7MLuQ&amp;midSig=3NKeL8gcRcGr81&amp;trk=eml-email_job_alert_digest_01-job_card-0-job_posting&amp;trkEmail=eml-email_job_alert_digest_01-job_card-0-job_posting-null-jkz8q4~lt6cby45~vb-null-null&amp;eid=jkz8q4-lt6cby45-vb&amp;otpToken=MTMwNDE2ZTQxMjI3Y2FjZGI3MmMwZmViNDExZWVlYjU4YWM5ZDg0OTk5YTk4YTY4N2JjZjA3NmY0ODVlNWVmYmYwZDRkMmU5NzNiNWRkZGY2MmFlZWQ4Mzk4ZTkyNDc0YTdkYjA4YTAwMjllZTNhYjEzYjc4NmE5LDEsMQ%3D%3D\n\n\n129\nFull Stack JavaScript Developer\nJobot\n2024.2.28\n\nhttps://www.linkedin.com/jobs/view/3839789738/\n\n\n130\nSoftware Engineer Intern\nStealth Startup\n2024.2.28\n\nhttps://www.linkedin.com/jobs/view/3839738435\n\n\n131\nSoftware Engineer Intern - Ethos\nEllucian\n2024.2.28\n3.19 rej\nhttps://www.linkedin.com/jobs/view/3825448897\n\n\n132\nSoftware Engineer Intern\nSageSure\n2024.2.28\n3.3 rej\nhttps://www.linkedin.com/jobs/view/3836755200\n\n\n133\nSoftware Engineer Intern\nLacework\n2024.2.28\n\nhttps://www.linkedin.com/jobs/view/3838062047\n\n\n134\n2024 Software Engineering (User Interface) Summer Internship\nSchonfeld\n2024.2.28\n\nhttps://www.linkedin.com/jobs/view/3838145611\n\n\n135\nIntern - Java Developer\nSS&amp;C Technologies\n2024.2.29\n\nhttps://www.linkedin.com/jobs/view/3843335733/\n\n\n136\nSoftware Engineer Intern, Demand and Product Ops\nFreeWheel\n2024.2.29\n\nhttps://www.linkedin.com/jobs/view/384150709\n\n\n137\nSoftware Engineer Intern\nLoop\n2024.3.1\n\nhttps://simplify.jobs/p/b8f67b38-b5d4-47fc-9296-baad0deda9fc/Software-Engineer-Intern\n\n\n138\nInternship, Software Engineer, Energy Engineering (Fall 2024)\nTesla\n2024.3.1\n3.10 rej\nhttps://www.linkedin.com/jobs/view/3841756952/\n\n\n139\nFull-Stack Software Engineering Intern\nOrigami Risk\n2024.3.5\n\nhttps://nyu.joinhandshake.com/stu/jobs/8739090?utm_campaign=job_alert_digest&amp;utm_source=activity_mailer&amp;utm_medium=email\n\n\n140\nSoftware Developer Intern - Summer 2024\nThrivent\n2024.3.5\n4.2 rej\nhttps://nyu.joinhandshake.com/stu/jobs/8747781?utm_campaign=job_alert_digest&amp;utm_source=activity_mailer&amp;utm_medium=email\n\n\n141\nSoftware Engineering Intern - Summer 2024\nEnergy Jobline\n2024.3.5\n\nhttps://www.linkedin.com/jobs/view/3846285514/\n\n\n142\nBIM Web Developer Intern - Summer 2024\nWSP in the U.S.\n2024.3.5\n\nhttps://www.linkedin.com/jobs/view/3828086255\n\n\n143\nSoftware Engineering Intern, Summer 2024\nWhatnot\n2024.3.5\n\nhttps://www.linkedin.com/jobs/view/3847727889/\n\n\n144\nSoftware Engineering Intern (Summer 2024)\nVantage\n2024.3.5\n3.7 rej\nhttps://www.linkedin.com/jobs/view/3846739267\n\n\n145\nFull Stack Engineer Intern\nWeaveGrid\n2024.3.6\n3.25 rej\nhttps://www.linkedin.com/jobs/view/3847321174\n\n\n146\nSoftware Engineering Intern- Spring 2024\nTeradyne\n2024.3.6\n3.13 rej\nhttps://www.linkedin.com/jobs/view/3847608534/\n\n\n147\nSoftware Engineer Intern\nPayPal\n2024.3.9\n\nhttps://simplify.jobs/p/fc7c90d5-3ae4-4cff-91d7-e341f36dd7d7/Software-Engineer-Intern\n\n\n148\nSoftware Engineer Intern\nEtsy\n2024.3.9\n3.12 rej\nhttps://simplify.jobs/p/d01aff33-602e-4e28-8b64-c0f503d9ab57/Software-Engineer-Intern\n\n\n149\nIntern – User Interface\nLightmatter\n2024.3.9\n4.1 rej\nhttps://simplify.jobs/p/4809253e-8b69-45fb-bb98-5e6c5b357d3c/Intern--User-Interface\n\n\n150\nSoftware Engineering Intern\nBraze\n2024.3.11\n\nhttps://www.linkedin.com/jobs/view/3830526239\n\n\n151\nSoftware Engineering Intern\nTrimble Inc.\n2024.3.11\n3.27 rej\nhttps://www.linkedin.com/jobs/view/3838909178\n\n\n152\nSoftware Engineer Intern\nThe Guestbook\n2024.3.11\n3.14 rej\nhttps://www.linkedin.com/jobs/view/3839568550\n\n\n153\nSoftware Engineer Intern\nMoloco\n2024.3.11\n\nhttps://www.linkedin.com/jobs/view/3816303130\n\n\n154\nSoftware Engineering Intern, Summer 2024\nWhatnot\n2024.3.11\n\nhttps://www.linkedin.com/jobs/view/3847727889\n\n\n155\nSoftware Development Intern - Network Automation\nEBSCO Information Services\n2024.3.11\n\nhttps://www.linkedin.com/jobs/view/3840681008\n\n\n156\n2024 Software Engineering Internship\nOpenSesame\n2024.3.11\n\nhttps://www.linkedin.com/jobs/view/3836750264\n\n\n157\nSoftware Engineering Internship - Backend\nidentifeye HEALTH\n2024.3.11\n\nhttps://www.linkedin.com/jobs/view/3823001554\n\n\n158\nStaff Software Engineer, Internal Services and Insights\nJustworks\n2024.3.11\n3.13 rej\nhttps://www.linkedin.com/jobs/view/3808080377\n\n\n159\nSummer 2024 Software Engineering Intern\nIntradiem\n2024.3.11\n\nhttps://www.linkedin.com/jobs/view/3755883029\n\n\n160\nSoftware Development Engineering Intern\nVeeco\n2024.3.11\n\nhttps://www.linkedin.com/jobs/view/3811014983\n\n\n161\nSoftware Engineering Intern\nDeltek\n2024.3.11\n\nhttps://www.linkedin.com/jobs/view/3848397817\n\n\n162\nSoftware Engineer Intern\nViasat Inc\n2024.3.12\n\nhttps://nyu.joinhandshake.com/stu/jobs/8761158?utm_campaign=job_alert_digest&amp;utm_source=activity_mailer&amp;utm_medium=email\n\n\n163\nWeb Application Development Intern\nBeiGene\n2024.3.12\n\nhttps://nyu.joinhandshake.com/stu/jobs/8773395?utm_campaign=job_alert_digest&amp;utm_source=activity_mailer&amp;utm_medium=email\n\n\n164\nSoftware Engineer intern\nSmarsh\n2024.3.13\n\nhttps://simplify.jobs/p/ef02dde7-711f-4bab-a431-39996fed09bb/Software-Engineer-intern\n\n\n165\nIntern – 2024 Summer Internship\nCoalfire\n2024.3.13\n3.19 rej\nhttps://simplify.jobs/p/997317c0-5880-45a0-9110-117e01567a6a/Intern--2024-Summer-Internship\n\n\n166\nSoftware Development Intern\nNuna\n2024.3.13\n\nhttps://simplify.jobs/p/6f861b29-db0b-4a0f-93ca-5551239c2046/Software-Development-Intern\n\n\n167\nSofware Engineering Intern\nDocker\n2024.3.13\n3.14 rej\nhttps://simplify.jobs/p/91e09586-3f8d-460f-aca6-aff425690317/Sofware-Engineering-Intern\n\n\n168\nSoftware Development Intern (Transportation) - Summer 2024\nTyler Technologies\n2024.3.13\n\nhttps://www.linkedin.com/jobs/view/3849720849\n\n\n169\nSoftware Engineer Intern at Chapter One\nChapter One\n2024.3.13\n3.20 rej\nhttps://wellfound.com/jobs/2950460-software-engineer-intern\n\n\n170\nSoftware Engineer Intern at JETSWEAT\nJETSWEAT\n2024.3.13\n\nhttps://wellfound.com/jobs/307020-software-engineer-intern\n\n\n171\nIntern, Full Stack Software Engineer\nAutodesk\n2024.3.13\n3.20 rej\nhttps://autodesk.wd1.myworkdayjobs.com/uni/job/Texas-USA---Remote/Intern--Full-Stack-Software-Engineer_24WD74765\n\n\n172\nFull-Stack Software Engineer Intern at ManageXR\nManageXR\n2024.3.13\n\nhttps://wellfound.com/jobs/2942519-full-stack-software-engineer-intern\n\n\n173\nBackend Engineer Intern\nAutodesk\n2024.3.13\n3.21 rej\nhttps://autodesk.wd1.myworkdayjobs.com/uni/job/AMER---United-States---Arizona---OffsiteHome/Backend-Engineer-Intern_24WD76181-3\n\n\n174\nSoftware Engineering Intern\nHewlett Packard Enterprise\n2024.3.13\n\nhttps://www.linkedin.com/jobs/view/3842563805/\n\n\n175\nSoftware Engineering Intern\nFluidra North America\n2024.3.13\n\nhttps://www.ziprecruiter.com/jobs/fluidra-north-america-2013d93c/software-engineering-intern-c8aabbc7\n\n\n176\nSoftware Development Intern\nCustomShow\n2024.3.13\n\nhttps://jobs.smartrecruiters.com/CustomShow/75886593-software-development-intern\n\n\n177\n2024 Software Engineering (User Interface) Summer Internship\nSchonfeld\n2024.3.13\n\nhttps://boards.greenhouse.io/schonfeld/jobs/5766800\n\n\n178\nFrontend Developer Internship (Remote)\nsubconscious.ai\n2024.3.13\n\nhttps://www.ziprecruiter.com/jobs/subconscious-ai-47c25558/frontend-developer-internship-remote-86cbf6c4\n\n\n179\nSoftware Engineering Intern (Summer 2024)\nVantage\n2024.3.13\n3.18 rej\nhttps://jobs.ashbyhq.com/vantage/3f1a9f78-1a5e-4d62-b56c-a71d6241c77a?utm_source=Simplify&amp;ref=Simplify&amp;src=Simplify\n\n\n180\nSummer 2024 Intern - FedNow Developer Intern\nFederal Reserve Bank of Boston\n2024.3.13\n\nhttps://rb.wd5.myworkdayjobs.com/en-US/FRS/job/Summer-2024-Intern---FedNow-Developer-Intern_R-0000021670-1\n\n\n181\nFrontend Developer (React) - Remote Internship\nGBCS Group\n2024.3.13\n\nhttps://nyu.joinhandshake.com/stu/jobs/7612412\n\n\n182\nFull Stack Intern\nORKA\n2024.3.13\n\nhttps://nyu.joinhandshake.com/stu/jobs/8540977\n\n\n183\nSoftware Engineer Intern\nTencent\n2024.3.16\n\nhttps://www.linkedin.com/jobs/view/3855215076\n\n\n\n Fulltime\n\n\n\n序号\n公司\n职位\n申请日期\n时间线\n链接\n\n\n\n\n1\nSoFi\nSoftware Engineer\n2024/8/10\n9.30 rej\nhttps://www.sofi.com/careers/job/?gh_jid=6082594003\n\n\n2\nDatabricks\nSoftware Engineer - New Grad (2025 Start) Mountain View, California\n2024/8/10\n\nhttps://www.databricks.com/company/careers/university-recruiting/software-engineer---new-grad-2025-start-6865698002\n\n\n3\nSpotify\nBackend Engineer – Backstage Data Platform\n2024/8/10\n8.14 rej\nhttps://jobs.lever.co/spotify/af52d791-7cdc-4eaa-ac8c-ee811b3bd37e\n\n\n4\nState Farm\nSoftware Engineer (Remote or Hybrid)\n2024/8/10\n8.13 rej\nhttps://jobs.statefarm.com/main/jobs/37694\n\n\n5\nAdobe\nSoftware Development Engineer\n2024/8/10\n8.21 rej\nhttps://careers.adobe.com/us/en/job/ADOBUSR146800EXTERNALENUS/Software-Development-Engineer\n\n\n6\nJuge\nFull Stack Java with Node.js - W2 only\n2024/8/10\n\nhttps://www.judge.com/jobs/details/1051097/\n\n\n7\nSamsung Electronics America\nSoftware Engineer\n2024/8/10\n\nhttps://sec.wd3.myworkdayjobs.com/zh-CN/Samsung_Careers/job/645-Clyde-Avenue-Mountain-View-CA-USA/Software-Engineer_R93611-1\n\n\n8\nFlyHigh Group, Inc.\nJunior SDE\n2024/8/10\n\nhttps://www.linkedin.com/jobs/view/3995432642/\n\n\n9\nHertz\nSoftware Engineer\n2024/8/10\n\nhttps://fa-evlf-saasfaprod1.fa.ocs.oraclecloud.com/hcmUI/CandidateExperience/en/sites/CX_1/job/27323/\n\n\n10\nRoblox\n[2025] Software Engineer - New Graduate\n2024/8/10\n8.11 rej\nhttps://careers.roblox.com/jobs/6086753\n\n\n11\nPalantir Technologies\nSoftware Engineer, New Grad\n2024/8/10\n\nhttps://jobs.lever.co/palantir/c34b424e-caf2-455a-b104-ae1096ccca29\n\n\n12\nUp &amp; Up\nSoftware Engineer\n2024/8/10\n\nhttps://nyu.joinhandshake.com/stu/jobs/9135674\n\n\n13\nIMC Trading\nGraduate Software Engineer\n2024/8/10\n9.6 rej\nhttps://boards.eu.greenhouse.io/imc/jobs/4347769101?gh_src=b43d2362teu\n\n\n14\nFreddie Mac\nTechnology Analyst - Software Developer/Programmer (Hybrid - 3 Days in Office)\n2024/8/10\n\nhttps://careers.freddiemac.com/us/en/job/JR13345/Technology-Analyst-Software-Developer-Programmer-Hybrid-3-Days-in-Office\n\n\n15\nNoon\nSoftware Development Engineer\n2024/8/10\n\nhttps://nyu.joinhandshake.com/stu/jobs/9114846\n\n\n16\nInstalily, Inc.\nSoftware Engineer\n2024/8/10\n\nhttps://nyu.joinhandshake.com/stu/jobs/8819573\n\n\n17\nNightfall AI\nNew Grad Backend Engineer Contract Position\n2024/8/10\n\nhttps://nyu.joinhandshake.com/stu/jobs/8897390\n\n\n18\nCodeium\nSoftware Engineer\n2024/8/10\n8.13 rej\nhttps://jobs.ashbyhq.com/codeium/c3d54dc9-d305-4f9c-93a4-cffa98e963e7\n\n\n19\nAltera.AL, Inc\nSoftware Engineer\n2024/8/10\n\nhttps://nyu.joinhandshake.com/stu/jobs/9067494\n\n\n20\nAspen Dental\nSoftware Engineer\n2024/8/10\n\nhttps://nyu.joinhandshake.com/stu/jobs/8927667\n\n\n21\nHive\nSoftware Engineer - Backend\n2024/8/10\n\nhttps://jobs.lever.co/hive/9461e715-9e58-4414-bc9b-13e449f92b08\n\n\n22\nWhova, Inc.\nSoftware Engineer\n2024/8/10\n\nhttps://nyu.joinhandshake.com/stu/jobs/8931606\n\n\n23\nDify.AI\nFrontend Engineer\n2024/8/10\n\nhttps://nyu.joinhandshake.com/stu/jobs/9114843\n\n\n24\nVeeva Systems\nAssociate Software Engineer in Test\n2024/8/12\n8.14 rej\nhttps://careers.veeva.com/job/8683a486-a11b-44be-8824-d3afdaa37b2d/associate-software-engineer-in-test-pleasanton-ca/\n\n\n25\nYangtze River Consulting Service LLC\nsoftware developer\n2024/8/12\n\nhttps://nyu.joinhandshake.com/stu/jobs/8401668\n\n\n26\nCloud Resources LLC\nSoftware Engineer\n2024/8/12\n\nhttps://nyu.joinhandshake.com/stu/jobs/8115318?\n\n\n27\nRevature\nEntry Level Software Engineer\n2024/8/12\n8.19 rej\nhttps://revature.com/jobs/entry-level-software-engineer-3\n\n\n28\nCodeworks IT Careers\nJava Software Development Engineer\n2024/8/12\n\nhttps://mycompas.net/codeworks/?cjobid=W4mQbZNOeGc&amp;postid=4Y21vDHfvI4\n\n\n29\nAssociate Staffing\nSoftware Engineer\n2024/8/12\n\nhttps://www.linkedin.com/jobs/view/3918942028/\n\n\n30\nWalmart\nFull Stack Software Engineer\n2024/8/12\n\nhttps://walmart.wd5.myworkdayjobs.com/WalmartExternal/job/Sunnyvale-CA/Full-Stack-Software-Engineer\\_R-1866951\n\n\n31\nBeaconFire Inc\nJava Software Engineer\n2024/8/12\n\nhttps://www.linkedin.com/jobs/view/3977286979\n\n\n32\nStuut\nSoftware Engineer Intern (Graduate Students in NYC)\n2024/8/12\n8.16 rej\nhttps://www.linkedin.com/jobs/view/3999785772\n\n\n33\nCodeium\nSoftware Engineer (New Grad)\n2024/8/14\n\nhttps://jobs.ashbyhq.com/codeium/cb10c443-7e5b-44ac-8b21-0edd60b22095\n\n\n34\nConfluent\n2025 Software Engineer\n2024/8/14\n\nhttps://careers.confluent.io/jobs/14738286-2025-software-engineer?utm_source=Simplify&amp;ref=Simplify\n\n\n35\nMarshall Wace\nTechnology Graduate Scheme 2025 - New York\n2024/8/14\n8.16 rej\nhttps://job-boards.greenhouse.io/mw-tech-grad/jobs/7499717002?gh_src=bb1e940f2us\n\n\n36\nAxle Health\nSoftware Engineer (New Grad)\n2024/8/14\n8.14 rej\nhttps://www.ycombinator.com/companies/axle-health/jobs/ommmQqU-software-engineer-new-grad\n\n\n37\nElectronX\nNew Grad: Software Engineer\n2024/8/14\n\nhttps://jobs.ashbyhq.com/electronx/42123d2b-31b3-464c-a0cd-4c7a7e62d672\n\n\n38\nOptiver\nGraduate Software Engineer (2025 Start – Austin)\n2024/8/14\n8.15 oa\nhttps://optiver.com/working-at-optiver/career-opportunities/7498618002\n\n\n39\nCitadel Securities\nSoftware Engineer – 2025 University Graduate (US)\n2024/8/14\n8.14 oa\nhttps://www.citadelsecurities.com/careers/details/software-engineer-2025-university-graduate-us-2\n\n\n40\nAutodesk\nSoftware Engineer\n2024/8/15\n10.3 rej\nhttps://autodesk.wd1.myworkdayjobs.com/Ext/job/Novi-MI-USA/Software-Engineer\\_24WD80650\n\n\n41\nQualtrics\nSoftware Engineer I, Voice - Seattle\n2024/8/15\n9.9 rej\nhttps://www.qualtrics.com/careers/us/en/job/QUALUS6171618EXTERNALENUS/Software-Engineer-I-Voice-Seattle\n\n\n42\nPayPal\nSoftware Engineer - Recent Graduate\n2024/8/15\n8.28 rej\nhttps://paypal.eightfold.ai/careers?pid\\=274901907358\n\n\n43\nMicrosoft\nSoftware Engineering\n2024/8/16\n9.7 rej\nhttps://jobs.careers.microsoft.com/us/en/job/1753111/Software-Engineer\n\n\n44\nRubrik\nSoftware Engineer\n2024/8/16\n\nhttps://www.rubrik.com/company/careers/departments/job.6175979\n\n\n45\nFigma\nSoftware Engineer - Early Career (2025)\n2024/8/26\n\nhttps://job-boards.greenhouse.io/figma/jobs/5227935004\n\n\n46\nZoom\nAI Software Engineer\n2024/8/26\n8.28 rej\nhttps://zoom.wd5.myworkdayjobs.com/Zoom/job/Bay-Area-CA/AI-Software-Engineer\\_R12973-1\n\n\n47\nOracle\nSoftware Engineer - Fusion Applications Development\n2024/8/28\n\nhttps://eeho.fa.us2.oraclecloud.com/hcmUI/CandidateExperience/en/sites/jobsearch/job/255788\n\n\n48\nCisco\nSoftware Engineer I (Full Time) United States\n2024/8/29\n8.30 rej\nhttps://jobs.cisco.com/jobs/ProjectDetail/Software-Engineer-I-Full-Time-United-States/1426825\n\n\n49\nMicrosoft\nSoftware Engineer I\n2024/8/29\n9.13 rej\nhttps://jobs.careers.microsoft.com/us/en/job/1752115/Software-Engineer-I\n\n\n50\nByteDance\nBackend Software Engineer Graduate (Customer Service Platform) -2025 Start (BS/MS)\n2024/8/29\n\nhttps://jobs.bytedance.com/en/position/7398733461756840230/detail\n\n\n51\nMeta\nSoftware Engineer, Product\n2024/9/1\n\nhttps://www.metacareers.com/jobs/1766960080500830\n\n\n52\nStripe\nSoftware Engineer, New Grad\n2024/9/1\n\nhttps://stripe.com/jobs/listing/software-engineer-new-grad/6142741\n\n\n53\nApplied Intuition\nSoftware Engineer - New Grad\n2024/9/1\n9.16 rej\nhttps://boards.greenhouse.io/appliedintuition/jobs/4420849005\n\n\n54\nGlean\nSoftware Engineer - University Grad\n2024/9/1\n\nhttps://boards.greenhouse.io/gleanwork/jobs/4449298005\n\n\n55\nScale AI\nSoftware Engineer - New Grad\n2024/9/1\n\nhttps://job-boards.greenhouse.io/scaleai/jobs/4463083005\n\n\n56\nWyetech LLC\nSoftware Engineer 1/Jr. Java Developer\n2024/9/1\n\nhttps://jobs.lever.co/wyetechllc/fb36d3fc-dfc9-4cae-89ef-7cd3632b2ba8/\n\n\n57\nWiley Edge\nJunior Software Engineer\n2024/9/1\n9.2 rej\nhttps://job-boards.greenhouse.io/wileyedgerecruitingportal/jobs/4391958006\n\n\n58\nZip\nSoftware Engineer, New Grad (2025 Start)\n2024/9/1\n\nhttps://job-boards.greenhouse.io/zip/jobs/5234060004\n\n\n59\nWhatnot\nSoftware Engineer, 2025 New Grad\n2024/9/2\n\nhttps://job-boards.greenhouse.io/whatnot/jobs/5247525004\n\n\n60\nDatadog\nSoftware Engineer - Early Career\n2024/9/3\n10.15 rej\nhttps://careers.datadoghq.com/detail/6182685/?gh_jid=6182685\n\n\n61\nRVO Health\n2025 Early Career Program: Software Engineering\n2024/9/3\n9.5 rej\nhttps://job-boards.greenhouse.io/rvohealth/jobs/4455898005\n\n\n62\nZipRecruiter\nSoftware Engineer - New Grad\n2024/9/3\n9.17 oa\nhttps://job-boards.greenhouse.io/ziprecruiter/jobs/6165341\n\n\n63\nSignify Health\nSoftware Engineer I - Data\n2024/9/4\n\nhttps://www.signifyhealth.com/careers-corporate?gh_jid=6108628003\n\n\n64\nOKX\nSoftware Engineer, New Grad\n2024/9/4\n\nhttps://job-boards.greenhouse.io/okx/jobs/6081008003\n\n\n65\nServiceNow\nUTG - Software Engineer - New College Grad\n2024/9/6\n10.9 rej\nhttps://jobs.smartrecruiters.com/ServiceNow/744000011667145\n\n\n66\nPylon\n(New grad) Software Engineer\n2024/9/6\n\nhttps://jobs.ashbyhq.com/pylon-labs/ecf0d509-cfb9-43c6-b628-1e685d6f5f42/application\n\n\n67\nNewsBreak\nSoftware Engineer (Junior &amp; New Grad)\n2024/9/6\n\nhttps://job-boards.greenhouse.io/newsbreak/jobs/4054592006\n\n\n68\nSalesforce\nSoftware Engineering AMTS/MTS (New Grad)\n2024/9/6\n\nhttps://salesforce.wd12.myworkdayjobs.com/en-us/External\\_Career\\_Site/job/California---San-Francisco/Software-Engineering-AMTS-MTS--New-Grad-\\_JR264567-1\n\n\n69\nIXL Learning\nSoftware Engineer, New Grad\n2024/9/6\n\nhttps://www.ixl.com/company/careers?gh_jid=7535059002\n\n\n70\nPolicyMe\nJunior Software Engineer (Remote)\n2024/9/6\n\nhttps://jobs.lever.co/policyme/b6b41cf8-fd9f-48d8-864c-671b53fc7042\n\n\n71\nRubrik\nSoftware Engineer- VMware\n2024/9/8\n\nhttps://www.linkedin.com/jobs/view/4003115482/\n\n\n72\nDisney Careers\nSoftware Engineer I\n2024/9/11\n9.11 rej\nhttps://disney.wd5.myworkdayjobs.com/en-US/disneycareer/job/Santa-Monica-CA-USA/Software-Engineer-I\\_10097956\n\n\n73\nPersona\nSoftware Engineer (Entry level)\n2024/9/11\n10.27 oa 10.28 rej\nhttps://jobs.lever.co/persona/70dd3239-d020-4035-aaab-16bd289642f7/\n\n\n74\nSubsplash\nSoftware Development Engineer I (Back-end)\n2024/9/11\n9.11 rej\nhttps://boards.greenhouse.io/subsplash/jobs/7631988002\n\n\n75\nPerpay\nSoftware Engineer, New Grad\n2024/9/11\n9.24 rej\nhttps://boards.greenhouse.io/perpay/jobs/4034578007\n\n\n76\nTwich\nSystems Development Engineer\n2024/9/11\n\nhttps://boards.greenhouse.io/twitch/jobs/7602955002\n\n\n77\nAdobe\n2025 University Graduate - Software Engineer\n2024/9/11\n10.1 rej\nhttps://careers.adobe.com/us/en/job/ADOBUSR148217EXTERNALENUS/2025-University-Graduate-Software-Engineer\n\n\n78\nIBM\nSoftware Developer\n2024/9/11\n9.19 oa 9.21 rej\nhttps://careers.ibm.com/job/20993575/software-developer-austin-tx/\n\n\n79\nAlto Pharmacy\nEarly Career Software Engineer\n2024/9/12\n9.22 rej\nhttps://boards.greenhouse.io/alto/jobs/6235262\n\n\n80\nChime\nSoftware Engineer- New Grad [For Fall 2024 Event Attendees]\n2024/9/12\n\nhttps://boards.greenhouse.io/chime/jobs/7626713002\n\n\n81\nTencent\nSecurity Software Engineer I\n2024/9/12\n\nhttps://tencent.wd1.myworkdayjobs.com/en-US/Tencent_Careers/job/US-Palo-Alto/Security-Engineer-I_R103856\n\n\n82\nJerry\nSoftware Engineer I (Palo Alto)\n2024/9/15\n\nhttps://jobs.ashbyhq.com/Jerry/01a0c07a-ebc9-4bfb-a99d-21eafaf9be38\n\n\n83\nSplunk\nSoftware Engineer - Early in Career (Backend/Full-stack, Immediate Start Date)\n2024/9/15\n\nhttps://www.splunk.com/en_us/careers/jobs/software-engineer-early-in-29740.html\n\n\n84\nNetflix\nNew Grad Software Engineer (2025)\n2024/9/15\n\nhttps://explore.jobs.netflix.net/careers/job?domain\\=netflix.com&amp;pid\\=790298755510\n\n\n85\nKalder\nNew Grad Software Engineer 2023\n2024/9/15\n\nhttps://www.adzuna.com/details/4464899452\n\n\n86\nWeRide\nNew Grads 2025 - General Software Engineer\n2024/9/16\n\nhttps://jobs.lever.co/weride/c6199fb6-cd1e-4f11-b51c-24702ddfa63\n\n\n87\nVisa\nSoftware Engineer, New College Grad - 2025\n2024/9/16\n9.18 rej\nhttps://jobs.smartrecruiters.com/Visa/744000014248486\n\n\n88\nWestern Digital\nNew College Grad Engineer\n2024/9/16\n9.27 rej\nhttps://jobs.smartrecruiters.com/WesternDigital/744000014221462\n\n\n89\nPinterest\nUniversity Grad Software Engineer (USA)\n2024/9/19\n9.22 rej\nhttps://www.pinterestcareers.com/jobs/6231229/university-grad-software-engineer-usa/\n\n\n90\nGenesis Therapeutics\nSoftware Engineer – New Grad\n2024/9/19\n\nhttps://jobs.lever.co/genesistherapeutics/528d24ad-745a-4eed-a883-c0fbba5aa624/\n\n\n91\nELEVI Associates\nEntry Level Software Engineer\n2024/9/21\n9.23 rej\nhttps://job-boards.greenhouse.io/eleviassociates/jobs/6213926003\n\n\n92\nMagical\nNew Grad Front End/Fullstack Engineer (Remote, North America)\n2024/9/22\n\nhttps://jobs.ashbyhq.com/magical/70434e4d-91a4-47b3-8cd1-a7adf8fcd718\n\n\n93\nRocket Software\nSoftware Engineer I\n2024/9/22\n\nhttps://rocket.wd5.myworkdayjobs.com/en-US/rocket_careers/job/Newbury-United-Kingdom/Software-Engineer-I_R2024-5044?utm_source=Simplify\n\n\n94\nTiktok\nSoftware Engineer Graduate (TikTok Short Video) - 2025 Start (Bachelors/Master)\n2024/9/24\n10.3 oa 10.8 rej\nhttps://careers.tiktok.com/position/7394316025958828325/detail\n\n\n95\nNominal\nSoftware Engineer - New Grad\n2024/9/24\n\nhttps://jobs.lever.co/nominal/89854893-f950-4b95-afd9-415190bbcd1c/\n\n\n96\nSnap Inc.\nSoftware Engineer, Full Stack, New Grad Engineer\n2024/9/27\n10.17 rej\nhttps://wd1.myworkdaysite.com/recruiting/snapchat/snap/job/Seattle-Washington/Software-Engineer--Full-Stack--New-Grad-Engineer\\_R0037143-1\n\n\n97\nBooz Allen\nSoftware Developer, Junior\n2024/10/2\n10.4 rej\nhttps://bah.wd1.myworkdayjobs.com/en-US/BAH_Jobs/job/McLean-VA/Software-Developer--Junior_R0206889-1?utm_source=Simplify&amp;ref=Simplify\n\n\n98\nCodazen\nFull-Stack Engineer Summer 2025 New Grad\n2024/10/2\n\nhttps://boards.greenhouse.io/codazen/jobs/5338061004?utm\\_source\\=Simplify&amp;ref\\=Simplify\n\n\n99\nSMX\nJunior Software Engineer (TS/SCI CI Poly) (3848)\n2024/10/2\n10.3 rej\nhttps://www.smxtech.com/jobs/smxtech/junior-software-engineer-ts-sci-ci-poly-3848/?gh_jid=6228060003\n\n\n100\nSeatGeek\nSoftware Engineer – New Grad\n2024/10/2\n\nhttps://seatgeek.com/jobs/6295342?gh_jid=6295342&amp;utm_source=Simplify&amp;ref=Simplify\n\n\n101\nGrand Rounds\nFull Stack Software Engineer, Treat Team (New College Grad)\n2024/10/2\n\nhttps://jobs.lever.co/includedhealth/84ee4d3b-ee3e-461f-ad77-db0d82ee65f6\n\n\n102\nKLA\nSoftware Engineer\n2024/10/3\n\nhttps://kla.wd1.myworkdayjobs.com/en-US/Search/job/Software-Engineer_2426018-1\n\n\n103\nNVIDIA\nSoftware Engineer, Big Data - New College Grad 2025\n2024/10/7\n\nhttps://nvidia.wd5.myworkdayjobs.com/en-US/nvidiaexternalcareersite/job/Software-Engineer--Big-Data---New-College-Grad-2025_JR1988904\n\n\n104\nFlexport\nSoftware Engineer I, Forwarding Applications\n2024/10/7\n10.9 rej\nhttps://job-boards.greenhouse.io/flexport/jobs/6309298?utm_source=Simplify&amp;ref=Simplify\n\n\n105\nCodazen\nFull-Stack Engineer Summer 2025 New Grad\n2024/10/9\n\nhttps://boards.greenhouse.io/codazen/jobs/5338060004?utm_source=Simplify&amp;gh_src=Simplify#app\n\n\n106\nUniversal Music Group\nJunior Software Developer\n2024/10/9\n10.17 rej\nhttps://umusic.wd5.myworkdayjobs.com/en-US/UMGUS/job/New-York-New-York/Junior-Software-Developer_UMG-17506\n\n\n107\nHorace Mann\nSoftware Engineer I\n2024/10/12\n\nhttps://boards.greenhouse.io/horacemannservicecorporation/jobs/5346297004?utm_source=Simplify&amp;ref=Simplify\n\n\n108\nEpic\nSoftware Developer\n2024/10/16\n10.23 rej\nhttps://epic.avature.net/DataCompletionRequest?uid\\=Nmm62g7Xxp1HXgcW&amp;folderId\\=740&amp;emailCampaignId\\=521\n\n\n109\nAdobe\n2025 University Graduate - Software Development Engineer\n2024/10/17\n\nhttps://adobe.wd5.myworkdayjobs.com/external_experienced/job/San-Jose/XMLNAME-2025-University-Graduate---Software-Development-Engineer_R148212?utm_source=Simplify&amp;ref=Simplify\n\n\n110\nHeyGen\nSoftware Engineer, University Graduate\n2024/10/23\n\nhttps://job-boards.greenhouse.io/heygen/jobs/4546885007\n\n\n111\nOld Mission\nCollege Graduates - Full-Time - Junior Full-Stack Engineer (2025)\n2024/10/23\n10.29 rej\nhttps://www.oldmissioncapital.com/careers/?gh_jid=6113554003\n\n\n\n","categories":["日记"],"tags":["美国","实习","秋招","校招"]}]